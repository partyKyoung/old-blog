<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 2.13.8"/><title data-react-helmet="true"></title><link rel="shortcut icon" href="/icons/icon-48x48.png?v=008654519ce705ac7bc44303a9014606"/><link rel="manifest" href="/manifest.webmanifest"/><meta name="theme-color" content="#663399"/><link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png?v=008654519ce705ac7bc44303a9014606"/><style data-styled="" data-styled-version="4.3.2"></style><link as="script" rel="preload" href="/component---src-templates-blog-template-tsx-e07aa2a173d2d60ceec3.js"/><link as="script" rel="preload" href="/app-8ed2bcd8d918eca8e6e5.js"/><link as="script" rel="preload" href="/webpack-runtime-ee1f602fcca81f26856b.js"/><link as="fetch" rel="preload" href="/page-data/back-end/nodejs/nodejs/page-data.json" crossorigin="use-credentials"/></head><body><noscript id="gatsby-noscript">This app works best with JavaScript enabled.</noscript><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group" id="gatsby-focus-wrapper"><div class="blog-post-container"><div class="blog-post"><h1>Node.js</h1><h2>July 17, 2018</h2><div class="blog-post-content"><h2>Node.js?</h2>
<p>Node.js는 크롬 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임이다. Node.js는 이벤트 기반, 논블로킹 I/O모델을 사용해 가볍고 효울적이다.
런타임은 특정 언어로 만든 프로그램들을 실행할 수 있는 환경을 뜻한다. 따라서 Node.js는 JavaScript 프로그램을 컴퓨터에서 실행할 수 있게 해준다. 자바스크립트 애플리케이션이 서버로서 기능하기 위한 도구를 제공하므로 서버 역할도 수행할 수 있다.</p>
<p>노드는 V8과 libuv라는 라이브러리를 사용한다. libuv 라이브러리는 노드의 특성인 이벤트 기반, 논블로킹 I/O모델을 구현하고 있다.</p>
<h2>Node.js 특징</h2>
<h3>이벤트 기반</h3>
<p>이벤트 기반이란 이벤트(클릭이나 네트워크 요청 등)가 발생할 때 미리 지정해둔 작업을 수행하는 방식을 의미한다. 이벤트 기반 시스템에서는 특정 이벤트가 발생할 때 무엇을 할지 미리 등록해두어야 한다. 이것을 이벤트 리스너에 콜백 함수를 등록한다고 포현한다.</p>
<blockquote>
<p>콜백함수: javaScript 에서는 함수를 다른 함수의 파라미터로 전달할 수 있다. 파라미터로 전달된 함수를 다른 내부에서 호출하는 것이 콜백 함수 이다. 콜백은 일반적으로 일회성 응답에 대한 로직을 정의하는데 사용된다.</p>
</blockquote>
<p>노드도 이벤트 기반 방식으로 동작하므로 이벤트가 발생하면 이벤트 리스너에 등록해둔 콜백함수를 호출한다. 발생한 이벤트가 없거나 발생했던 이벤트를 다 처리하면 노드는 다음 이벤트가 발생할 때까지 대기한다. 여러 이벤트가 동시에 발생했을 때 어떤 순서로 콜백 함수를 호출할지를 이벤트 루프가 판단한다.</p>
<blockquote>
<p>이벤트 루프: 이벤트 발생 시 호출할 콜백 함수들을 관리하고, 호출된 콜백 함수의 실행 순서를 결정하는 역할을 담당한다. 노드가 종료될 때가지 이벤트 처리를 위한 작업을 반복하므로 루프라고 불린다.
태스크 큐: 이벤트 발생 후 호출되어야 할 콜백 함수들이 기다리는 공간이다. 콜백들이 이벤트 루프가 정한 순서대로 줄을 서 있으므로 콜백 큐라고 부른다.
백그라운드: 타이머나 I/O 작업 콜백 또는 이벤트 리스너들이 대기하는 곳이다.</p>
</blockquote>
<h3>Non-Blocking I/O</h3>
<p>Non-Blocking이란 이전 작업이 완료될 때까지 멈추지 않고 다음 작업을 수행함을 뜻한다. 이벤트 루프를 잘 활용하면 오래 걸리는 함수를 벡그라운드로 보내서 다음 코드가 먼저 실행되게 하고, 그 함수가 다시 태스크 큐를 거쳐 호출 스택으로 올라오기를 기다리는 논블로킹 방식으로 오래 걸리는 작업을 효율적으로 처리할 수 있다.</p>
<p>현재 노드 프로세스 외의 다른 컴퓨팅 자원을 사용할 수 있는 I/O 작업이 주로 논블로킹 방식으로 시간적 이득을 많이 본다. I/O작업을 할 대 노드는 논블로킹 방식으로 동작한다.</p>
<ul>
<li>Bloking</li>
</ul>
<pre><code class="language-javascript">var ccontent = file.read('a.txt');

대기 후... // 위의 file.read 작업이 끝나야 밑의 작업들이 마저 실행 됨

doShow(contents);

var result = doAdd(10, 10);
</code></pre>
<p>동기는 프로그램이 어떤 작업을 시작 했을 때 그 작업이 다 끝난 후에야 다른 작업을 할 수 있다.
이러한 방식은 프로그램이 실행하는 중간중간 대기 시간이 발생하면서 속도가 느려지는 문제가 생긴다.</p>
<ul>
<li>Non-Blocking</li>
</ul>
<pre><code class="language-javascript">file.read("a.txt", contents => {
  doShow(contents) // file.read 작업이 끝나면 콜백 함수 실행
})

var result = doAdd(10, 10) // 다른 작업을 이어 나감
</code></pre>
<h3>싱글 스레드</h3>
<p>멀티 스레드인 시스템에서는 여러 개의 스레드가 일을 나눠서 처리할 수 있으나 노드는 싱글 스레드이므로 주어진 작업을 혼자서 처리해야 한다.
자바스크립트와 노드에서 논블로킹이 중요한 이유는 바로 싱글 스레드이기 때문이다. 한 번에 한 가지 일밖에 처리하지 못하므로 어떠한 작업에서 블로킹이 발생하면 다음 일을 처리하지 못한다.</p>
<p>노드 프로세스도 내부적으로는 스레드를 여러개 가지고 있다. 하지만 직접 제어할 수 있는 스레드는 하나뿐이므로 싱글 스레드라고 부른다.</p>
<p>싱글 스레드 여러 개를 사용해 멀티 스레딩과 비슷한 기능을 하게 할 수 있다. 하지만 엄밀히 말하면 멀티 스레딩이라기 보다는 멀티 프로세싱에 가깝다. 노드는 스레드를 늘리는 대신 프로세스 자체를 복사해 여러 작업을 동시에 처리하는 멀티 프로세싱 방식을 택했다. 자바스크립트 언어 자체가 싱글 스레드 특성을 띠고 있기 때문이다.</p>
<p>싱글 스레드여서 멀티 스레드 방식보다는 컴퓨터를 적게 사용하는 장점이 있지만 CPU 코어를 하나밖에 사용하지 못하는 단점도 있다.</p>
<h2>단일 스레드 이벤트 루프</h2>
<p>Node.js는 단일 쓰레드 이벤트 루프 모델을 사용한다.</p>
<h3>단일 스레드 이벤트 루프 모델 처리 단계</h3>
<ul>
<li>클라이언트가 Node.js 서버에게 Request 를 날린다.</li>
<li>Node.js 서버는 내부적으로 제한된 스레드 풀을 유지 관리하여 클라잉언트 요청에 서비스를 제공한다.</li>
<li>Node.js 서버는 여러 Request 를 받고 Queue 에 저장한다. 이 Queue 를 이벤트 대기 Queue 라고 한다.</li>
<li>Node.js 서버는 내부적으로 Event Loop 를 가지고 있다. (요청을 수신하고 처리하기 위해 무한 루프를 사용하기 때문에 Event Loop 라는 이름을 가지고 있다.)</li>
<li>Event Loop 는 단일스레드만 사용한다. 이것이 Node.js 프로세싱 모델의 핵심이다.</li>
<li>Event Loop 는 Event Queue 에 Request 가 있는지 체크한다. Event Queue 가 빈 상태라면 Request 를 무기한 기다린다.</li>
<li>
<p>Request 가 있으면 Event Queue 로 부터 Request 를 꺼내 처리를 시작한다.</p>
<ul>
<li>만약 Bloking IO 작업을 요구하지 않는 경우라면 Request 를 처리하고 Response 를 준비한 다음 클라이언트에게 보낸다.</li>
<li>데이터베이스, 파일시스템, 외부 서비스와의 상호작용과 같은 Bloking IO 작업을 요구하는 경우라면 다른 접근 방식을 따른다.</li>
<li>내부 스레드 풀에서 스레드 가용성 확인한다.</li>
<li>Client Request 를 스레드 하나에 할당한다.</li>
<li>스레드가 해당 요청을 처리하고, 처리하며, IO 작업을 차단하고, 응답을 준비한 후 이벤트 루프로 반환한다.</li>
<li>이벤트 루프가 차례로 해당 응답을 해당 클라이언트에 전송한다.</li>
</ul>
</li>
</ul>
<h2>Node.js를 쓰면 좋은 곳</h2>
<p>노드는 개수는 많지만 크기는 작은 데이터를 실시간으로 주고 받는데 적합하다.</p>
<ul>
<li>입출력이 잦은 어플리케이션
노드는 libuv 라이브러리를 사용하여 I/O 작업을 논블로킹 방식으로 처리하기 때문에 스레드 하나가 많은 수의 I/O를 혼자서도 감당할 수 있다.</li>
<li>데이터 스트리밍 어플리케이션</li>
<li>데이터를 실시간으로 다루는 어플리케이션</li>
<li>JSON API 기반 어플리케이션
요즘은 XML 대신 JSON을 사용해서 데이터를 주고 받는데 JSON이 자바스크립트 형식이어서 노드에서는 쉽게 처리할 수 있다.</li>
<li>싱글페이지 어플리케이션
노드는 자바스크립트 런타임이기 때문에 용도가 서버에만 한정된 것이 아니라 웹, 모바일, 데스크톱 애플리케이션 개발에도 사용된다.</li>
</ul>
<p>코드가 CPU 연산을 많이 요구하면 블로킹이 발생해 스레드 하나가 감당하기 어렵기 때문에 CPU 부하가 큰 작업에는 적합하지 않다.</p>
<h2>Reference</h2>
<ul>
<li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&#x26;mallGb=KOR&#x26;barcode=9791160505221&#x26;orderClick=LEA&#x26;Kc=">Node.js 교과서</a></li>
<li><a href="https://velopert.com/133">[Node.JS] 강좌 01편: 소개</a></li>
<li><a href="https://www.journaldev.com/7462/node-js-architecture-single-threaded-event-loop">Node JS Architecture – Single Threaded Event Loop</a> -<a href="http://sjh836.tistory.com/149?fbclid=IwAR0I0tS30AIttOa5gRFbgc_3GRS7MljHr7bVJYwpw7bCLeSKhIruxUi34ko">nodejs의 내부 동작 원리 (libuv, 이벤트루프, 워커쓰레드, 비동기)</a></li>
</ul></div></div></div></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/back-end/nodejs/nodejs";window.webpackCompilationHash="306c1024de87b0321d7d";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-8ed2bcd8d918eca8e6e5.js"],"component---src-templates-blog-template-tsx":["/component---src-templates-blog-template-tsx-e07aa2a173d2d60ceec3.js"],"component---src-pages-about-tsx":["/component---src-pages-about-tsx-4ac013acf8f3c9b6e0b4.js"],"component---src-pages-index-tsx":["/component---src-pages-index-tsx-8bc8aae9081b91f67895.js"]};/*]]>*/</script><script src="/webpack-runtime-ee1f602fcca81f26856b.js" async=""></script><script src="/app-8ed2bcd8d918eca8e6e5.js" async=""></script><script src="/component---src-templates-blog-template-tsx-e07aa2a173d2d60ceec3.js" async=""></script></body></html>