<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 2.13.8"/><title data-react-helmet="true"></title><link rel="shortcut icon" href="/icons/icon-48x48.png?v=008654519ce705ac7bc44303a9014606"/><link rel="manifest" href="/manifest.webmanifest"/><meta name="theme-color" content="#663399"/><link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png?v=008654519ce705ac7bc44303a9014606"/><link as="script" rel="preload" href="/component---src-templates-blog-template-tsx-b66e07bd040af23b46a9.js"/><link as="script" rel="preload" href="/app-0d5d2409b38cfdcf00cf.js"/><link as="script" rel="preload" href="/webpack-runtime-b18de972a18959228b00.js"/><link as="fetch" rel="preload" href="/page-data/base/algorithms/binary-search/page-data.json" crossorigin="use-credentials"/></head><body><noscript id="gatsby-noscript">This app works best with JavaScript enabled.</noscript><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group" id="gatsby-focus-wrapper"><div class="blog-post-container"><div class="blog-post"><h1>이진 탐색</h1><h2>March 17, 2019</h2><div class="blog-post-content"><h2>이진탐색</h2>
<ul>
<li><strong>탐색</strong>: 배열 형태로 주어진 데이터에서 원하는 값을 가진 데이터를 찾는 문제.</li>
<li><strong>이진 탐색</strong>: 정렬된 상태의 데이텅에 대해 적용 가능한 효과적인 탐색 방법.</li>
</ul>
<h2>탐색 방법</h2>
<p>배열은 오름차순 정렬 되어 있다고 가정한다.</p>
<h3>분할</h3>
<p>배열의 가운데 원소를 기준으로 왼쪽 부분배열과 오른쪽 부분배열로 분할한다. 탐색키 x가 가운데 원소와 같으면 가운데 원소에 해당하는 배열의 인덱스를 반환하고 종료한다.</p>
<h3>정복</h3>
<p>x가 가운데 원소보다 작으면 왼쪽 부분배열을 대상으로 이진 탐색을 순환호출 하고, 크면 오른쪽 부분배열을 대상으로 이진 탐색을 순환호출한다. 탐색을 다시 수행할 때마다 탐색 범위가 절반으로 줄어든다.</p>
<h3>결합.</h3>
<p>부분배열에 대해서 이진 탐색의 결과가 직접 반환되므로 결과를 결합할 필요가 없다.</p>
<p><img src="/images/base/algorithms-binary-search-1.png" alt="이진 탐색 분할"></p>
<h2>알고리즘</h2>
<h3>재귀함수</h3>
<pre><code class="language-c">int binarySearch(int arr[], int leftIndex, int rightIndex, int x) {
  // 탐색 실패
  if (leftIndex > rightIndex) {
    return -1;
  }

  int mid = (leftIndex + rightIndex) / 2;

  if (x == arr[mid]) {
    return mid;
  }

  if (x &#x3C; arr[mid]) {
    // 왼족 배열 탐색
    return binarySearch(arr, leftIndex, mid - 1, x);
  } else {
    // 오른쪽 배열 탐색
    return binarySearch(arr, mid + 1, rightIndex, x);
  }
};
</code></pre>
<h3>반복함수</h3>
<pre><code class="language-c">int binarySearch_Iteration(int arr[], int index, int x) {
  int leftIndex = 0, rightIndex = index - 1;

  while(leftIndex &#x3C;= rightIndex) {
    int mid = (leftIndex + rightIndex) / 2;

    if (x == arr[mid]) {
      return mid;
    }

    if (x &#x3C; arr[mid]) {
      // 왼쪽 부분배열 탐색
      rightIndex = mid - 1;
    } else {
      // 오른쪽 부분배열 탐색
      leftIndex = mid + 1;
    }
  }

  // 탐색키가 존재하지 않을 경우
  return -1;
};
</code></pre>
<p>이진 탐색에서는 분할 될 때마다 입력 크기가 절반으로 감소 하며, 탐색 대상의 개수가 1이 되면 더는 분할이 수행되지 않고 탐색 성공 여부가 결정된다.</p>
<h2>성능 분석</h2>
<p>T(n) = 입력 크기 n에 대한 탐색 과정에서의 모든 비교 횟수의 합 = 맨 바깥 수준에서의 비교 횟수 + 순환 호출에서의 비교 횟수.</p>
<p>맨 바깥 수준에서의 비교 횟수는 상수이므로 1.
순환 호출에서의 비교 횟수는 비교 할 때마다 절반 씩 데이터를 나누므로 $\frac{n}{2}$.</p>
<p>T(n) = T($\frac{n}{2}$) + O(1)(n > 1), T(1) = 1;
T(n) = O($logn$)</p>
<h2>특징</h2>
<ul>
<li>입력이 정렬된 리스트에 대해서만 적용이 가능하다.</li>
<li>
<p>데이터의 삽입/삭제 연산을 수행하면 데이터의 이동이 발생한다.</p>
<ul>
<li>평균 $\frac{2}{n}$개의 데이터 이동이 발생하므로 삽입/삭제가 빈번한 응용에는 부적합하다.</li>
</ul>
</li>
</ul>
<h2>Reference</h2>
<p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920026935&#x26;condLscValue=001&#x26;condYr=&#x26;condSmst=">방송대 컴퓨터과학과 알고리즘 3강</a></p></div></div></div></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/base/algorithms/binary-search";window.webpackCompilationHash="36f39e3b50b61b19d339";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-0d5d2409b38cfdcf00cf.js"],"component---src-templates-blog-template-tsx":["/component---src-templates-blog-template-tsx-b66e07bd040af23b46a9.js"],"component---src-pages-index-tsx":["/component---src-pages-index-tsx-270c6b30b12b5491f622.js"]};/*]]>*/</script><script src="/webpack-runtime-b18de972a18959228b00.js" async=""></script><script src="/app-0d5d2409b38cfdcf00cf.js" async=""></script><script src="/component---src-templates-blog-template-tsx-b66e07bd040af23b46a9.js" async=""></script></body></html>