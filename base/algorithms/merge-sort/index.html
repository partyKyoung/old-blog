<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 2.13.8"/><title data-react-helmet="true"></title><link rel="shortcut icon" href="/icons/icon-48x48.png?v=008654519ce705ac7bc44303a9014606"/><link rel="manifest" href="/manifest.webmanifest"/><meta name="theme-color" content="#663399"/><link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png?v=008654519ce705ac7bc44303a9014606"/><link as="script" rel="preload" href="/component---src-templates-blog-template-tsx-b66e07bd040af23b46a9.js"/><link as="script" rel="preload" href="/app-0d5d2409b38cfdcf00cf.js"/><link as="script" rel="preload" href="/webpack-runtime-b18de972a18959228b00.js"/><link as="fetch" rel="preload" href="/page-data/base/algorithms/merge-sort/page-data.json" crossorigin="use-credentials"/></head><body><noscript id="gatsby-noscript">This app works best with JavaScript enabled.</noscript><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group" id="gatsby-focus-wrapper"><div class="blog-post-container"><div class="blog-post"><h1>합병정렬</h1><h2>March 18, 2019</h2><div class="blog-post-content"><h2>합병정렬</h2>
<p>배열을 동일한 크기의 두 개의 부분배열로 분할하고 각각의 부분 배열을 순환적으로 정렬한 후, 정렬된 두 부분배열을 합병하여 하나의 정렬된 배열을 만든다.</p>
<h3>분할</h3>
<p>입력의 크기가 n인 배열을 n/2개의 원소를 가진 두 부분배열로 분할한다.</p>
<h3>정복</h3>
<p>각각의 부분배열에 대해서 합병 정렬을 순환적으로 적용하여 각 부분배열을 정렬한다.</p>
<h3>결합</h3>
<p>정렬된 두 부분배열을 합병하여 하나의 정렬된 배열을 만든다.</p>
<p><img src="/images/base/algorithms-merge-sort-1.png" alt="합병정렬"></p>
<h2>알고리즘</h2>
<pre><code class="language-c">void merge(int arr[], int sorted[], int leftIndex, int mid, int rightIndex) {
  int l_hold = leftIndex, r_hold = mid + 1;
  int resultIndex = leftIndex; // 결과 배열의 index

  while(l_hold &#x3C;= mid &#x26;&#x26; r_hold &#x3C;= rightIndex) {
    // 부분배열 두개를 비교하여 작은 값을 선택한다.
    if (arr[l_hold] &#x3C; arr[r_hold]) {
      sorted[resultIndex] = arr[l_hold];

      l_hold++;
    } else {
      sorted[resultIndex] = arr[r_hold];

      r_hold++;
    }

    resultIndex++;
  }

  // 왼쪽 부분배열에 남아있는 모든 원소를 새로은 배열로 이동시킨다.
  while (l_hold &#x3C;= mid) {
    sorted[resultIndex] = arr[l_hold];

    resultIndex ++;
    l_hold ++;
  }

  // 오른쪽 부분배열에 남아있는 모든 원소를 새로은 배열로 이동시킨다.
  while (r_hold &#x3C;= rightIndex) {
    sorted[resultIndex] = arr[r_hold];

    resultIndex ++;
    r_hold ++;
  }


  // 원본 배열에 정렬된 배열을 이동 시킨다.
  for (int i = leftIndex; i &#x3C;= rightIndex; i++) {
    arr[i] = sorted[i];
  }
}

void mergeSort (int arr[], int sorted[], int leftIndex, int rightIndex) {
  if (leftIndex &#x3C; rightIndex) {
    // 각각 n/2크기를 가진 두 부분배열로 나누기 위해 가운데 값 정함.
    int mid = (leftIndex + rightIndex) / 2;

    // 왼쪽 부분배열의 순환호출
    mergeSort(arr, sorted, leftIndex, mid);

    // 오른쪽 부분배열의 순환호출
    mergeSort(arr, sorted, mid + 1, rightIndex);

    // 정렬된 두 부분배열의 합병
    merge(arr, sorted, leftIndex, mid, rightIndex);
  }
}
</code></pre>
<h2>성능 분석</h2>
<h3>합병 함수 수행 시간</h3>
<p>합병 함수 수행 시간 = 부분배열[n/2] + 부분배열[n/2] = 배열[n]</p>
<p>두 부분 배열을 합병하면 최악의 경우 결과 배열엔 n + m개의 원소가 저장되는에 이때 최악의 경우 n + m - 1회의 비교가 필요하다.</p>
<ul>
<li>최소 비교횟수: $\frac{n}{2}$</li>
<li>최대 비교횟수: ($\frac{n}{2}$ + $\frac{n}{2}$ - 1) = n - 1;
=> 입력 데이터 개수만큼의 저장 장소가 추가로 필요하다.</li>
</ul>
<p>결국 합병을 하는데 걸리는 시간은 입력 크기 n에 비례하므로 Θ(n)이 된다.</p>
<h3>합병 정렬 수행 시간</h3>
<p>합병 정렬 수행시간 = 크기 n/2인 두번의 합병 정렬 순환 호출 + 한번의 합병</p>
<p>T(1) = 1;
T(n) = T($\frac{n}{2}$) + T($\frac{n}{2}$) + Θ(n);</p>
<p>=> T(n) = 2T($\frac{n}{2}$) + Θ(n)
=> T(n) = O($n log n$)</p>
<h2>Reference</h2>
<p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920026935&#x26;condLscValue=001&#x26;condYr=&#x26;condSmst=">방송대 컴퓨터과학과 알고리즘 4강</a></p></div></div></div></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/base/algorithms/merge-sort";window.webpackCompilationHash="36f39e3b50b61b19d339";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-0d5d2409b38cfdcf00cf.js"],"component---src-templates-blog-template-tsx":["/component---src-templates-blog-template-tsx-b66e07bd040af23b46a9.js"],"component---src-pages-index-tsx":["/component---src-pages-index-tsx-270c6b30b12b5491f622.js"]};/*]]>*/</script><script src="/webpack-runtime-b18de972a18959228b00.js" async=""></script><script src="/app-0d5d2409b38cfdcf00cf.js" async=""></script><script src="/component---src-templates-blog-template-tsx-b66e07bd040af23b46a9.js" async=""></script></body></html>