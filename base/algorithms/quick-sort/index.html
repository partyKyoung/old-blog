<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style id="GlobalStyle-955300486">
  html, body, 
  h1, h2, h3, h4, h5, h6,
  div, p, span,
  blockquote, applet, object, iframe,
  pre, a, 
  abbr, acronym, address,
  big, cite, code,
  del, dfn, em,
  font, img, 
  ins, kbd, q, s,
  samp, small,
  strike, strong,
  sub, sup, tt, var,
  dl, dt, dd,
  ol, ul, li,
  fieldset, form, label, legend,
  table, caption, tbody, tfoot, thead, tr, th, td {
    margin: 0;
    padding: 0;
  }
  body,
  input,
  textarea,
  select,
  button,
  table {
    font-size: 0.875rem;
    line-height: 1.25em;
  }

  html,
  body {
    height: 100%;
    padding: 0;
    margin: 0;
    color: #212121;
    box-sizing: border-box;
  }

  header {
    height: 50px
  }

  footer {
    height: 50px
  }

  img,
  fieldset {
    border: 0;
  }
  ul,
  ol {
    list-style: none;
  }
  em,
  address {
    font-style: normal;
  }
  a,
  a:hover,
  a:active,
  a:focus {
    text-decoration: none;
    box-sizing: border-box;
  }
</style><meta name="generator" content="Gatsby 2.13.8"/><title data-react-helmet="true"></title><link rel="shortcut icon" href="/icons/icon-48x48.png?v=008654519ce705ac7bc44303a9014606"/><link rel="manifest" href="/manifest.webmanifest"/><meta name="theme-color" content="#663399"/><link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png?v=008654519ce705ac7bc44303a9014606"/><style data-styled="" data-styled-version="4.3.2"></style><link as="script" rel="preload" href="/component---src-templates-blog-template-tsx-062bd6b3a19c060efb50.js"/><link as="script" rel="preload" href="/app-1ab349c5de0fd1142102.js"/><link as="script" rel="preload" href="/webpack-runtime-481ffd67231f524cb647.js"/><link as="fetch" rel="preload" href="/page-data/base/algorithms/quick-sort/page-data.json" crossorigin="use-credentials"/></head><body><noscript id="gatsby-noscript">This app works best with JavaScript enabled.</noscript><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group" id="gatsby-focus-wrapper"><div class="blog-post-container"><div class="blog-post"><h1>퀵 정렬</h1><h2>March 17, 2019</h2><div class="blog-post-content"><h2>퀵 정렬</h2>
<p>특정 원소를 기준으로 주어진 배열을 두 부분배열로 분할하고, 각 부분배열에 대해서 퀵 정렬을 순환적으로 적용하는 방식.
특정 원소를 <strong>피벗</strong> 이라고 부름. 즉, 피벗이 제자리를 잡조록 하여 정렬하는 방식. 피벗의 왼쪽 부분배열엔 피벗보다 작은 값이, 오른쪽 부분배열엔 피벗보다 큰 값이 온다.</p>
<ul>
<li>피벗: 두 부분배열로 분할할 때 기준에 되는 특정 원소. 보통 주어진 배열의 첫 번째 원소로 지정한다.</li>
</ul>
<h3>분할</h3>
<p>피벗을 기준으로 주어진 배열을 두 부분배열로 분할한다.</p>
<h3>정복</h3>
<p>두 부분배열에 대해서 퀵 정렬을 순환적으로 적용하여 각 부분배열을 정렬한다.</p>
<h3>결합</h3>
<p>필요 없음</p>
<p><img src="/images/base/algorithms-quick-sort-1.png" alt="퀵정렬"></p>
<h2>알고리즘</h2>
<pre><code class="language-c">void swap(int arr[], int a, int b)
{
    int temp = arr[a];
    arr[a] = arr[b];
    arr[b] = temp;
}

// 배열의 맨 오른쪽 index엔 무한대 값이 있다고 가정한다.
int partition(int arr[], int leftIndex, int rightIndex) {
// 맨 왼쪽을 피벗으로 잡기 때문에 l_hold는 피벗의 위치 + 1, r_hold는 배열의 마지막 index
  int pivot = arr[leftIndex], l_hold = leftIndex + 1, r_hold = rightIndex;

  while (l_hold &#x3C;= r_hold) {
    // l_hold는 피벗보다 큰 값을 찾는다.
    while (l_hold &#x3C;= rightIndex &#x26;&#x26; arr[l_hold] &#x3C; pivot) {
      l_hold++;
    }

    // r_hold는 피벗보다 작은 값을 찾는다.
    while (r_hold > leftIndex &#x26;&#x26; arr[r_hold] >= pivot) {
      r_hold--;
    }

    if (l_hold &#x3C; r_hold) {
      // arr[l_hold]와 arr[r_hold]의 값을 교환한다.
      swap(arr, l_hold, r_hold);
    }
  }

  // 피벗과 arr[r_hold]값을 교환한다.
  swap(arr, leftIndex, r_hold);

  return r_hold;
}

void quickSort(int arr[], int leftIndex, int rightIndex) {
  if (leftIndex &#x3C;= rightIndex) {
    int pivot = partition(arr, leftIndex, rightIndex); // 두 부분배열로 분할

    quickSort(arr, leftIndex, pivot - 1);  // 왼쪽 부분배열에 대해 순환호출
    quickSort(arr, pivot + 1, rightIndex); // 오른쪽 부분배열에 대해서 순환호출
  }

}
</code></pre>
<h2>성능 분석</h2>
<p>퀵 정렬 알고리즘은 한 번의 분할과 두 번의 순환 호출로 구성된다.</p>
<h3>분할 함수 수행 시간</h3>
<p>피벗을 제외한 배열의 원소들은 피벗과 최대 2번 비교 하게 된다. 전체적으로는 입력 크기 n에 비례하는 Θ(n) 시간이 걸린다.</p>
<h3>퀵 정렬 수행 시간</h3>
<p>퀵 정렬 수행 시간 = 한 번의 분할 + 두번의 킉정렬 순환 호출.
배열 부분 시 두 부분배열의 크기가 다르기 때문에 배열이 어떤 크기의 두 부분배열로 분할되느냐에 따라 수행 시간이 다르다.</p>
<h4>최악의 경우</h4>
<p>극심한 불균형적 분할.</p>
<ul>
<li>피벗만 제자리를 잡고, 나머지 모든 원소가 하나의 부분배열로 분할되는 경우</li>
<li>피벗이 항상 부분배열의 최솟값, 또는 최댓값이 되는 경우</li>
<li>입력 데이터가 정렬되어 있고 피벗을 배열의 처음 원소로 지정한 경우</li>
</ul>
<p>T(n) = T(n-1) + T(0) + Θ(n) (n > 0) // 한쪽은 데이터가 없으므로 T(0)
T(0) = 0</p>
<p>=> T(n) = T(n - 1) + Θ(n)
=> T(n) = O($n^2$)</p>
<h3>최선의 경우</h3>
<p>가장 균형적인 분할.</p>
<ul>
<li>피벗을 중심으로 항상 동일한 크기의 두 부분배열로 분할되는 경우</li>
<li>피벗이 항상 부분배열의 중간값이 되는 경우</li>
</ul>
<p>T(n) = T($\frac{n}{2}$) + T($\frac{n}{2}$) + Θ(n) (n > 1)
T(1) = 1</p>
<p>=> T(n) = 2T($\frac{n}{2}$) + Θ(n)
=> T(n) = O($n log n$)</p>
<h3>평균적인 경우</h3>
<p>부분배열의 모든 분할 비율에 따른 수행 시간의 평균.</p>
<ul>
<li>피벗은 동일한 확률로서 분할 후 배열의 어느 곳에나 위치 가능</li>
</ul>
<p>T(1) = T(0) = 0
T(n) = $\frac{1}{n}\sum_{i = 1}^{n}(T(i - 1) + T(n - i)) + O(n) (n >= 2)$</p>
<p>=> T(n) = O($n log n$)</p>
<h2>특징</h2>
<ul>
<li>최선/ 평균의 경우 O($n log n$)</li>
<li>최악의 경우 O($n^2$)</li>
</ul>
<p>즉 피벗 선택의 임의성만 보장되면 평균적인 성능을 보일 가능성이 매우 높다. 그래서 배열에서 임의로 값을 선택해서 배열의 처음 원소와 서로 교환 후 정렬 수행하면 최악의 경우를 피할 가능성이 커진다.</p>
<h2>Reference</h2>
<p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920026935&#x26;condLscValue=001&#x26;condYr=&#x26;condSmst=">방송대 컴퓨터과학과 알고리즘 3강</a></p></div></div></div></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/base/algorithms/quick-sort";window.webpackCompilationHash="04b35bb1e7e18e473c98";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-1ab349c5de0fd1142102.js"],"component---src-templates-blog-template-tsx":["/component---src-templates-blog-template-tsx-062bd6b3a19c060efb50.js"],"component---src-pages-about-tsx":["/component---src-pages-about-tsx-c51ac192ef3e8136e036.js"],"component---src-pages-index-tsx":["/component---src-pages-index-tsx-3d1d0b2c52beb17cb7e9.js"]};/*]]>*/</script><script src="/webpack-runtime-481ffd67231f524cb647.js" async=""></script><script src="/app-1ab349c5de0fd1142102.js" async=""></script><script src="/component---src-templates-blog-template-tsx-062bd6b3a19c060efb50.js" async=""></script></body></html>