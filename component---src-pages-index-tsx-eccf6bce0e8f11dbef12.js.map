{"version":3,"file":"component---src-pages-index-tsx-eccf6bce0e8f11dbef12.js","mappings":"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","sources":["webpack://kyoungah-dev-blog/./node_modules/@tanstack/query-core/build/modern/queryObserver.js","webpack://kyoungah-dev-blog/./node_modules/@tanstack/query-core/build/modern/infiniteQueryObserver.js","webpack://kyoungah-dev-blog/./node_modules/@tanstack/react-query/build/modern/QueryErrorResetBoundary.js","webpack://kyoungah-dev-blog/./node_modules/@tanstack/react-query/build/modern/isRestoring.js","webpack://kyoungah-dev-blog/./node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js","webpack://kyoungah-dev-blog/./node_modules/@tanstack/react-query/build/modern/utils.js","webpack://kyoungah-dev-blog/./node_modules/@tanstack/react-query/build/modern/suspense.js","webpack://kyoungah-dev-blog/./node_modules/@tanstack/react-query/build/modern/useInfiniteQuery.js","webpack://kyoungah-dev-blog/./node_modules/@tanstack/react-query/build/modern/useBaseQuery.js","webpack://kyoungah-dev-blog/./src/pages/index.tsx"],"sourcesContent":["// src/queryObserver.ts\nimport {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  shallowEqualObjects,\n  timeUntilStale\n} from \"./utils.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { focusManager } from \"./focusManager.js\";\nimport { Subscribable } from \"./subscribable.js\";\nimport { canFetch } from \"./retryer.js\";\nvar QueryObserver = class extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.#currentQuery = void 0;\n    this.#currentQueryInitialState = void 0;\n    this.#currentResult = void 0;\n    this.#trackedProps = /* @__PURE__ */ new Set();\n    this.#client = client;\n    this.options = options;\n    this.#selectError = null;\n    this.bindMethods();\n    this.setOptions(options);\n  }\n  #client;\n  #currentQuery;\n  #currentQueryInitialState;\n  #currentResult;\n  #currentResultState;\n  #currentResultOptions;\n  #selectError;\n  #selectFn;\n  #selectResult;\n  // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n  #lastQueryWithDefinedData;\n  #staleTimeoutId;\n  #refetchIntervalId;\n  #currentRefetchInterval;\n  #trackedProps;\n  bindMethods() {\n    this.refetch = this.refetch.bind(this);\n  }\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this);\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch();\n      } else {\n        this.updateResult();\n      }\n      this.#updateTimers();\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.destroy();\n    }\n  }\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnReconnect\n    );\n  }\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus\n    );\n  }\n  destroy() {\n    this.listeners = /* @__PURE__ */ new Set();\n    this.#clearStaleTimeout();\n    this.#clearRefetchInterval();\n    this.#currentQuery.removeObserver(this);\n  }\n  setOptions(options, notifyOptions) {\n    const prevOptions = this.options;\n    const prevQuery = this.#currentQuery;\n    this.options = this.#client.defaultQueryOptions(options);\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.#client.getQueryCache().notify({\n        type: \"observerOptionsUpdated\",\n        query: this.#currentQuery,\n        observer: this\n      });\n    }\n    if (typeof this.options.enabled !== \"undefined\" && typeof this.options.enabled !== \"boolean\") {\n      throw new Error(\"Expected enabled to be a boolean\");\n    }\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey;\n    }\n    this.#updateQuery();\n    const mounted = this.hasListeners();\n    if (mounted && shouldFetchOptionally(\n      this.#currentQuery,\n      prevQuery,\n      this.options,\n      prevOptions\n    )) {\n      this.#executeFetch();\n    }\n    this.updateResult(notifyOptions);\n    if (mounted && (this.#currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {\n      this.#updateStaleTimeout();\n    }\n    const nextRefetchInterval = this.#computeRefetchInterval();\n    if (mounted && (this.#currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.#currentRefetchInterval)) {\n      this.#updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n  getOptimisticResult(options) {\n    const query = this.#client.getQueryCache().build(this.#client, options);\n    const result = this.createResult(query, options);\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      this.#currentResult = result;\n      this.#currentResultOptions = this.options;\n      this.#currentResultState = this.#currentQuery.state;\n    }\n    return result;\n  }\n  getCurrentResult() {\n    return this.#currentResult;\n  }\n  trackResult(result) {\n    const trackedResult = {};\n    Object.keys(result).forEach((key) => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.#trackedProps.add(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n  getCurrentQuery() {\n    return this.#currentQuery;\n  }\n  refetch({ ...options } = {}) {\n    return this.fetch({\n      ...options\n    });\n  }\n  fetchOptimistic(options) {\n    const defaultedOptions = this.#client.defaultQueryOptions(options);\n    const query = this.#client.getQueryCache().build(this.#client, defaultedOptions);\n    query.isFetchingOptimistic = true;\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n  fetch(fetchOptions) {\n    return this.#executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true\n    }).then(() => {\n      this.updateResult();\n      return this.#currentResult;\n    });\n  }\n  #executeFetch(fetchOptions) {\n    this.#updateQuery();\n    let promise = this.#currentQuery.fetch(\n      this.options,\n      fetchOptions\n    );\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop);\n    }\n    return promise;\n  }\n  #updateStaleTimeout() {\n    this.#clearStaleTimeout();\n    if (isServer || this.#currentResult.isStale || !isValidTimeout(this.options.staleTime)) {\n      return;\n    }\n    const time = timeUntilStale(\n      this.#currentResult.dataUpdatedAt,\n      this.options.staleTime\n    );\n    const timeout = time + 1;\n    this.#staleTimeoutId = setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n  #computeRefetchInterval() {\n    return (typeof this.options.refetchInterval === \"function\" ? this.options.refetchInterval(this.#currentQuery) : this.options.refetchInterval) ?? false;\n  }\n  #updateRefetchInterval(nextInterval) {\n    this.#clearRefetchInterval();\n    this.#currentRefetchInterval = nextInterval;\n    if (isServer || this.options.enabled === false || !isValidTimeout(this.#currentRefetchInterval) || this.#currentRefetchInterval === 0) {\n      return;\n    }\n    this.#refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        this.#executeFetch();\n      }\n    }, this.#currentRefetchInterval);\n  }\n  #updateTimers() {\n    this.#updateStaleTimeout();\n    this.#updateRefetchInterval(this.#computeRefetchInterval());\n  }\n  #clearStaleTimeout() {\n    if (this.#staleTimeoutId) {\n      clearTimeout(this.#staleTimeoutId);\n      this.#staleTimeoutId = void 0;\n    }\n  }\n  #clearRefetchInterval() {\n    if (this.#refetchIntervalId) {\n      clearInterval(this.#refetchIntervalId);\n      this.#refetchIntervalId = void 0;\n    }\n  }\n  createResult(query, options) {\n    const prevQuery = this.#currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.#currentResult;\n    const prevResultState = this.#currentResultState;\n    const prevResultOptions = this.#currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.#currentQueryInitialState;\n    const { state } = query;\n    let { error, errorUpdatedAt, fetchStatus, status } = state;\n    let isPlaceholderData = false;\n    let data;\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode) ? \"fetching\" : \"paused\";\n        if (!state.dataUpdatedAt) {\n          status = \"pending\";\n        }\n      }\n      if (options._optimisticResults === \"isRestoring\") {\n        fetchStatus = \"idle\";\n      }\n    }\n    if (options.select && typeof state.data !== \"undefined\") {\n      if (prevResult && state.data === prevResultState?.data && options.select === this.#selectFn) {\n        data = this.#selectResult;\n      } else {\n        try {\n          this.#selectFn = options.select;\n          data = options.select(state.data);\n          data = replaceData(prevResult?.data, data, options);\n          this.#selectResult = data;\n          this.#selectError = null;\n        } catch (selectError) {\n          this.#selectError = selectError;\n        }\n      }\n    } else {\n      data = state.data;\n    }\n    if (typeof options.placeholderData !== \"undefined\" && typeof data === \"undefined\" && status === \"pending\") {\n      let placeholderData;\n      if (prevResult?.isPlaceholderData && options.placeholderData === prevResultOptions?.placeholderData) {\n        placeholderData = prevResult.data;\n      } else {\n        placeholderData = typeof options.placeholderData === \"function\" ? options.placeholderData(\n          this.#lastQueryWithDefinedData?.state.data,\n          this.#lastQueryWithDefinedData\n        ) : options.placeholderData;\n        if (options.select && typeof placeholderData !== \"undefined\") {\n          try {\n            placeholderData = options.select(placeholderData);\n            this.#selectError = null;\n          } catch (selectError) {\n            this.#selectError = selectError;\n          }\n        }\n      }\n      if (typeof placeholderData !== \"undefined\") {\n        status = \"success\";\n        data = replaceData(\n          prevResult?.data,\n          placeholderData,\n          options\n        );\n        isPlaceholderData = true;\n      }\n    }\n    if (this.#selectError) {\n      error = this.#selectError;\n      data = this.#selectResult;\n      errorUpdatedAt = Date.now();\n      status = \"error\";\n    }\n    const isFetching = fetchStatus === \"fetching\";\n    const isPending = status === \"pending\";\n    const isError = status === \"error\";\n    const isLoading = isPending && isFetching;\n    const result = {\n      status,\n      fetchStatus,\n      isPending,\n      isSuccess: status === \"success\",\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: state.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      failureReason: state.fetchFailureReason,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === \"paused\",\n      isPlaceholderData,\n      isRefetchError: isError && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch\n    };\n    return result;\n  }\n  updateResult(notifyOptions) {\n    const prevResult = this.#currentResult;\n    const nextResult = this.createResult(this.#currentQuery, this.options);\n    this.#currentResultState = this.#currentQuery.state;\n    this.#currentResultOptions = this.options;\n    if (this.#currentResultState.data !== void 0) {\n      this.#lastQueryWithDefinedData = this.#currentQuery;\n    }\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n    this.#currentResult = nextResult;\n    const defaultNotifyOptions = {};\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n      const { notifyOnChangeProps } = this.options;\n      const notifyOnChangePropsValue = typeof notifyOnChangeProps === \"function\" ? notifyOnChangeProps() : notifyOnChangeProps;\n      if (notifyOnChangePropsValue === \"all\" || !notifyOnChangePropsValue && !this.#trackedProps.size) {\n        return true;\n      }\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.#trackedProps\n      );\n      if (this.options.throwOnError) {\n        includedProps.add(\"error\");\n      }\n      return Object.keys(this.#currentResult).some((key) => {\n        const typedKey = key;\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n    if (notifyOptions?.listeners !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true;\n    }\n    this.#notify({ ...defaultNotifyOptions, ...notifyOptions });\n  }\n  #updateQuery() {\n    const query = this.#client.getQueryCache().build(this.#client, this.options);\n    if (query === this.#currentQuery) {\n      return;\n    }\n    const prevQuery = this.#currentQuery;\n    this.#currentQuery = query;\n    this.#currentQueryInitialState = query.state;\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n  onQueryUpdate() {\n    this.updateResult();\n    if (this.hasListeners()) {\n      this.#updateTimers();\n    }\n  }\n  #notify(notifyOptions) {\n    notifyManager.batch(() => {\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.#currentResult);\n        });\n      }\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: \"observerResultsUpdated\"\n      });\n    });\n  }\n};\nfunction shouldLoadOnMount(query, options) {\n  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === \"error\" && options.retryOnMount === false);\n}\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\nfunction shouldFetchOn(query, options, field) {\n  if (options.enabled !== false) {\n    const value = typeof field === \"function\" ? field(query) : field;\n    return value === \"always\" || value !== false && isStale(query, options);\n  }\n  return false;\n}\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== \"error\") && isStale(query, options);\n}\nfunction isStale(query, options) {\n  return query.isStaleByTime(options.staleTime);\n}\nfunction shouldAssignObserverCurrentProperties(observer, optimisticResult) {\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true;\n  }\n  return false;\n}\nexport {\n  QueryObserver\n};\n//# sourceMappingURL=queryObserver.js.map","// src/infiniteQueryObserver.ts\nimport { QueryObserver } from \"./queryObserver.js\";\nimport {\n  hasNextPage,\n  hasPreviousPage,\n  infiniteQueryBehavior\n} from \"./infiniteQueryBehavior.js\";\nvar InfiniteQueryObserver = class extends QueryObserver {\n  // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n  constructor(client, options) {\n    super(client, options);\n  }\n  bindMethods() {\n    super.bindMethods();\n    this.fetchNextPage = this.fetchNextPage.bind(this);\n    this.fetchPreviousPage = this.fetchPreviousPage.bind(this);\n  }\n  setOptions(options, notifyOptions) {\n    super.setOptions(\n      {\n        ...options,\n        behavior: infiniteQueryBehavior()\n      },\n      notifyOptions\n    );\n  }\n  getOptimisticResult(options) {\n    options.behavior = infiniteQueryBehavior();\n    return super.getOptimisticResult(options);\n  }\n  fetchNextPage(options) {\n    return this.fetch({\n      ...options,\n      meta: {\n        fetchMore: { direction: \"forward\" }\n      }\n    });\n  }\n  fetchPreviousPage(options) {\n    return this.fetch({\n      ...options,\n      meta: {\n        fetchMore: { direction: \"backward\" }\n      }\n    });\n  }\n  createResult(query, options) {\n    const { state } = query;\n    const result = super.createResult(query, options);\n    const { isFetching, isRefetching } = result;\n    const isFetchingNextPage = isFetching && state.fetchMeta?.fetchMore?.direction === \"forward\";\n    const isFetchingPreviousPage = isFetching && state.fetchMeta?.fetchMore?.direction === \"backward\";\n    return {\n      ...result,\n      fetchNextPage: this.fetchNextPage,\n      fetchPreviousPage: this.fetchPreviousPage,\n      hasNextPage: hasNextPage(options, state.data),\n      hasPreviousPage: hasPreviousPage(options, state.data),\n      isFetchingNextPage,\n      isFetchingPreviousPage,\n      isRefetching: isRefetching && !isFetchingNextPage && !isFetchingPreviousPage\n    };\n  }\n};\nexport {\n  InfiniteQueryObserver\n};\n//# sourceMappingURL=infiniteQueryObserver.js.map","\"use client\";\n\n// src/QueryErrorResetBoundary.tsx\nimport * as React from \"react\";\nfunction createValue() {\n  let isReset = false;\n  return {\n    clearReset: () => {\n      isReset = false;\n    },\n    reset: () => {\n      isReset = true;\n    },\n    isReset: () => {\n      return isReset;\n    }\n  };\n}\nvar QueryErrorResetBoundaryContext = React.createContext(createValue());\nvar useQueryErrorResetBoundary = () => React.useContext(QueryErrorResetBoundaryContext);\nvar QueryErrorResetBoundary = ({\n  children\n}) => {\n  const [value] = React.useState(() => createValue());\n  return /* @__PURE__ */ React.createElement(QueryErrorResetBoundaryContext.Provider, { value }, typeof children === \"function\" ? children(value) : children);\n};\nexport {\n  QueryErrorResetBoundary,\n  useQueryErrorResetBoundary\n};\n//# sourceMappingURL=QueryErrorResetBoundary.js.map","\"use client\";\n\n// src/isRestoring.ts\nimport * as React from \"react\";\nvar IsRestoringContext = React.createContext(false);\nvar useIsRestoring = () => React.useContext(IsRestoringContext);\nvar IsRestoringProvider = IsRestoringContext.Provider;\nexport {\n  IsRestoringProvider,\n  useIsRestoring\n};\n//# sourceMappingURL=isRestoring.js.map","\"use client\";\n\n// src/errorBoundaryUtils.ts\nimport * as React from \"react\";\nimport { shouldThrowError } from \"./utils.js\";\nvar ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {\n  if (options.suspense || options.throwOnError) {\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false;\n    }\n  }\n};\nvar useClearResetErrorBoundary = (errorResetBoundary) => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset();\n  }, [errorResetBoundary]);\n};\nvar getHasError = ({\n  result,\n  errorResetBoundary,\n  throwOnError,\n  query\n}) => {\n  return result.isError && !errorResetBoundary.isReset() && !result.isFetching && shouldThrowError(throwOnError, [result.error, query]);\n};\nexport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary\n};\n//# sourceMappingURL=errorBoundaryUtils.js.map","// src/utils.ts\nfunction shouldThrowError(throwError, params) {\n  if (typeof throwError === \"function\") {\n    return throwError(...params);\n  }\n  return !!throwError;\n}\nexport {\n  shouldThrowError\n};\n//# sourceMappingURL=utils.js.map","// src/suspense.ts\nvar defaultThrowOnError = (_error, query) => typeof query.state.data === \"undefined\";\nvar ensureStaleTime = (defaultedOptions) => {\n  if (defaultedOptions.suspense) {\n    if (typeof defaultedOptions.staleTime !== \"number\") {\n      defaultedOptions.staleTime = 1e3;\n    }\n  }\n};\nvar willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;\nvar shouldSuspend = (defaultedOptions, result) => defaultedOptions?.suspense && result.isPending;\nvar fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).catch(() => {\n  errorResetBoundary.clearReset();\n});\nexport {\n  defaultThrowOnError,\n  ensureStaleTime,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch\n};\n//# sourceMappingURL=suspense.js.map","\"use client\";\n\n// src/useInfiniteQuery.ts\nimport { InfiniteQueryObserver } from \"@tanstack/query-core\";\nimport { useBaseQuery } from \"./useBaseQuery.js\";\nfunction useInfiniteQuery(options, queryClient) {\n  return useBaseQuery(\n    options,\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    InfiniteQueryObserver,\n    queryClient\n  );\n}\nexport {\n  useInfiniteQuery\n};\n//# sourceMappingURL=useInfiniteQuery.js.map","\"use client\";\n\n// src/useBaseQuery.ts\nimport * as React from \"react\";\nimport { notifyManager } from \"@tanstack/query-core\";\nimport { useQueryErrorResetBoundary } from \"./QueryErrorResetBoundary.js\";\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nimport { useIsRestoring } from \"./isRestoring.js\";\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary\n} from \"./errorBoundaryUtils.js\";\nimport { ensureStaleTime, fetchOptimistic, shouldSuspend } from \"./suspense.js\";\nfunction useBaseQuery(options, Observer, queryClient) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (typeof options !== \"object\" || Array.isArray(options)) {\n      throw new Error(\n        'Bad argument type. Starting with v5, only the \"Object\" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'\n      );\n    }\n  }\n  const client = useQueryClient(queryClient);\n  const isRestoring = useIsRestoring();\n  const errorResetBoundary = useQueryErrorResetBoundary();\n  const defaultedOptions = client.defaultQueryOptions(options);\n  defaultedOptions._optimisticResults = isRestoring ? \"isRestoring\" : \"optimistic\";\n  ensureStaleTime(defaultedOptions);\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);\n  useClearResetErrorBoundary(errorResetBoundary);\n  const [observer] = React.useState(\n    () => new Observer(\n      client,\n      defaultedOptions\n    )\n  );\n  const result = observer.getOptimisticResult(defaultedOptions);\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => {\n        const unsubscribe = isRestoring ? () => void 0 : observer.subscribe(notifyManager.batchCalls(onStoreChange));\n        observer.updateResult();\n        return unsubscribe;\n      },\n      [observer, isRestoring]\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult()\n  );\n  React.useEffect(() => {\n    observer.setOptions(defaultedOptions, { listeners: false });\n  }, [defaultedOptions, observer]);\n  if (shouldSuspend(defaultedOptions, result)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);\n  }\n  if (getHasError({\n    result,\n    errorResetBoundary,\n    throwOnError: defaultedOptions.throwOnError,\n    query: observer.getCurrentQuery()\n  })) {\n    throw result.error;\n  }\n  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;\n}\nexport {\n  useBaseQuery\n};\n//# sourceMappingURL=useBaseQuery.js.map","import React from 'react';\nimport { useInfiniteQuery } from '@tanstack/react-query';\nimport { css } from '@emotion/react';\n\nimport type { HeadFC } from 'gatsby';\n\nimport Container from '../commons/components/Container';\nimport Posts from '../commons/components/Posts';\nimport LayoutTemplate from '../commons/templates/LayoutTemplate';\n\nasync function fetchPosts({ pageParam }: { pageParam: number }) {\n  const response = await fetch(`./jsons/page${pageParam}.json`);\n  const page = await response.json();\n\n  return page;\n}\n\nfunction Index() {\n  const { data, isFetched } = useInfiniteQuery({\n    queryKey: ['posts'],\n    queryFn: fetchPosts,\n    initialPageParam: 1,\n    getNextPageParam: (lastPage) => lastPage.nextCursor,\n  });\n\n  return (\n    <LayoutTemplate>\n      <Container css={cssProps.root}>\n        {!isFetched && <Posts.FetchPostLoader css={cssProps.center} />}\n        {data && (\n          <>\n            {data.pages && (\n              <Posts>\n                {data.pages.map((page, pageIndex) => {\n                  if (page.currentPage === 1 && page.posts <= 0) {\n                    return <Posts.EmptyPost css={cssProps.center} />;\n                  }\n\n                  return (\n                    <Posts.PostList>\n                      {page.posts.map((post) => (\n                        <Posts.Post\n                          key={`${pageIndex}-${post.id}`}\n                          excerpt={post.excerpt}\n                          link={`/posts${post.slug}`}\n                          title={post.title}\n                        />\n                      ))}\n                    </Posts.PostList>\n                  );\n                })}\n              </Posts>\n            )}\n          </>\n        )}\n      </Container>\n    </LayoutTemplate>\n  );\n}\n\nconst cssProps = {\n  root: css({\n    position: 'relative',\n  }),\n  center: css({\n    position: 'absolute',\n    top: '50%',\n    left: '50%',\n    transform: 'translate(-50%, -50%)',\n  })\n};\n\nexport const Head: HeadFC = () => <title>Home Page</title>;\n\nexport default Index;\n"],"names":["QueryObserver","constructor","client","options","super","this","Set","bindMethods","setOptions","refetch","bind","onSubscribe","listeners","size","addObserver","shouldFetchOnMount","updateResult","onUnsubscribe","hasListeners","destroy","shouldFetchOnReconnect","shouldFetchOn","refetchOnReconnect","shouldFetchOnWindowFocus","refetchOnWindowFocus","removeObserver","notifyOptions","prevOptions","prevQuery","defaultQueryOptions","getQueryCache","notify","type","query","observer","enabled","Error","queryKey","mounted","shouldFetchOptionally","staleTime","nextRefetchInterval","getOptimisticResult","build","result","createResult","optimisticResult","getCurrentResult","shouldAssignObserverCurrentProperties","state","trackResult","trackedResult","Object","keys","forEach","key","defineProperty","configurable","enumerable","get","add","getCurrentQuery","fetch","fetchOptimistic","defaultedOptions","isFetchingOptimistic","then","fetchOptions","cancelRefetch","promise","throwOnError","catch","isStale","timeout","dataUpdatedAt","setTimeout","refetchInterval","nextInterval","setInterval","refetchIntervalInBackground","focusManager","isFocused","clearTimeout","clearInterval","prevResult","prevResultState","prevResultOptions","queryInitialState","data","error","errorUpdatedAt","fetchStatus","status","isPlaceholderData","_optimisticResults","fetchOnMount","fetchOptionally","networkMode","select","selectError","placeholderData","Date","now","isFetching","isPending","isError","isLoading","isSuccess","isInitialLoading","failureCount","fetchFailureCount","failureReason","fetchFailureReason","errorUpdateCount","isFetched","dataUpdateCount","isFetchedAfterMount","isRefetching","isLoadingError","isPaused","isRefetchError","nextResult","defaultNotifyOptions","notifyOnChangeProps","notifyOnChangePropsValue","includedProps","some","typedKey","has","shouldNotifyListeners","onQueryUpdate","notifyManager","batch","listener","retryOnMount","shouldLoadOnMount","refetchOnMount","field","value","suspense","isStaleByTime","InfiniteQueryObserver","fetchNextPage","fetchPreviousPage","behavior","infiniteQueryBehavior","meta","fetchMore","direction","isFetchingNextPage","fetchMeta","isFetchingPreviousPage","hasNextPage","hasPreviousPage","createValue","isReset","clearReset","reset","QueryErrorResetBoundaryContext","useQueryErrorResetBoundary","IsRestoringContext","useIsRestoring","Provider","ensurePreventErrorBoundaryRetry","errorResetBoundary","useClearResetErrorBoundary","getHasError","throwError","params","ensureStaleTime","shouldSuspend","useInfiniteQuery","queryClient","Observer","isRestoring","onStoreChange","unsubscribe","subscribe","batchCalls","useBaseQuery","async","fetchPosts","_ref","pageParam","response","json","cssProps","root","name","styles","center","Head","___EmotionJSX","queryFn","initialPageParam","getNextPageParam","lastPage","nextCursor","LayoutTemplate","Container","css","Posts","FetchPostLoader","React","pages","map","page","pageIndex","currentPage","posts","EmptyPost","PostList","post","Post","id","excerpt","link","slug","title"],"sourceRoot":""}