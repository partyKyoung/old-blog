{"pages":[{"title":"About Me","text":"박유경 (Youkyoung Park)Web Front end Developer 공부하고 경험한 것을 기록하고 있습니다.잘못된 내용이 있거나 궁금한 점이 있으면 언제든 연락주세요! email: kyoungah@kyoungah.com portfolio: http://kyoungah.com","link":"/about/index.html"},{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"","text":"","link":"/tags/index.html"}],"posts":[{"title":"javascript로 사진 똑바로 만들기","text":"회사에서 열심히 일을 하던 도중 이슈가 하나 생겼다. 폰으로 사진 파일을 업로드 하면 어떤 사진들은 이미지 방향이 자꾸 돌아가서 업로드 되는 것이었다. 사실 좀 귀찮기도 하고 어떻게 고칠지 막막하기도 해서 그냥 냅두고 싶었지만 그러면 절대 안되기 때문에 우여곡절 어떻게든 방법을 찾아서 해결 했는데 그 과정을 공유해보고자 한다. 원인카메라로 사진을 찍으면 메타데이터로 exif 값이 저장된다. 이 exif 는 디지털 카메라에서 이용되는 이미지 파일 포맷인데 여기에 orientation 이라고 사진의 방향 값이 저장되어 있다. exif-js 오픈소스를 사용하면 exif 데이터를 읽어올 수 있길래 한번 써보았다. 12345678910111213141516171819function getExif(file) { const reader = new FileReader(); const imageViewer = document.getElementById(\"imageViewer\"); const image = file.files[0]; reader.onload = e =&gt; { EXIF.getData(image, () =&gt; { const tags = EXIF.getAllTags(image); // metadata 출력 console.log(tags); // 이미지 미리보기 imageViewer.style.backgroundImage = `url(${e.target.result})`; }); }; reader.readAsDataURL(image);} 해결 방법대표님이 세가지 솔루션을 제시해주셨다. client 단에서 업로드시 orientation 값 기준으로 수정하여 서버에 업로드 server 단에서 업로드 후 rotation 처리 보여줄때 그때마다 rotation 처리해 주는 방식 여기서 JavaScript-Load-Image 오픈소스를 사용하면 첫번째 방법으로 해결이 될것 같아서 첫번째 방법으로 문제를 해결하기로 했다. 12345678910111213function fixRotationOfFile(file) { const image = file.files[0]; loadImage( image, img =&gt; { const imageViewer = document.getElementById(\"imageViewer\"); imageViewer.appendChild(img); }, { maxWidth: 400, orientation: true } );} 이렇게 하면 이미지가 정뱡향으로 출력된다! 123456789101112131415161718192021return new Promise((resolve, reject) =&gt; { const image = file.files[0]; const fileType = image.type; loadImage( file, img =&gt; { if (img.type === \"error\") { reject(img); } // img.toBlob(blob =&gt; { const createdFile = new File([blob], image.name); // 이미지 업로드 실행은 여기서 }, fileType); }, { orientation: true } );}); 위의 코드와 같은 식으로 정방향으로 출력된 blob 이미지를 file 로 바꾸어 이미지를 업로드 하는 식으로 해결했다. 마무리AWS S3 및 몇몇 서비스에서는 원본을 그대로 두고 이미지가 출력될 때마다 rotation 처리를 해주는 방식을 사용한 것 같던데 나중에 기회가 된다면 이미지가 출력될 때마다 rotation 처리를 해주는 방식 으로도 한번 해결해보고 싶다.","link":"/2018/07/11/2018-07-03-javascript-memo-ex-if/"},{"title":"Node.js 내장 객체","text":"Node.js에서는 기본적인 내장 객체와 내장 모듈으르 제공한다. 브라우저의 window 객체와 비슷하다고 보면 된다.노드에는 DOM이나 BOM이 없어 window와 document 객체를 사용할 수 없다. 노드에서 window나 document를 사용하면 에러가 발생한다. global브라우저의 window와 같은 전역 객체이다. 모든 파일에서 접근할 수 있다. window.open 메서드를 그냥 open으로 호출할 수 있는 것 처럼 global도 생략 가능하다.전역 객체라는 점을 이용하여 간단한 데이터를 파일끼리 공유할 때 사용하기도 하나 프로그램의 규모가 커질 수록 어떤 파일에서 global 객체에 값을 대입했는지 찾기 힘들어 유지보수에 어려움을 겪게 되기 때문에 남용하면 안된다. console노드에서는 window 대신 global 객체 안에 console이 들어있다. 브라우저에서의 console과 거의 비슷하다. console 객체는 보통 디버깅을 위해 사용된다. console.time(레이블): console.timeEnd(레이블)과 대응되어 같은 레이블을 가진 time과 timeEnd 사이의 시간을 측정한다. console.log(내용): 평범한 로그를 콘솔에 표시한다. console.error(에러): 에러를 콘솔에 표시한다. console.dir(객체, 옵션): 객체를 콘솔에 표시할때 사용한다. 첫 번째 인자로 객체를 넣고 두 번째 인자로 옵션을 넣는다. console.trace(레이블): 에러가 어디서 발생했는지 추적할 수 있게 해준다. 타이머타이머 기능을 제공하는 함수인 setTimeout, setInterval, setImmediate는 노드에서 window 대신 global 객체 안에 들어있다. 이 타이머 함수들은 모두 아이디르르 반환하고 이 아이디를 사용하여 타이머를 취소할 수 있다. setTimeout(콜백 함수, 밀리초): 주어진 밀리초(1000분의 1초) 이후에 콜백 함수를 실행한다. clearTimeout(아이디): setTimeout을 취소한다. setInterval(콜백 함수, 밀리초): 주어진 밀리초마다 콜백 함수를 반복 실행한다. clearInterval(아이디): setInterval을 취소한다. setImmediate(콜백 함수): 콜백 함수를 즉시 실행한다. clearImmediate(아이디): setImmediate를 취소한다. filename, dirname노드는 filename, dirname이라는 키워드로 경로에 대한 정보를 제공한다. 파일에 filename과 dirname을 넣어두면 파일 실행 시 현제 파일명과 파일 경로로 바뀐다.경로가 문자열로 반환되가도 하고 \\나 /같은 경로 구분자 문제도 있어 보통은 이를 해결해주는 path 모듈과 함꼐 쓴다. module, exports모듈을 만들때 주로 module.exports를 사용하지만 module 객체 말고 exports 객체로도 모듈으르 만들 수 있다. module.exports 1234567const test = 0const test2 = 1module.exports = { test, test2} exports 12exports.test = 0exports.test2 = 1 module.exports와 exports가 동일하게 동작하는 이유는 module.exports와 exports가 같은 객체를 참조하기 때문이다.exports 객체 사용 시 module.exports와의 참조 관계가 깨지지 않도록 주의해야 한다. module.exports에는 어떤 값이든 대입해도 되지만 exports에는 객체만 대입할 수 있다. 만약 exports에 다른 값을 대입하면 객체의 참조 관게가 끊겨 더 이상 모듈로 기능하지 않는다. exports와 module.exports에는 참조 관계가 있으므로 한 모듈에 exports 객체와 module.exports를 동시에 사용하지 않는 것이 좋다.","link":"/2019/01/10/2018-01-09-node-global/"},{"title":"Fragment","text":"JSX1234567891011121314import React, { Component } from 'react';class App extends Component { render() { return ( &lt;div&gt; &lt;h1&gt;React.js&lt;/h1&gt; &lt;div&gt;JSX &lt;br/&gt; :)&lt;/div&gt; &lt;/div&gt; ); }}export default App; JSX는 JavaScript XML의 약자이다. render 함수를 보면 HTML 태그 처럼 생긴 것들이 보이는데 저 부분이 JSX 이다. JSX로 컴포넌트가 화면에 어떻게 보일지 나타낼 수 있다. JSX는 HTML과 비슷해 보이지만 용도도 사용법도 다르다. 12345678910111213141516171819202122import React, { Component } from 'react';class App extends Component { render() { return ( /* { error &lt;div&gt;안녕하세요&lt;/div&gt; &lt;div&gt;반갑습니다&lt;/div&gt; } */ &lt;div&gt; &lt;div&gt;안녕하세요&lt;/div&gt; &lt;div&gt;반갑습니다&lt;/div&gt; &lt;/div&gt; ); }}export default App; JSX는 컴포넌트에 여러 요소가 있다면 부모 요소 하나로 꼭 감싸야 한다. Virtual DOM에서 컴포넌트 변화를 감지해 낼 때 효율적으로 비교할 수 있도록 컴포넌트 내부는 DOM 트리 구조 하나여야 한다는 규칙이 있기 때문이다.하지만 이렇게 요소들을 감싸기 위한 용도로 DOM 요소들을 추가하다보면 쓸모없는 요소들이 늘어나게 된다. Fragment1234567891011121314import React, { Component, Fragment } from 'react';class App extends Component { render() { return ( &lt;Fragment&gt; &lt;div&gt;안녕하세요&lt;/div&gt; &lt;div&gt;반갑습니다&lt;/div&gt; &lt;/Fragment&gt; ); }}export default App; Fragment는 React v16 이상의 버전에서 도입되었다. Fragment로 부모 DOM 요소를 추가하지 않고도 자식 요소들을 그룹화 할 수 있다.Fragment를 사용하면 단지 부모 요소로만 쓰이는 불필요한 DOM을 줄일 수 있어 조금 더 빨라지고 메모리 사용량도 조금 더 적어진다. 개발자 도구로 DOM 요소를 확인 할 때도 조금 더 편리하게 확인할 수 있다. 마무리실무에서 React.js를 사용하면서 왜 JSX에 부모요소로 꼭 자식요소들을 감싸야 하는지 이유도 모른체 매번 써왔는데 이번에 처음부터 React.js를 공부하면서 드디어 그 이유를 알게 되었다 ㅠ…개인적으로 부모요소 규칙때문에 짜증난적이 한두번이 아니었는데 Fragment 덕분에 많이 편해졌다. 필요한걸 쏙쏙 골라서 업데이트 해주는 React.js가 너무 좋다 :). Reference리액트를 다루는 기술Fragments","link":"/2018/08/05/2018-08-05-reactjs-jsx-fragment/"},{"title":"React.js","text":"React.js?페이스북에서 개발한 오픈소스 JavaScript Library. React.js 특징Only ViewReact는 오직 View만 신경쓰고 담당하는 Library 이다. JSXReact.js는 컴포넌트를 화면에 어떻게 보일지를 정의할 때 JSX를 사용한다. JSX는 JavaScript XML의 약자이다.JSX를 사용하지 않아도 되지만 사용하는게 훨씬 편하다. Virtual DOMVirtual DOM 을 사용하여 상태의 변함에 따라 선택적으로 유저 인터페이스를 렌더링 한다. 따라서, 최소한의 DOM 처리로 컴포넌트들을 업데이트 할 수 있게 해준다. DOM은 문서 객체 모델(Document Object Model)의 약자이다. HTML과 XML 문서를 위한 API 이며 문서의 구조화된 표현을 제공한다. Virtual DOM은 실제 DOM의 빠른 인 메모리의 형태이며 JavaScript와 DOM이 반응을 하는것 처럼 다룰 수 있게 하는 추상적 개념이다. 동작과정은 아래의 순서와 같다. 데이터 모델 상태가 변경될 때 마다 Virtual DOM과 React는 Virtual DOM 표현에 맞게 UI를 다시 렌더링한다. 컴포넌트가 초기 렌더링을 할 때 render 함수를 사용하는데 이 함수는 View의 생김새, 작동하는 방법 같은 정보를 지닌 객체를 반환한다.렌더링이 끝나면 지니고 있는 정보들을 사용하여 HTML 마크업을 만들고 지정해놓은 DOM 요소 안에 주입한다.컴포넌트가 데이터를 업데이트 했을 때 새로운 데이터를 가지고 render 함수를 또 호출한다. React는 두 개의 Virtual DOM 사이의 차이점, 즉 실제 DOM이 변경되어야 하는 부분을 연산한다. render 함수가 반환한 결과와 이전 render 함수가 만들었던 정보를 최소한의 연산으로 비교한다. React는 실제 DOM에서 변경 되어야 하는 부분만 새로 실제 DOM에 적용한다. 두 Virtual DOM 표현의 차이점을 찾고 실제 DOM에 업데이트 된 패치만 다시 랜더링하는 과정은 빠르며 실제로 다시 그려져야 하는 부분이 무엇인지 고민할 필요가 없다. UI를 업데이트하는 과정에서 생기는 복잡함을 모두 해소하고 더욱 쉽게 업데이트에 접근할 수 있다. ComponentComponent는 UI를 재사용할 수 있는 독립적인 단위 라고 볼 수있다.UI는 컴포넌트를 이용해 제작하며 원하는 방법으로 이러한 컴포넌트를 조합할 수 있다. 실제로 애플리케이션을 개발할 때는 커스텀 컴포넌트를 제작하게 된다. 단방향 데이터 흐름부모 컴포넌트에서 자식 컴포넌트로 흐르는 단방향 데이터 흐름을 지향한다. 마무리회사에서 이때까지 혼자서 프론트앤드를 담당하다가 신입이 들어오면서 모르는게 있으면 가르쳐 주고 같이 협업하게 되었다. 과연 내가 누구에게 가르쳐주고 도와줄만큼 React.js를 잘알고 있나 싶어서 리마인드 하는식으로 다시 한번 되짚고 넘어가보고자 한다.열심히 공부해야지. Reference리액트를 다루는 기술","link":"/2018/08/02/2018-08-02-reactjs-first-reactjs/"},{"title":"Node.js 작업환경 설정하기","text":"Node.js 프로젝트를 만들고 Webpack 설정까지 해보자. 시작하기 전에 필요한 것Node.jsNode.js 공식사이트여기서 Node.js 를 설치할 수 있다. NPM 또는 YarnNPMNPM은 Node.js Package Manger의 약자이다. Node.js에서 사용가능한 모듈들을 패키지화시켜 모아놓은 곳 이다. npm으로 원하는 모듈들을 설치하고 관리할 수 있다. YarnYarn은 의존하는 라이브러리가 많아지면 느려지고 설치하는 시기에 따라 다른 버전을 설치할 가능성이 있는 NPM의 단점을 보완하기 위해 나왔다. npm을 대체할 수 있다. NPM의 이슈는 NPM 최신버전에서 해결됐고 속도 차이점은 솔직히 난 잘 못느끼겠다. 이번에 Node.js를 공부하면서 Yarn이 써보고 싶어서 Yarn을 썼는데 딱히 NPM이랑 다른건 없는거 같으니 원하는걸 쓰면 되겠다. 작업환경 설정es6 개발환경을 구축하기 위해 webpack이랑 babel을 사용할 것이다. 12yarn init -yyarn add --dev webpack webpack-cli babel-loader babel-core babel-preset-env 먼저 yarn init 또는 npm init 으로 package.json 파일을 생성해준 후 webpack과 babel 관련 모듈들을 깔아주자. webpack.config.js1234567891011121314151617181920212223242526272829const webpack = require('webpack');const path = require('path');const nodeExternals = require('webpack-node-externals');module.exports = { target: 'node', // 기본은 web 이기 때문에 꼭 node로 맞춰줘야 한다. externals: [nodeExternals()], entry: { server: './src/server.js' }, output: { filename: '[name].js', path: path.resolve(__dirname, 'build') }, module: { rules: [ { test: /\\.js$/, exclude: /(node_modules)/, // babel-loader로 트랜스파일시 node_modules는 제외한다. use: { loader: 'babel-loader', options: { presets: ['babel-preset-env'] } } } ] }}; server-side에서도 webpack을 사용할 수 있도록 webpack.config.js를 작성했다. webpack-node-externals은 node_modules를 빌드과정에서 제외시키는 역할을 한다. src/server.js12345678import http from 'http';const server = http.createServer();const port = 3000;server.listen(port, () =&gt; { console.log('server start!', port);}); 간단하게 서버쪽 소스를 작성했다. package.json123\"scripts\": { \"build\": \"webpack --mode production &amp;&amp; node ./build/server.js\"}, 빌드와 실행을 동시에 하기 위해 script에 build 명령어도 넣어주면 설정은 끝났다.webpack 4 버전 부터는 꼭 –mode (develop or production)를 설정해주어야한다. npm run build빌드도 잘되고 실행도 잘된다. 작업환경을 끝냈으니 이제 본격적으로 Node.js 공부를 해보자. 해당 포스트에 작성된 모든 소스는 여기서 확인할 수 있다.","link":"/2018/07/31/2018-07-24-nodejs-setting/"},{"title":"Component","text":"ComponentComponent는 JavaScript function과 같다. props라고 불리는 임의의 input을 받아들이고 화면에 어떻게 나타낼지를 설명하는 React Element를 반환한다.Component는 데이터가 주어졌을 때 이에 맞추어 UI를 만들어 주고 LifeCycle API를 이용하여 Component가 화면에서 나타날 때, 사라질 때, 변화가 일어날 때 주어진 작업들을 처리할 수 있으며 method를 만들어 특별한 기능을 붙일 수 있다. 12345678910111213import React, { Component } from 'react';class App extends Component { render() { return ( &lt;div className=\"App\"&gt; first component! &lt;/div&gt; ); }}export default App; 컴포넌트의 초기 코드이다. es6에 추가된 export 명령어로 컴포넌트를 모듈화 시켜 내보낼 수 있다. 123456789101112import React, { Component } from 'react';import App from './App';class AppContainer extends Component { render() { return ( &lt;App /&gt; ); }}export default AppContainer; import 명령어로 원하는 컴포넌트를 불러와 사용할 수 있다. import 역시 es6에서 추가된 명령어 이다. ReferenceComponents and Props리액트를 다루는 기술","link":"/2018/09/02/2018-08-30-reactjs-component/"},{"title":"자료구조란 무엇인가","text":"자료와 정보의 관계 자료: 현실 세계에서 관찰이나 측정을 통해서 수집된 값이나 사실. 우리의 생활에서 실제로 만질 수 있거나 볼 수 있거나 하는 것(길이, 무게, 부피 등을 측정할 수 있는 대상)에 대해서 물리적인 단위로 표현하여 얻어 낼 수 있는 내용. 정보: 어떤 상황에 대해서 적절한 의사결정을 할 수 있게 하는 지식으로서 자료의 유효한 해설이나 자료 상호간의 관계를 표현하는 내용. 어떠한 상황에 적절한 결정이나 판단에 사용될 수 있는 형태로 가공되거나 분류되기 위해 ‘처리 과정’을 거쳐서 정리되고 정돈된 ‘자료의 2차 처리 결과물’. I = P(D)I: 정보D: 자료P: 처리 자료와 정보를 쌀과 밥으로 예를 들면 농부가 쌀을 재배하고 식품회사에 팔면 식품회사에서 밥을 짓고 그 밥으로 즉석밥을 만들 듯이 자료도 수집 - 측정 - 관찰 등과 같은 과정으로 얻어진 후 가공하고 정리해서 정보로 만들어진다. 컴퓨터가 나오기 전 자료를 가공하고 정리하는 일은 사람이 했는데 컴퓨터를 이용하여 자료를 정리하고 가공하게 되면서 자료의 규모가 커지고 정밀해졌다. 추상화 추상화: 공통적인 개념을 이용하여 같은 종류의 다양한 객체를 정의하는 것. 예를 들면 트럭, 버스, 승용차 등 모두 자동차라는 특성을 가지고 있다. 세부적으로 생각하면 다른점이 많지만 평소에 대화할 때 편하게 그냥 자동차라고 하듯이 추상화를 통해 말하는 사람의 의사를 간결하게 전달할 수 있게 된다.자료의 추상화는 다양한 객체를 컴퓨터에서 표현하고 활용하기 위해 필요한 자료의 구조에 대해서 공통의 특징만 뽑아 정의한 것이다. 자료의 추상화에는 컴퓨터 내부에서 처리되는 이진수의 표현 방법이나 저장 위치 등은 표현되지 않는다. 단순하게 개발자의 머릿속에 그림을 그리는 일과 같은 것 이라고 생각하면 된다. 자료구조의 개념 자료구조: 전산학에서 자료를 효율적으로 이용할 수 있도록 컴퓨터에 저장하는 방법 (출처: 위키백과). 추상화를 통해 자료의 논리적 관계를 구조화 한 것. 자료의 추상화와 구조화가 적절히 이루어지지 못하면 소프트웨어는 비효율적으로 수행되거나 소프트웨어의 확장성에 문제가 생길 수 있다. 따라서 자료가 복잡해지거나 소프트웨어가 복잡해질수로고 자료구조의 중요성이 강조되고 있다. 어떤 일을 컴퓨터에 시키기 위해 필요한 명령문을 알고리즘이라고 한다면 알고리즘이 일을 하기 위해서 필요한 다양한 자료의 논리적 구조나 논리적 관계를 자료구조 라고 한다.자료구조가 컴퓨터에 대한 입력값의 추상화된 상태라면 알고리즘은 컴퓨터가 수행해야 할 명령의 추상화다. I = P(D, A) 개발자는 입력될 값을 머릿속에서 추상화된 형태(자료구조)로 구조화 하고, 수행되어야 할 명령어를 머릿속에서 추상화된 형태(알고리즘)으로 체계화 한 후 프로그래밍 언어로 자료구조와 알고리즘을 표현(구체화) 한다. 자료구조의 형태는 프로그래밍 언어에서 제공되는 ‘미리 정의된 자료구조’와 개발자가 정의하여 사용하는 ‘사용자 정의 자료구조(스택, 큐, 트리, 그래프 등)’로 나누어 진다. 미리 정의된 자료구조는 정수, 실수, 문자와 같은 ‘기본 자료구조’와 배열, 구조체, 포인터 같은 ‘파생된 자료구조’로 나뉘어 진다.미리 정의된 자료구조는 프로그래밍 언어 개발자가 프로그램 개발을 위해 미리 정의하지만 사용자 정의 자료구조는 프로그램 개발자가 자신의 프로그램 개발 방향에 따라 프로그래밍 언어로 새롭게 정의하여 사용한다. Reference방송대 컴퓨터과학과 자료구조 1강","link":"/2018/09/16/2018-09-03-data-structure-first/"},{"title":"배열","text":"배열인덱스와 원소값(&lt;index, value&gt;)의 쌍으로 구성된 집합.예를 들면 101호, 201호, 301호.. 처럼 호수(인덱스) 순으로 표현되는 아파트(메모리 영역, 원소값을 위한 저장소)라고 생각하면 쉽다. 배열의 특징 원소들이 모두 같은 자료형, 즉 동질의 값과 기억 공간의 크기가 같다. 원소의 메인 메모리 공간(메인 메모리 주기억 장치)에서의 물리적인 위치를 ‘순서’적으로 결정한다. 배열 각 원소의 물리적인 위치(메모리 주소)의 순서가 배열의 인덱스 순서(논리적인 순서)와 일치한다. 즉 배열의 순서는 메모리 공간에서 저장되는 ‘원소값의 물리적 순서’를 의미한다. 배열의 인덱스 값을 이용해서 배열의 원소값에 직접 접근 할 수 있다. 배열의 인덱스 값은 물리적으로 컴퓨터가 처리하는 값이 아니라 사람이 이해하고 직관적으로 받아들이기 위해 정의한 값이고 이 값을 컴퓨터가 해석하여 물리적인 값으로 변환하고 이를 전기적인 신호로 바꾸어 계산한다. 1차원 배열 가장 기본적인 배열은 1차원 배열이다. 한 줄짜리 배열을 의미하므로 인덱스는 하나이다. 배열의 원소들은 컴퓨터 메모리의 연속적은 기억장소에 할당되어 순차적으로 저장된다. 배열 A가 있을 때 A[i]는 배열의 첫번째 원소 A[0]이 저장된 주소인 a로부터 시작하여, A[0]부터 A[i - 1]개 까지 i개의 배열 A[]를 지나서 저장된다. 따라서 A[]의 크기를 k라고 가정하면, A[i] 저장 주소는 a + i * k 가 된다. 2차원 배열1차원 배열을 여러개 쌓아 놓으면 2차원 배열이 된다.2차원 배열에서 하나의 원소는 두 개의 첨자 i와 j의 쌍으로 구분되며 두 개 이상의 첨자가 필요한 배열을 총칭해서 다차원 배열이라고 한다. i에 해당하는 것을 행(row)이라고 하고 j에 해당하는 것을 열(column)이라고 한다. 2차원 배열은 하나의 행을 연속적으로 메모리에 할당하고 그 다음 행을 메모리 영역에 할당한다.2차원 배열은 행렬을 프로그램으로 구현하는 경우에 많이 사용된다. 보통 행렬은 컴퓨터과학 분야에서 객체 간의 관계, 네트워크의 시뮬레이션, 최단거리 계산 등에 사용된다. 희소행렬행렬 중 원소값이 0인 원소가 그렇지 않은 원소보다 상대적으로 많을 때 이를 희소행렬이라 한다. 컴퓨터 메모리의 낭비를 막고 효율성을 높히기 위해서 희소행렬의 0인 원소는 저장하지 않고 0이 아닌 값만을 따로 모아서 저장하는 방법이 필요한데 이를 2차원 배열로 표현할 수 있다. Reference방송대 컴퓨터과학과 자료구조 1강","link":"/2018/11/11/2018-09-16-data-structure-array/"},{"title":"html 이메일 템플릿 작성하기","text":"오랜만에 퍼블리싱 외주를 받았는데 이메일 템플릿을 퍼블리싱 하는 일이었다.이메일 템플릿은 처음 퍼블리싱 해보는거라 작업 전 먼저 사전작업으로 리서치나 관련 정보들을 알아봤다. 리서치먼저 내가 받은 이메일 중 몇몇 이메일을 검사해 보았다. 대부분은 table로 레이아웃을 잡고 퍼블리싱을 했다. 평범하게 div를 사용해서 레이아웃을 잡은 이메일들도 있었다. 스타일은 전부다 인라인 스타일을 적용하고 있었다. 이메일 템플릿을 작성할 때 주의해야 할 점위에서 리서치한 결과대로 검색을 해봤더니 이메일 클라이언트 템플릿을 만들 때에는 주의해야 할 것들이 많았다. 레이아웃은 table로 잡자.이메일에서 사용하는 HTML과 CSS는 웹 표준과는 거리가 멀다. 게다가 이메일 클라이언트 마다 html과 css를 다르게 해석하기 때문에 주의해야 한다. 다행이 table 코드는 대부분 적용되므로 이를 사용하는 방법이 가장 많이 쓰인다.맨처음 이메일 템플릿 작업을 들어가면서 에이 뭐 어때 하며 평소대로 div나 다른 태그들로 레이아웃을 잡았었다가 작업했었다가 나중에 아웃룩 구버전에서 레이아웃이 다 깨지는걸 확인하고 허겁지겁 table로 레이아웃을 다 바꿨다 ㅠ. 인라인으로 CSS를 적어주는 것이 가장 안전하다.대부분의 메일 서비스 업체에서는 보안상 css 파일을 모두 제거하기 때문에 인라인 스타일로 css를 작성해주는 것이 좋다. 대신 안되는 css 요소들도 많으니 조심해야 한다. (position, background-image 등…) media query도 지원하는 곳에서만 쓸 수 있다. 이메일 템플릿을 작성하면서 도움을 받았던 사이트 HTML 이메일 템플릿 처음부터 제작하기이메일 템플릿을 작성하는 방법을 가르쳐준다. 튜토리얼 하는 식으로 한번 읽어보고 진행했었다. Responsive Email Templates무료 이메일 템플릿을 다운받을 수 있는 사이트이다. 이메일 템플릿 하나를 골라 다운 받은 뒤 작업하면서 많이 참고 했었는데 도움이 많이 되었다. litmus작성한 템플릿을 아웃룩, 아이폰, 안드로이드 등 여러 클라이언트에서 테스트 해 볼 수 있는 웹서비스이다. 일주일 동안 무료로 사용할 수 있고 그 다음 부터는 결제를 해야한다. gmail이랑 네이버 메일에서는 작성했던 템플릿이 무너지지 않고 잘 나오길래 안심하고 있다가 litmus로 아웃룩에서 다 무너져있는 템플릿을 보고 식겁하며 새로 작업했었다. CSS Inliner Toolhtml이랑 style을 합쳐서 인라인 스타일 html을 만들어주는 웹사이트이다. 이 사이트 덕분에 css파일과 html 파일을 편하게 합칠 수 있었다. 대신 여러번 작업하면 제대로 결과물이 출력이 안되는 오류가 있어서 파일을 한번 합치고 새로고침 하고 또 다른 파일들을 합치는 작업을 반복했었다. 마무리이메일 템플릿 퍼블리싱을 하면서 테이블로 레이아웃 짜는것이 얼마나 구리고 html5가 얼마나 좋은지 느낄 수 있었다. css도 마음대로 못쓰고 미디어쿼리가 안되는것도 정말 힘들었다 ㅠ. 다시는… 이메일…템플릿…퍼블리싱…하고 싶지….않아…","link":"/2018/08/23/2018-08-11-html-email-templete/"},{"title":"props","text":"propsprops는 Component 속성을 설정할 때 사용하는 요소이다. Component는 props를 받고 props의 값에 따라 다르게 렌더링 하거나 작동할 수 있다.PropTypes 속성의 종류는 React 공식 문서에서 확인할 수 있다. 부모 컴포넌트12345678910111213import React, { Component } from 'react';import Child from './Child';class Parent extends Component { render() { return ( &lt;Child singer=\"Nell\" song=\"Home\"/&gt; ); }}export default Parent; props값은 해당 컴포넌트를 불러와 사용하는 부모 컴포넌트에서만 설정할 수 있다. 자식 컴포넌트12345678910111213141516// 자식 컴포넌트import React, { Component } from 'react';class Child extends Component { render() { const { singer, song } = this.props; return ( &lt;div&gt; 지금 듣고 있는 노래는 {singer}의 {song}입니다. &lt;/div&gt; ); }}export default Child; props에 접근할 때는 this 키워드를 사용하여 접근한다. 부모 Component에서 자식 Component로 전달되며 받아온 props는 수정할 수 없다. propTypes1234567891011121314import React, { Component } from \"react\";import PropTypes from \"prop-types\";class Child extends Component { // ... 생략}Child.propTypes = { singer: PropTypes.string, song: PropTypes.string.isRequired // 필수적으로 존재해야 한다. };export default Child; 컴포넌트의 필수 props를 지정하거나 props 타입을 지정할 때는 propTypes를 사용한다. propTypes를 지정하려면 prop-types 모듈이 필요하다.필수 props를 지정하고 싶을 땐 propTypes를 설정할 때 isRequired를 사용하면 된다. 12345export default class Parent extends Component { render() { return &lt;Child singer={123} song=\"Home\" /&gt;; }} props의 타입을 propTypes에서 설정한 타입과 다른 타입으로 넘겨주면 렌더링은 되나 개발자 도구에 오류 메시지가 출력된다. 12345export default class Parent extends Component { render() { return &lt;Child singer=\"Nell\" /&gt;; }} 필수 props가 빠졌을 때도 렌더링은 되나 개발자 도구에 오류 메시지가 출력된다. defaultProps12345678910111213141516171819import React, { Component } from \"react\";import PropTypes from \"prop-types\";class Child extends Component { // ... 생략}Child.propTypes = { singer: PropTypes.string, song: PropTypes.string.isRequired};Child.defaultProps = { singer: \"Hoobastank\", song: \"Without A Fight\"};export default Child; defaultProps를 사용해서 prop의 기본 값을 설정할 수 있다. defaultProps는 prop-types 모듈이 필요 없다. 12345export default class Parent extends Component { render() { return &lt;Child /&gt;; }} props를 지정해주지 않으면 defaultProps에 있는 기본 값이 적용된다. transform-class-properties1234567891011121314151617181920212223242526import React, { Component } from \"react\";import PropTypes from \"prop-types\";class Child extends Component { static propTypes = { singer: PropTypes.string, song: PropTypes.string.isRequired }; static defaultProps = { singer: \"Hoobastank\", song: \"Without A Fight\" }; render() { const { singer, song } = this.props; return ( &lt;div&gt; 지금 듣고 있는 노래는 {singer}의 {song}입니다. &lt;/div&gt; ); }}export default Child; propTypes, defaulProps를 클래스 내부에서 정의할 수도 있다. 이 문법을 사용하려면 transform-class-properties babel 플러그인이 필요한데 create-react-app으로 생성한 프로젝트는 기본적으로 적용되어 있기 때문에 따로 설정할 필요가 없다. typescripttypeScript를 사용하여 props에 타입을 줘보자. 123456789101112131415161718192021222324252627import * as React from \"react\";interface ChildProps { singer: string; song: string;}interface ChildState {}class Child extends React.Component&lt;ChildProps, ChildState&gt; { static defaultProps = { singer: \"Hoobastank\", song: \"Without A Fight\" }; render() { const { singer, song } = this.props; return ( &lt;div&gt; 지금 듣고 있는 노래는 {singer}의 {song}입니다. &lt;/div&gt; ); }}export default Child; Reference리액트를 다루는 기술","link":"/2019/04/25/2018-09-28-reactjs-props/"},{"title":"컴파일러 개요","text":"컴파일러의 필요성컴퓨터 언어 중에서 어떤 문제를 풀기 위하여 일련의 과정을 기술하는 데 사용되는 언어를 프로그래밍 언어 라고 한다. 컴퓨터는 0과 1로 구성된 2진법 수만 취급하므로 초기의 프로그래밍 언어는 0과 1로 작성된 기계어 였다. 명령어를 0과 1로 나타낸다는 것은 매우 불편했고 컴퓨터의 하드웨어 특성과 동작과정을 잘 알아야 하기 때문에 매우 어려웠다. 따라서 조금 더 편리한 프로그래밍 언어를 생각하게 되었는데 그것이 어셈블리어(assembly languagge)이다. 어셈블리어는 0과 1로 구성된 명령어 대신에 A(ADD), L(Load) 등과 같이 그에 대응하는 기호를 사용함으로써 불편한 프로그래밍 작업을 완화 시켜 주었다. 어셈블리어(영어: assembly language) 또는 어셈블러 언어(assembler language)는 기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급 언어이다. (출처: 위키백과) 어셈블리어로 작성된 프로그램을 입력하면 어셈블러(어셈블리어로 작성된 프로그램을 그에 대응하는 기계어로 번역해 주는 번역기)가 번역하여 기곙어로 작성된 프로그램을 출력해준다. 그러나 어셈블리어도 기계어 대신에 기호를 사용한다는 것 뿐이지 결국은 기계어 처리방식을 알아야 하므로 프로그래밍이 매우 어려웠다. 이에 영어와 유사한 C, C++, JAVA 같은 고급언어를 만들게 되었다. 이처럼 기계어 보다는 어셈블리어, 어셈블리어 보다는 고급언어가 더 배우기 쉽고 프로그램 작성이 용이하며 디버깅이 쉽고 이식성도 높힐 수 있다. 하지만 이러한 고급언어로 작성된 프로그램은 결국 기계가 이해할 수 있는 기계어로 다시 바꾸어 주어야 한다. 즉 번역기가 번역을 해 주어야 한다. 번역기란 이처럼 하나의 프로그래밍 언어로 작성된 프로그램을 입력으로 하여, 그와 동등한 의미를 갖는 다른 프로그래밍 언어로 된 프로그램을 출력하는 하나의 프로그램이다. 이때 입력되는 프로그램을 원시 프로그램이라 하고 이 프로그램을 기술한 언어를 원시 언어라 한다. 출력되는 프로그램을 목적 프로그램이라 하고 ㅗ이 프로그램을 기술한 언어를 목적언어라 한다. 번역기의 종류를 살펴보면 어셈블러, 컴파일러, 프리프로세서, 인터프리터 등이 있는데 이 중 가장 대표적인 번역기가 컴파일러다. 일반적으로 모든 컴퓨터에는 어셈블러가 있다. 따라서 컴파일러는 프로그램을 어셈블리어로 작성된 프로그램으로 번역을 해준다. 따라서 컴파일러에서 기계어 프로그램으로 번역하는 기능을 제외할 수 있으므로 컴파일러를 제작하기가 수월해진다. 결론적으로 컴파일러와 인간의 의사 전달을 위해서는 고급언어가 필요하고, 고급언어로 작성된 프로그램을 컴퓨터가 인식할 수 있도록 기계어로 번역해 주어야 하므로 컴파일러가 필요하다. 켬파일러와 인터프리터컴파일러컴파일러는 고급 프로그래밍 언어를 기계어로 번역하는 프로그램이다. 컴파일러는 입력 프로그램의 전체 문장을 입력된 순서대로 처리하여 전체적인 하나의 목적 프로그램을 완성하고 이것은 후에 로드되어 실행하게 된다. 반복문이나 계속 호출되는 부프로그램처럼 많은 횟수로 반복 처리되는 프로그램인 경우에는 컴파일러 기법이 큰 장점을 갔는다. 전체적으로 디코딩하게 되면 그 다음 부터는 실행만 하므로 효율적이기 때문이다. 그러나 몇 줄의 원시 프로그램이 때로는 몇백개의 기계어로 번역되기 때문에 컴파일러 기법은 커다란 기억장소가 필요하다. 컴파일러 언어에는 C, C++, Java 등이 있다. 인터프리터인터프리터는 컴파일러와 같은 단계를 거치지 않고, 원시 프로그램을 그때그때 처리하므로 인터프리터의 처리과정은 컴파일러와는 다르다. 인터프리터 기법의 처리과정을 살펴보면, 고급언어로 작성된 원시 프로그램을 중간코드로 변환하고, 변환된 중간코드를 명령어 단위로 가져다가 디코드하고 실행한다. 그리고 명령어의 주소를 하나 늘린 후 다음 명령어를 가져온다. 따라서 반복문 등이 있을 때는 반복횟수만큼이나 명령어를 계속 가져와서 디코드하고 실행하므로, 단 한번의 번역으로 끝마치는 컴파일러 기법에 비해 시간이 많이 소요된다. 그러나 사용자가 실행과정을 눈으로 보로 수 있고, 일문일답 식의 대화가 가능하며, 언어에 사용되는 자료를 동적으로 정의하는 등의 융통성이 있다. 인터프리터 언어에는 JavaScript, PHP, Python, Ruby 등이 있다. Reference방송대 컴퓨터과학과 컴파일러 구성 1강","link":"/2018/10/13/2018-10-12-compiler-first/"},{"title":"컴파일러 구조","text":"컴파일러의 논리적 구조컴파일러의 논리적 구조를 살펴보면 6단계로 나누어 볼 수 있다. 각 단계들은 한 프로그램을 어떤 다른 형태로 변형시키지만 이 중 일부 단계는 하나로 합칠 수 있다. 어휘본석 단계어휘분석 단계에서는 원시 프로그램을 읽어 들여서 프로그램 문장을 구성하고 있는 최소 단위인 어휘들을 떼어내어 이 어휘들이 올바른지 분석하는 일을 한다. 어휘들은 이들을 정의한 해당 문법에 의하여 분석되는데 어휘가 올바르지 않으면 오류메시지가 출력되고, 올바른 경우에는 토큰(token)형태로 출력된다. 이와 같은 일을 하는 것을 어휘분석기 또는 스캐너 라고 한다. 토큰은 예약어나 상수, 연산자와 프로그래머가 정의한 식별자, 구분자 등이 있다. ABC:= E 3.14 + ABC / E; 라는 문장을 읽었다고 가정하자.어휘분석 단계에서는 ABC, :=, E, , 3.14, +, ABC, /, E, ; 같이 10개의 토큰으로 분리하며 이러한 토큰들은 토큰번호와 토큰 값으로 구성되며 다음 단계인 구문분석 단계의 입력이 된다. 프로그래머가 작성한 주석은 이 과정에서 모두 처리된다. 구문분석 단계구문분석 또는 파싱(parsing)이라고도 하며 어휘분석 단계의 결과인 토큰들을 입력으로 받아 이 토큰들의 열이 올바른 문장구조를 갖고 있는지를 검사한다. 올바른 문장에 대해서는 그 문장에 대한 구문구조를 만들어 출력하고 올바르지 않은 문장에 대해서는 오류메시지를 출력한다. 이처럼 구문분석을 담당하는 것을 구문분석기(syntax analyzer) 또는 파서(parse)라고 한다. 구문구조는 토큰들을 단말노드로 하는 트리(tree)형태로 치환되는데 이 트리를 파스트리(parse tree)라고 한다. 파스트리는 중간코드 생성 단계에서 이용된다. 파스트리는 불필요한 정보인 식별자, 숫자, 식 등이 있어서 기억공간을 낭비하고 컴파일러의 속도를 떨어뜨린다. 따라서 불필요한 정보를 제거하고 다음 단계에 꼭 필요한 정보만으로 구성된 트리를 만들 수 있는데 이것을 구문트리(syntax tree, abstract syntax tree)라 한다. 의미분석 단계구문분석 단계의 결과인 구문트리가 어떠한 의미가 있고 어떠한 기능을 하는지 분석하고 이러한 기능이 올바르게 수행될 수 있도록 환경을 조성하는 일을 한다. 이와 같은 일을 담당하는 것을 의미분석기(semantic analyzer)라고 한다.여기서는 구문트리를 보며 산술식과 각 문장의 연산자 및 피연산자를 인식하고 유형검사 등을 한다. 유형검사란 각 연산자들이 원시 프로그램 규칙에 의해 허용된 피연산자를 가졌는지를 검사하는 것을 뜻한다. 중간코드 생성 단계이 단계는 최적화를 위한 중간단계이다. 구문분석 단계에서 만들어진 구문트리를 이용하여 코드를 생성하거나 한 문법규칙이 reduce될 때마다 구문지시적 변환으로 이루어진다. 구문지시적 변환은 문법규칙이 reduce될 때 그 규칙에 알맞은 코드생성 루틴을 부름으로써 최적화를 위한 코드, 중간코드를 생성한다. 중간코드 생성을 담당하는 도구를 중간코드 생성기 라고 한다. ex) 중간코드 의미 (*, E, 3.14, T0) T0 = E * 3.14 (/, ABC, E, T1) / T1 = ABC / E (+, T0, T1, T2) T2 = T0 + T1 (:=, T2, ⏀, ABC) ABC := T2 코드 최적화 단계여기서는 코드를 좀더 효율적으로 만들어 코드 실행 시 기억공간이나 실행시간을 절약하기 위한 단계이다. 이 단계는 선택적 단계로 생략되는 경우도 있지만 요즘은 RISC(Reduced Instruction Set Computer)와 같은 컴퓨터 구조의 특성을 활용하기 위하여 최적화 단계를 많이 사용하고 있다.최적화는 지역최적화와 전역최적화, 단일문에서의 최적화와 루프 문장에서의 최적화, 실행 속도 면에서의 최적화, 기억장소 절약 면에서의 최적화로 나눌 수 있다. 목적코드 생성 단계컴파일 단계의 마지막 단계로 연산을 수행할 레지스터를 선택하거나 자료에 기억장소의 위치를 정해주며, 실제로 목적기계어에 대한 코드를 생성하는 단계이다. 이 과정에서는 중간코드 생성 단계에서 만들어진 중간코드들을 기계명령어로 바꾸어 주는 역할을 한다. 컴파일러의 물리적 구조컴파일러의 구현에서는 여러 단계를 모아서 하나의 모듈로 묶을 수 있는데 이를 패스(pass)라고 한다.현재 많이 사용하는 컴파일러 구현방법으로는 1-패스 컴파일러, 2-패스 컴파일러가 있다. 1-패스 컴파일러초창기에 컴파일러를 만들 때 사용하였던 방법으로 컴파일러의 전 과정을 하나의 패스로 구현하는 방법이다. 전진분기의 처리를 위해 빈칸으로 남겨두었다가 그 정보를 얻었을 때 채워 넣는 백패칭(backpatching)이 필요하나 직접 그 기계에 맞는 코드로 변환시킬 수 있기 때문에 효율성이 좋고 실생속도가 빠르다. 2-패스 컴파일러컴파일러의 구성을 중간코드를 기점으로 하여 앞 단계를 전반부, 뒷 단계를 후반부로 구성하는 방법이다. 코드로 직접 번역하지 못하기 때문에 기계코드 표현에 제약을 받고 실생속도가 느리지만 컴파일러를 기능적으로 독립된 여러 모듈로 구성할 수 있기 떄문에 이식성이 좋고 중간코드를 이용한 최적화에 따라 기계와 독립적인 최적화가 가능하며 하나의 패스가 사용했던 공간을 다시 사용할 수 있으므로 기억장소를 절약할 수 있다.일반적으로는 2-패스 컴팡일러를 사용하고 있다. Reference방송대 컴퓨터과학과 컴파일러 구성 1강","link":"/2018/10/28/2018-10-13-compiler-structure/"},{"title":"데이터베이스 모델링","text":"데이터베이스데이터베이스(영어: database, DB)는 체계화된 데이터의 모임이다. 즉, 작성된 목록으로써 여러 응용 시스템들의 통합된 정보들을 저장하여 운영할 수 있는 공용 데이터들의 묶음이다. (출처: 위키백과)특정 조직의 업무처리를 위해 애플리케이션 시스템에서 사용되는 시스템을 데이터베이스라 한다. 데이터 모델링 데이터 사실을 나타내는 수치 양적 데이터와 질적 데이터로 구성 사실에 대한 정량적, 정성적 특징을 나타낼 수 있는 값과 값에 대한 설명인 메타데이터로 구성 예전에는 파일 시스템으로 데이터들을 관리 하였는데 파일 시스템은 처리 지향적인 방법으로 데이터가 컴퓨터 시스템의 물리적, 논리적 특성에 종속됨으로써 사용자의 요구에 유연하게 대처하지 못하는 문제점이 있다.데이터베이스는 사용자의 요구와 시스템의 특징에 맞게 데이터를 유연하게 관리, 운용하기 위하여 세 가지 모델링 단계를 거쳐 설계된다. 데이터 모델링이란 데이터 개체들을 정의하고, 데이터 개체들 사이의 의미를 정의하는 작업과정을 말한다. 데이터의 합리적인 해석을 얻을 수 있는 데이터에 관한 모델화 작업으로서, 데이터 모델은 숲(데이터의 정보내용)과 나무(데이터의 개개 값)의 대응관계를 이해하기 쉽게 구성하는 추상화 방법이다. 즉 데이터 모델은 현실세계에 존재하는 정보와 현상을 선과 도형등을 이용하여 전체 구조와 역할을 한눈에 알아볼 수 있도록 쉽게 표현한 것이다. 간단하게 표현하면 현실세계의 추상화라 할 수 있겠다. 데이터 모델링을 통해 완성된 뎅이터 모델은 크게 두 가지 목적으로 활용할 수 있다. 응용 프로그래머, 데이터베이스 설계자, 의뢰인 등과 의사소통을 위한 수단이 된다. 제대로 작성된 데이터 모델은 프로젝트의 수정 및 확장을 위한 대비책도 된다. 데이터 모델링은 프로젝트의 최종 목표를 위해 전체를 구상하고 그 범위 내에서 여러가지 개체와 속성을 정의하며 개체와 개체의 관계를 설정하고 예외상황을 대입하여 진행한다. 이때 일반화를 하는데 여러가지 제약조건이 필요하다면 개체 간의 관계에 제약조건을 설정하여 모델링을 완성한다. 모델링 단계데이터베이스 모델링 단계는 각각의 데이터 모델의 기능적 측면에서 작성하는 것을 원칙으로 한다. 사용자 요구사항 수정 및 분석사용자 요구사항 분석 단계에서 데이터베이스 설계자들은 실제 데이터베이스 사용자가 데이터베이스를 어떻게 이용할 것인가, 즉 목표를 수립하고 그 목표를 달성하기 위해 필요한 데이터베이스의 요구사항을 의뢰인과 데이터베이스 설계자가 동시에 만족할 수 있는 형태의 문서화가 진행되며 간결하게 작성된 사용자 요구사항 명세서가 만들어진다. 개념적 DB 모델링개념적 데이터베이스 모델링 단계에서는 사용자 요구사항에 대한 명세를 토대로 데이터베이스 접근을 위한 논리설계를 한다. 현실세계의 추상화를 통해 속성들로 기술된 개체 타입과 이 개체 타입의 관계를 나타내는 개념적 데이터 모델을 사용해서 데이터베이스에 대한 개념적 구조를 만든다. 데이터베이스의 대상이 되는 현실세계의 사물에 대해 논리적으로 체계화하는 설계가 필요하며 이 설계가 ER 모델을 아용한 설계이다. 논리적 DB 모델링논리적 데이터베이스 모델링 단계에서는 데이터베이스 설계를 위해 한 단계 더 구체적으로 접근한다.상용 DBMS를 사용하여 실제 데이터베이스를 구현하려면 개념적 구조의 논리표현을 목표 DBMS에 적합한 구현 모델로의 스키마로 변환하는 작업이 필요하다. 이 변환과정을 논리적 데이터베이스 모델링이라고 하며 이 단계를 논리적 데이터베이스 설계라고 한다. 물리적 DB 모델링물리적 데이터베이스 모델링은 데이터베이스 논리적 설계로부터 효율적이고 구현 가능한 물리적 데이터베이스 구조를 설계하는 것이다. 인덱스레코드가 물리적 디스크상의 어느 블록에 저장되어 있는지 위치정보르르 모아서 정렬한 구조체를 말한다. 인덱스는 데이터베이스에서 빠른 검색을 위해 사용되며 제약조건을 부여하여 유일성을 갖는 컬럼의 정의로도 사용된다.컬럼값의 특성, 속성값의 변경 주기, 검색방법에 따라 다양한 종류의 인덱스가 존재한다. 일반적으로 B-트리 계열이 숫자 및 문자 속성에 사용되며 해시(hash) 인덱스, 역키(inverse key) 인덱스 등이 있다. 효율적인 인덱스 구현을 위해서는 인덱스의 구조와 동작원리에 대한 메커니즘을 정확히 이해하는 것이 중요하다. 결국 데이터베이스 관리 시스템에서 지원되는 인덱스의 특성을 파악하여 목적에 맞게 구현하는 과정이 물리적 데이터베이스 모델링 단계에서 필요하다. 뷰기반 테이블에서 자주 사용되는 정보를 모아 별도의 개체로 정의한 가상 테이블(virtual table)을 의미한다. 사용자의 요구가 복잡한 질의를 자주 호칠한다면 이를 단순화하여 뷰로 정의할 경우, 데이터베이스의 복잡도를 줄일 수 있다. 뷰를 생성한 후에는 뷰를 그냥 테이블로 생각하고 접근하면 된다. 원래의 테이블에 접근한 것과 동일한 결과를 얻을 수 있다.","link":"/2018/11/04/2018-10-16-database-first/"},{"title":"css drawing 튜토리얼 - 호무새 그리기","text":"요즘 css drawing 에 맛들려 시간날 때마다 조금씩 css drawing을 작업하다가 튜토리얼을 간단하게 작성해보기로 했다. 위의 이미지는 호무새 방송시 구독 메시지와 같이 출력되는 이미지인데 튜토리얼용으로도 괜찮을것 같아서 캡쳐해왔다. css로 이 이미지를 한번 작업해보자. 먼저 어떻게 영역을 나눠볼지 정해보자. 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;호무새&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"./angry-heavy-rain.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"heavy-rain\"&gt; &lt;div class=\"heavy-rain-eyes left\"&gt;&lt;/div&gt; &lt;div class=\"heavy-rain-eyes right\"&gt;&lt;/div&gt; &lt;div class=\"heavy-rain-mouse-line\"&gt;&lt;/div&gt; &lt;div class=\"heavy-rain-mouse\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 얼굴안에 눈, 부리가 있으니 얼굴이 될 div안에 눈, 부리 영역을 div로 잡아 넣어주었다. 이제 css를 작성해보자. 얼굴1234567891011121314151617181920212223242526272829303132333435/* 얼굴 */.heavy-rain { position: relative; width: 380px; height: 380px; margin: 70px auto 0; border-radius: 50%; background-color: #54bc89;}/* 머리 위의 꽁지들 */.heavy-rain:before,.heavy-rain:after { content: \"\"; display: block; position: absolute; border-radius: 50% 50% 50% 50% / 40% 40% 60% 60%; background-color: #54bc89;}.heavy-rain:before { width: 50px; height: 90px; right: 100px; top: -50px; transform: rotate(20deg);}.heavy-rain:after { width: 50px; height: 70px; right: 65px; top: -10px; transform: rotate(45deg);} div 하나를 호무새 얼굴로 잡고 가상 선택자(before, after)로 호무새의 꽁지를 표현했다.가상 선택자는 존재하지 않는 요소를 존재하는 것처럼 부여하여 문서의 특정 부분 선택이 가능하다. 호무새 눈12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* 눈 */.heavy-rain-eyes { position: absolute; width: 50px; height: 50px; background-color: #ffffff; border-radius: 50%; border: 4px solid #000000; top: 120px;}.heavy-rain-eyes.left { left: 70px;}.heavy-rain-eyes.right { right: 150px;}.heavy-rain-eyes:before,.heavy-rain-eyes:after { content: \"\"; display: block; position: absolute;}/* 눈썹 */.heavy-rain-eyes:before { width: 35px; height: 3px; background-color: #000000; border-radius: 100px; top: -15px;}.heavy-rain-eyes.left:before { left: 10px; transform: rotate(20deg);}.heavy-rain-eyes.right:before { right: 10px; transform: rotate(-20deg);}/* 눈동자 */.heavy-rain-eyes:after { width: 10px; height: 10px; background-color: #ffffff; border-radius: 50%; box-shadow: 10px 10px 0px 13px #000000; top: 10px; left: 10px;} 역시 가상선택자로 눈알을 표현했다. before는 눈썹, after로는 그림자를 사용하여 눈동자를 나타내었다. 호무새 부리호무새 부리1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* 부리 테두리 */.heavy-rain-mouse-line { position: absolute; width: 0; height: 0; border: 30px solid transparent; border-right: 160px solid #0d4645; bottom: 151px; left: -52px; transform: rotate(-3deg); z-index: 6;}.heavy-rain-mouse-line:after { content: \"\"; position: absolute; width: 0; height: 0; border: 30px solid transparent; border-left: 30px solid #0d4645; bottom: -30px; left: 160px; z-index: 6;}/* 부리 */.heavy-rain-mouse { position: absolute; width: 0; height: 0; border: 25px solid transparent; border-right: 140px solid #105f59; left: -28px; transform: rotate(-3deg); top: 174px; z-index: 6;}.heavy-rain-mouse:before,.heavy-rain-mouse:after { content: \"\"; display: block; position: absolute;}.heavy-rain-mouse:after { width: 0; height: 0; border: 25px solid transparent; border-left: 25px solid #105f59; bottom: -25px; left: 140px; z-index: 6;}/* 호무새 부리 중앙선 */.heavy-rain-mouse:before { width: 161px; height: 0; border: 2px solid #0d4645; bottom: -2px; left: 0px; z-index: 7;}} 좀 낡은 방법이지만 css로 삼각형을 만들 땐 div의 border의 두께를 두껍게 준 후 원하는 방향을 제외한 다른 방향들을 다 투명하게 만드는 방법을 쓴다.원래는 비틀어진 마름모를 하나 만들어서 한번에 다 끝내고 싶었으나 지식이 짦아서 그냥 div와 가상선택자 after로 마름모를 만들었다. 마름모 두개를 만든 후 하나는 부리 테두리로 사용했다. 부리까지 만들고 나면 호무새 완성! 마무리완성작을 보니 뿌듯하긴 하지만 최대한 html 요소를 적게 쓰고 싶었는데 부리에 div를 두개나 쓴게 마음에 안든다. 더 좋은 방법이 있는지 찾아봐야겠다 ㅠ. 코드 전체 보기See the Pen angry heavy rain by partyKyoung (@partykyoung) on CodePen.","link":"/2018/10/24/2018-10-24-css-drawing-tutorial/"},{"title":"2018년 회고록","text":"시간이 참 빨리간다. 눈 몇번 깜빡하고 나니까 벌써 2018년이 지나갔다 ㅠ.2019년을 맞이하는 마음으로 2018년을 한번 돌아보자. 올해 잘한 일 방송통신대에 3학년으로 편입해서 1학기, 2학기를 보냈다.전문학사가 아쉬워서 학사를 따야지, 따야지 하다가 더 미루면 안될것 같아 눈 딱 감고 편입을 했다. 회사일과 학교공부를 동시에 하는게 좀 힘들었지만 그래도 후회는 없다. 도중에 포기하지않고 학사까지 무사히 따는 것이 목표이다. 혼자서 프론트 프로젝트 설정 부터 구현까지 해냈다.지금 다니고 있는 회사에서 올해 초에 같이 프론트를 담당하던 이사님이 빠지고 나서 혼자서 프론트 프로젝트를 다 책임져야 하는 상황에 쳐했었다. 맨처음엔 이걸 어떻게 나 혼자 관리하고 만들지 하며 걱정했었는데 에라 모르겠다 하고 달린 결과 나름 괜찮게 결과물이 나왔다. 내가 책임지다 보니 도중에 추가하고 싶은 모듈이나 설정을 맘껏 할 수 있는 장점이 있었다. 내년에는 테스트 환경을 도입하고 성능을 생각하며 리팩토링을 하는 것이 목표이다. 오픈소스 활동에 기여했다.회사에서 프로젝트를 하며 react-lazy-load-image-component 라는 컴포넌트를 쓰고 있었는데 className prop를 추가하지 않으면 class명에 undefined 들어가는게 은근 거슬렸다. 해당 오픈소스를 fork 한 후 propTypes, defaultProps만 추가한 후 풀리퀘를 날릴까 말까 고민하고 있었는데 오픈소스 제작자가 먼저 나에게 괜찮으면 이거 풀리퀘를 날려달라고 코멘트를 달아서 우여곡절 끝에 별거 아닌 내 코드가 소스에 반영되었다. 이 외에도 다른 오픈소스 readMe 파일에 오타가 있어서 풀리퀘를 날린적이 있는데 제작자가 잠수(?)를 타서 아직도 컨펌을 못받은것도 있다 ㅠ. 올해 못한 일 개인 공부를 제대로 하지 못했다.학교 공부 핑계로 공부해야할건 많은데 제대로 공부 하지 않앗다. 주말에도 짬이라도 내서 해야했는데 노느라 바빴던것 같다. 흑… 개인 프로젝트를 진행하지 못했다.올해 초에 프로젝트 설정만 잡아놓고 조금 끄적이다가 연말까지 계속 손을 놓고 있었다. 내년에는 꼭 프로젝트 진행을 하자. 기능 구현만 아니라 만든 프로젝트로 서비스 운영까지 해보는 것이 목표이다. 학교 공부를 벼락치기 식으로 진행했다.전 대학교를 다닐때 한번씩 배운 내용이라고 설렁설렁 공부했다가 학점이 영 만족스럽게 나오지 않았다. 2학기 때는 회사일이 너무 바쁘다는 핑계로 강의도 다 듣지 못하고 완전 벼락치기로 공부를 한 후 시험을 쳤다. 그 결과 수학 F… ㅇ&lt;-&lt; 독서를 멀리했다.올해는 제대로 읽은 책도 없다. 내년에는 서점, 책이랑 친해져야지 ㅠ… 내년 목표 개인 공부(특히 MobX, TypeScript) 하기 개인 공부한 것들로 토이 프로젝트 진행하기 학교 공부 복습 미루지 않기 한달에 한권씩 꼭 책을 읽기","link":"/2018/12/31/2018-12-31-2018-memoir/"},{"title":"TypeScript","text":"TypeScript Microsoft에서 개발한 오픈 소스 프로그래밍 언어. TypeScript는 JavaScript의 Superset이다. JavaScript의 모든 기능을 사용할 수 있고 그 위에 TypeScript만의 문법을 추가한 언어이다. TypeScript는 Compiled Language 이다. TypeScript 컴파일러가 TypeScript를 JavaScript로 컴파일 해준다. 때문에 Transpile이라는 용어를 사용하기도 한다. 정적 타입 언어 vs 동적 타입 언어정적 타입 언어 미리 타입을 지정해놓고 시작하는 언어 미리 타입을 지정해놓기 때문에 타입 에러로 인한 문제점을 초기에 발견할 수 있다. 동적 타입 언어 타입이 없는 언어 실행 도중에 변수에 예상치 못한 타입이 들어와 오류가 생길 수 있다. 코드 덩어리가 커지면 오류를 잡아내기도 어렵고 동시 다발적으로 문제 생기는 경우가 많은데 이 때문에 정적 타입을 채용한 것이 TypeScript. 테스트 코드를 많이 애용하면 정적 타입 언어가 필요 없으나 테스트 커버리지를 엄청 올리는 일이 가면 갈수록 힘들어진다. 미리 타입 체킹을 하며 오류를 막아 주는 것이 TypeScript 이다. TypeScript 5분 튜토리얼1npm install -g typescript TypeScript를 전역으로 설치해주자. helloTypeScript.ts12345function greeter(person: string) { return `Hello ${person}`;}greeter(\"typescript\"); TypeScript 공식 사이트에서 튜토리얼을 보고 간단하게 작성해 보았다. 1tsc helloTypeScript.ts tsc 명령어로 TypeScript를 컴파일 할 수 있다. ReferenceTypeScript 강좌(1) - Introduction타입스크립트 코리아 : 기초 세미나TypeScript in 5 minutes정적언어(타입)과 동적언어(타입)","link":"/2019/04/25/2019-01-14-typescript-first/"},{"title":"create-react-app으로 생성한 React 프로젝트 TypeScript로 마이그레이션 하기","text":"TypeScript에 익숙해질 겸 기존에 진행하고 있던 프로젝트를 TypeScript으로 마이그레이션 해보기로 했다.create-react-app v2로 생성한 프로젝트면 간단하게 마이그레이션 할 수 있다. 12yarn add @types/node @types/react @types/react-domyarn add --dev typescript awesome-typescript-loader source-map-loader @types/jest 먼저 위의 모듈들을 install 해주자. App.tsx1234567891011121314import * as React from \"react\";interface Props {}interface State {}export default class App extends React.Component&lt;Props, State&gt; { constructor(props: Props) { super(props); } render(): JSX.Element { return &lt;div&gt;TypeScript&lt;/div&gt;; }} 위의 App 컴포넌트 처럼 컴포넌트 파일들의 확장자를 tsx로 바꾸고 Props, State 타입을 지정해주면 된다.마지막으로 index.js 파일을 index.tsx로 바꾸면 마이그레이션이 간단하게 끝난다. 여기까지는 React 공식문서를 따라 해서 문제가 없었는데 나는 yarn eject로 프로젝트 의존성을 풀어놔서 문제가 잠시 생겼었다.컴포넌트 import시 컴포넌트 경로를 적을 때 tsx 확장자를 적지 않으면 컴포넌트를 제대로 불러오지 못하는 것이었다. 빨간줄이 거슬려서 해결법을 찾아보았다. paths.js12345678910111213const moduleFileExtensions = [ 'web.mjs', 'mjs', 'web.js', 'js', 'web.ts', 'ts', 'web.tsx', 'tsx', 'json', 'web.jsx', 'jsx',]; paths.js 파일을 확인해보면 분명 확장자에 ts, tsx가 있는데 제대로 확장자를 빼면 컴포넌트를 제대로 불러오지 않는것이 이상해서 webpack 설정을 보았다. webpack.config.js1234567resolve: { /* 생략 */ extensions: paths.moduleFileExtensions.map(ext =&gt; `.${ext}`), // .filter(ext =&gt; useTypeScript || !ext.includes(\"ts\")), /* 생략 */ resolve 옵션은 webpack이 알아서 경로나 확장자를 처리할 수 있게 도와준다. extensions에 넣은 확장자들은 웹팩에서 알아서 처리해주기 때문에 파일 경로를 입력할 때 확장자를 적을 필요가 없어진다.확인 해보니 Array.filter 메소드로 TypeScript 파일들을 다 걸러내고 있길래 해당 부분을 주석처리 해주었더니 정상 작동 되었다. 진작 webpack 설정을 봤었어야 했는데 삽질을 좀 많이 했다. 흑흑… 그래도 무사히 마이그레이션 성공! ReferenceAdding TypeScript","link":"/2019/01/22/2019-01-20-typescript-react/"},{"title":"이벤트 핸들링","text":"이벤트유저가 웹 브라우저에서 DOM 요소들과 상호 작용하는 것을 이벤트(event)라고 한다. javascript1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;이벤트&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;div id=\"number\"&gt;1&lt;/div&gt; &lt;button type=\"button\" onclick='changeNumber()'&gt;클릭&lt;/button&gt; &lt;script&gt; function changeNumber() { const div = document.getElementById('number'); let number = parseInt(div.innerText); number += 1; div.innerHTML = number; } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; See the Pen javascript event by partyKyoung (@partykyoung) on CodePen. reactReact의 이벤트 시스템은 웹 브라우저의 HTML 이벤트와 인터페이스가 동일하기 때문에 사용법이 꽤 비슷하다. 12345678910111213141516171819202122232425262728293031323334import React, { Component } from \"react\";export default class MyComponent extends Component { constructor(props) { super(props); // state 초기값 설정 this.state = { number: 0 }; } handleUpdate = () =&gt; { const { number } = this.state; // state 업데이트 this.setState({ number: number + 1 }); }; render() { const { number } = this.state; return ( &lt;div&gt; {`Number: ${number}`} &lt;button type=\"button\" onClick={this.handleUpdate}&gt; 업데이트 &lt;/button&gt; &lt;/div&gt; ); }} See the Pen react state by partyKyoung (@partykyoung) on CodePen. 이벤트 사용시 주의 사항 이벤틑 이름은 camelCase로 작성하기onclick이나 onchagne등의 이벤트 이름을 React에서는 onClick, onChagne … 이런 식으로 작성해야 한다. 이벤트에 함수 형태의 객체를 전달하기HTML에서는 이벤트를 설정할 때 큰 따옴표 안에 실행할 코드를 넣지만 리액트에서는 함수 형태의 객체를 전달한다. 화살표 함수로 바로 전달해도 되고 렌더링 부분 외부에 함수를 작성해서 전달해도 된다. DOM 요소에만 이벤트 설정 가능DOM 요소에는 이벤트를 설정할 수 있지만 직접 만든 컴포넌트에는 이벤트를 설정시 props로 전달되기 때문에 자체적으로 이벤트를 사용할 순 없다. 대신 전달받은 props를 컴포넌트 내부의 DOM에서 이벤트로 설정 가능하다. 이벤트 바인딩JavaScript 에서 함수를 선언하면 함수는 자기 자신을 가리키는 this 를 생성하며, 함수 호출 시, this 는 전역 객체를 바인딩 하게 된다. 12345678910111213141516export default class MyComponent extends Component { state = { number: 0 }; handleUpdate() { const { number } = this.state; // state 업데이트 this.setState({ number: number + 1 }); } // ... 생략} 리액트도 JavaScript이기 때문에 위의 코드 처럼 컴포넌트에 임의 메서드를 만들면 기본적으로 this에 접근할 수 없다. 1234567891011121314151617181920export default class MyComponent extends Component { // ... 생략 constructor() { super(); this.handleUpdate = this.handleUpdate.bind(this); } handleUpdate() { const { number } = this.state; // state 업데이트 this.setState({ number: number + 1 }); } // ... 생략} 컴포넌트의 생성자 메서드인 constructor에서 각 메서드를 this와 바인딩 해주어야 한다. 메서드에서 this를 사용할 수 있도록 메서드에 this를 묶어주는 것이다. 12345678910111213141516export default class MyComponent extends Component { state = { number: 0 }; handleUpdate = () =&gt; { const { number } = this.state; // state 업데이트 this.setState({ number: number + 1 }); }; // ... 생략} 바벨의 transform-class-properties 문법을 사용하여 화살표 함수 형태로 메서드를 정의할 수 있다.화살표 함수는 함수를 둘러싸고 있는 영역의 this를 함수 내부에서 this로 그대로 사용한다. typescript12345678910111213141516171819202122232425262728293031323334import React, { Component } from \"react\";interface Props {}interface State { number: number;}export default class MyComponent extends Component&lt;Props, State&gt; { state = { number: 0 }; handleUpdate: any = () =&gt; { const { number } = this.state; // state 업데이트 this.setState({ number: number + 1 }); }; render(): JSX.Element { const { number } = this.state; return ( &lt;div&gt; {`Number: ${number}`} &lt;button type=\"button\" onClick={this.handleUpdate}&gt; 업데이트 &lt;/button&gt; &lt;/div&gt; ); }} Reference리액트를 다루는 기술react 컴포넌트에서 constructor 내부에 이벤트 함수를 바인딩 해줘야 하는 이유컴포넌트 이벤트 연결(바인딩)","link":"/2019/02/09/2019-01-30-reactjs-event/"},{"title":"state","text":"stateComponent 내부에서 읽고 업데이트도 가능한 값을 사용하려면 state를 써야 한다. state는 기본 값이 미리 설정되어 있어야 하고 this.setState 메소드로 값을 업데이트 할 수 있다. 12345678910111213141516171819202122232425262728293031323334import React, { Component } from \"react\";export default class MyComponent extends Component { constructor(props) { super(props); // state 초기값 설정 this.state = { number: 0 }; } handleUpdate = () =&gt; { const { number } = this.state; // state 업데이트 this.setState({ number: number + 1 }); }; render() { const { number } = this.state; return ( &lt;div&gt; {`Number: ${number}`} &lt;button type=\"button\" onClick={this.handleUpdate}&gt; 업데이트 &lt;/button&gt; &lt;/div&gt; ); }} See the Pen react state by partyKyoung (@partykyoung) on CodePen. constructorconstructor는 클래스 인스턴스를 생성하고 클래스 프로퍼티를 초기화를 해주는 특수한 메소드이다. state의 초기값도 constructor에서 지정한다. constructor는 부모 클래스의 constructor를 호출하기 위해 super 키워드를 사용할 수 있다. constructor을 만들면 super 키워드를 필수로 사용해야 한다. super 키워드에 props를 인자로 넘겨줘야 constructor 안에서 this.props에 접근할 수 있다.만약 constructor 안이 아닌 다른 곳에서 this.props에 접근하고 싶으면 super 키워드에 props를 인자로 넘겨줄 필요가 없다. setStatestate 값을 업데이트 할 때는 this.setState 메서드를 사용한다. state값을 업데이트 할 때는 무조건 setState로만 업데이트를 해야한다. setState 메서드는 인자로 전달받은 state 필드를 업데이트 한 후 컴포넌트가 리렌더링하도록 트리거 하는 것 이다. 만약 직접 state에 접근하여(this.state.number = 1) 값을 수정하면 컴포넌트는 리렌더링 되지 않는다. this.forceUpdate 메소드로 강제 리렌더링을 시킬 수 있지만 이 방식은 매우 비효율적이므로 웬만하면 사용을 피해야 한다. transform-class-properties1234567891011121314151617181920212223242526272829import React, { Component } from \"react\";export default class MyComponent extends Component { state = { number: 0 }; handleUpdate = () =&gt; { const { number } = this.state; // state 업데이트 this.setState({ number: number + 1 }); }; render() { const { number } = this.state; return ( &lt;div&gt; {`Number: ${number}`} &lt;button type=\"button\" onClick={this.handleUpdate}&gt; 업데이트 &lt;/button&gt; &lt;/div&gt; ); }} transform-class-properties 문법으로 constructor 바깥에서 state를 정의할 수도 있다. typescripttypescript를 사용하면 state에도 타입을 지정해줄 수 있다. 12345678910111213141516171819202122232425262728293031323334import React, { Component } from \"react\";interface Props {}interface State { number: number;}export default class MyComponent extends Component&lt;Props, State&gt; { state = { number: 0 }; handleUpdate: any = () =&gt; { const { number } = this.state; // state 업데이트 this.setState({ number: number + 1 }); }; render(): JSX.Element { const { number } = this.state; return ( &lt;div&gt; {`Number: ${number}`} &lt;button type=\"button\" onClick={this.handleUpdate}&gt; 업데이트 &lt;/button&gt; &lt;/div&gt; ); }} 타입스크립트를 공부하고 있어서 타입스크립로 함수를 작성해봤다. render 함수는 JSX 객체를 리턴하기 때문에 리턴 타입에 JSX.Element를 적어주었고 나머지 이벤트 함수는 state 값만 바꿀 뿐 리턴 값이 없어서 리턴 타입으로 any를 적어 주었다. Reference리액트를 다루는 기술React ES6 — Class constructor에서의 super()","link":"/2019/01/27/2019-01-27-reactjs-state/"},{"title":"ref","text":"일반 HTML에서 DOM 요소에 이름을 달고 접근할 때 id를 사용한다. 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;DOM ID&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"./angry-heavy-rain.css\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"me\"&gt;DOM ID&lt;/div&gt; &lt;button type=\"button\" onclick=\"clickDOM()\"&gt;클릭&lt;/button&gt; &lt;/body&gt; &lt;script&gt; function clickDOM() { const me = document.getElementById('me'); me.style.backgroundColor = \"red\"; } &lt;/script&gt;&lt;/html&gt; See the Pen DOM Id by partyKyoung (@partykyoung) on CodePen. refHTML에서 id를 사용하여 DOM에 이름을 다는 것 처럼 리액트에서는 ref를 사용하여 DOM에 이름을 달 수 있다. 리액트에서도 id를 사용할 수 있지만 특수한 경우가 아니면 사용을 권장하지 않는다. DOM의 id는 유일해야 하는데 컴포넌트를 여러번 사용하면 중복 id를 가진 DOM이 여러개 생기게 되는 경우가 있기 때문이다. 이런 상황에서는 컴포넌트를 만들 때 마다 중복 id가 발생하는 것을 방지해야 한다. ref는 전역적으로 작동하지 않고 컴포넌트 내부에서만 작동하기 때문에 이런 문제가 생기지 않는다. ref를 사용해야 할 때ref는 state나 props로 해결할 수 없고 DOM을 꼭 직접적으로 건드려야 할 때 사용한다. 특정 input에 포커스 주기 스크롤 박스 조작하기 Canvas 요소에 그림 그리기 등 ref 사용법ref를 달아야 하는 DOM에 props를 설정하듯이 ref를 설정햐면 된다. ref 값으로는 콜백 함수를 전달한다. 콜백 함수는 ref를 파라미터로 가지며 콜백 함수 내부에서 컴포넌트의 맴버 변수에 ref를 담는 코드를 작성한다.ref 이름은 자유롭게 지정할 수 있다. 123456789101112131415161718192021222324252627282930import React, { Component } from \"react\";export default class Ref extends Component { constructor() { super(); this.input = null; } handleFocus = () =&gt; { this.input.focus(); }; render() { return ( &lt;div&gt; &lt;input type=\"text\" ref={input =&gt; { // this.input은 input 요소의 DOM을 가리킨다. this.input = input; }} /&gt; &lt;button type=\"button\" onClick={this.handleFocus}&gt; 클릭 &lt;/button&gt; &lt;/div&gt; ); }} See the Pen react ref by partyKyoung (@partykyoung) on CodePen. 컴포넌트에 Ref 달기리액트에서는 컴포넌트에도 ref를 달 수 있다. 이 방법은 주로 컴포넌트 내부에 있는 DOM을 컴포넌트 외부에서 사용할 때 쓴다. 컴포넌트에 ref를 다는 방법은 DOM에 ref를 다는 방법과 똑같다. ChildRef.js1234567891011121314151617181920212223242526272829303132333435363738394041import React, { Component } from \"react\";export default class ChildRef extends Component { constructor() { super(); this.box = null; } handleScroll = () =&gt; { const { scrollHeight, clientHeight } = this.box; this.box.scrollTop = scrollHeight - clientHeight; }; render() { const style = { border: \"1px solid #000000\", height: \"300px\", width: \"300px\", overflow: \"scroll\" }; const innerStyle = { height: \"600px\", width: \"100%\", background: \"linear-gradient(white, black)\" }; return ( &lt;div style={style} ref={ref =&gt; { this.box = ref; }} &gt; &lt;div style={innerStyle} /&gt; &lt;/div&gt; ); }} ParentRef.js123456789101112131415161718192021222324252627282930313233343536import React, { Component } from \"react\";import ChildRef from \"./ChildRef\";export default class ParentRef extends Component { constructor() { super(); this.scroll = null; } handleClick = () =&gt; { /* 컴포넌트가 처음 랜더링 될 때는 this.scroll 값이 undefined 이므로 메서드를 호출 할 때 오류가 발생한다. 화살표 함수 문법을 사용하여 아예 새로운 함수를 만들고 그 내부에서 메서드를 실행하면 이미 한번 랜더링한 시점이므로 메서드 값을 읽어와서 실행하기 때문에 오류가 발생하지 않는다. */ this.scroll.handleScroll(); }; render() { return ( &lt;div&gt; &lt;ChildRef ref={ref =&gt; { this.scroll = ref; }} /&gt; &lt;button type=\"button\" onClick={this.handleClick}&gt; 맨 밑으로 &lt;/button&gt; &lt;/div&gt; ); }} See the Pen react component ref by partyKyoung (@partykyoung) on CodePen. 마무리컴포넌트 내부에서 DOM에 직접 접근해야 할 때는 ref를 사용한다. 먼저 ref를 사용하지 않고도 원하는 기능을 구현할 수 있는지 꼭 고려한 후 사용해야 한다. 서로 다른 컴포넌트끼리 데이터를 교류할 때 ref를 사용하는 것을 잘못된 방법이다. 할 수는 있지만 리액트 사상에 어긋난 설계이다. 앱 규모가 커지면 구조가 꼬여버려 유지보수가 불가능하기 때문이다. 컴포넌트끼리 데이터를 교류할 때는 언제나 부모 자식 흐름으로 교류해야 한다. Reference리액트를 다루는 기술Refs and the DOM","link":"/2019/02/17/2019-02-16-reactjs-ref/"},{"title":"알고리즘","text":"알고리즘의 개념알고리즘(algorithm)은 문제 해결을 위한 레시피(조리법)라고 할 수 있다. 알고리즘은 주어진 문제를 해결하기 위한 일련의 처리 과정을 단계적으로 나열한 것이다. 알고리즘의 단게적인 절차를 따르면 주어진 문제의 해를 구할 수 있다. 알고리즘의 정의 입출력0개 이상의 외부 입력과 하나 이상의 출력이 있어야 한다. 명확성각 명령은 모호하지 않고 단순 명확해야 한다. 유한성한정된 수의 단계를 거친 후에는 반드시 종료해야 한다. 유효성모든 명령은 컴퓨터에서 수행 가능해야 한다. 알고리즘은 “주어진 문제에 대한 결과를 생성하기 위해 모호하지 않고 간단하며 컴퓨터가 수행 가능한 유한개의 일련의 명령들을 순서적으로 구성한 것” 이다. 알고리즘이 존재하는 문제일지라도 컴퓨터를 이용해서 해결하는데 현실적으로는 처리 결과를 기다릴 수 없을 정도의 상당히 긴 처리 시간을 구하는 문제도 있다. 즉 이론적으로는 알고리즘이 존재해서 ㅎ해결이 가능하지만 효율적으로 풀 수 없는 문제도 있다. 따라서 실용적인 관점에서 보면 알고리즘이 효율적이어야 한다는 것도 충분히 고려되고 만족되어야 할 중요한 조건임에 틀림없다. 알고리즘의 생성알고리즘으르 생성하려면 일련의 과정을 거쳐야 한다. 설계주어진 문제의 입출력 조건과 처리 조건 등을 분석해서 알고리즘을 설계한다. 상향식 설계 하향식 설계 표현 / 기술설게가 완료된 알고리즘은 적절한 방법으로 표현한다. 일상 언어 순서도 의사코드 프로그래밍 언어… 정확성 검증알고리즘은 정확하고 효율적이어야만 실제 문제 해결에 안정적으로 사용될 수 있기 때문에 설계된 알고리즘의 정확성을 검증하고, 알고리즘이 얼마나 효율적인가를 분석하는 과정을 반드시 거친다. 수학적 검증 효율성 분석 공간 복잡도 시간 복잡도 Reference방송대 컴퓨터과학과 알고리즘 1강","link":"/2019/03/11/2019-03-02-algorithms-first/"},{"title":"Component 반복","text":"arr.map(callback(currentValue[, index[, array]])[, thisArg])JavaScript 배열 객체의 내장 함수 중 하나이다. 배열 내의 모든 요소 각각에 대하여 주어진 함수를 호출한 결과를 모아 새로운 배열을 반환한다. 원본 배열은 건드리지 않고 그 값들만을 사용해서 혹은 약간 변형해서 새로운 배열을 만들어야 할 때 유용하다. callback: 새로운 배열의 요소를 생성하는 콜백 함수. currentValue: 현재 처리하고 있는 요소 index: 현재 처리하고 있는 요소의 index 값 array: 현재 처리하고 있는 배열의 원본 ; Component maparray.map 메소드를 사용하여 기존 배열을 사용하여 컴포넌트로 구성된 배열을 생성할 수 있다. 1234567891011121314151617181920import React, { Component } from \"react\";export default class Map extends Component { constructor() { super(); this.fruitsList = [\"사과\", \"바나나\", \"오렌지\", \"체리\"]; } render() { return ( &lt;ul&gt; {this.fruitsList.map(fruits =&gt; { // DOM을 사용해도 되고 컴포넌트를 사용해도 된다. return &lt;li&gt;{fruits}&lt;/li&gt;; })} &lt;/ul&gt; ); }} See the Pen oVvvga by partyKyoung (@partykyoung) on CodePen. key리액트에서 key는 컴포넌트 배열을 렌더링 했을 때 어떤 원소에 변동이 있었는지 알아내려고 사용한다. key가 없으면 가상 DOM을 비교하는 과정에서 리스트를 순차적으로 비교하면서 변화를 감지하지만 key가 있으면 key 값을 사용하여 리스트에 어던 변화가 일어났는지 더욱 빠르게 알 수 있다. ; key 값을 설정할 때는 mpa 함수의 인자로 전달되는 함수 내부에서 컴포넌트 props를 설정하듯이 설정하면 된다. key 값은 언제나 유일해야 한다. key값이 중복된다면 렌더링 과정에서 오류가 발생한다. 12345678910111213// ... 생략 render() { return ( &lt;ul&gt; {this.fruitsList.map((fruits, index) =&gt; { return &lt;li key={index}&gt;{fruits}&lt;/li&gt;; })} &lt;/ul&gt; ); }// ... 생략 데이터가 가진 고윳값이 없으면 콜백함수의 인수인 index를 사용해도 괜찮으나 리액트 공식문서에서는 성능에 부정적인 영향을 줄 수 있으며 컴포넌트의 상태이슈를 유발하기 때문에 index를 key 값으로 쓰는것을 추천하지 않는다. 만약 key값을 명시하지 않은 경우에 리액트는 index값을 기본 값으로 할당하게 된다고 한다. state 활용state를 활용하면 유동적인 데이터를 렌더링 할 수 있다. 상태 안에서 배열을 변형할 때 배열을 직접 접근하여 수정하면 자동으로 리렌더링을 트리거 하지 않는다. 다라서 concat, slice 같이 새로운 배열을 반환하는 함수들을 사용하여 새로운 배열을 만든 후 setState 메서드로 적용해야 한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import React, { Component } from \"react\";interface Props {}interface State { fruitsList: string[]; value: string;}export default class MapState extends Component&lt;Props, State&gt; { constructor(props: Props) { super(props); this.state = { fruitsList: [], value: \"\" }; } handleChange = (e: any): void =&gt; { this.setState({ value: e.target.value }); }; handleInsert = (e: any): void =&gt; { const { fruitsList, value } = this.state; if (e.keyCode !== 13) { return; } this.setState({ fruitsList: fruitsList.concat(value), value: \"\" }); }; handleDelete = (index: number): void =&gt; { const { fruitsList } = this.state; this.setState({ fruitsList: [ ...fruitsList.slice(0, index), ...fruitsList.slice(index + 1, fruitsList.length) ] }); }; render() { const { fruitsList, value } = this.state; return ( &lt;div&gt; &lt;ul&gt; {fruitsList.map((fruits, index) =&gt; { return ( &lt;li key={index} onClick={() =&gt; { this.handleDelete(index); }} &gt; {fruits} &lt;/li&gt; ); })} &lt;/ul&gt; &lt;input type=\"text\" value={value} onChange={this.handleChange} onKeyDown={this.handleInsert} /&gt; &lt;/div&gt; ); }} See the Pen react typescript map by partyKyoung (@partykyoung) on CodePen. Reference리액트를 다루는 기술Lists and KeysIndex as a key is an anti-pattern","link":"/2019/02/25/2019-02-24-reactjs-map/"},{"title":"운영체제의 구성","text":"운영체제의 구성운영체제를 구성하는 요소는 다양하지만 컴퓨터 시스템의 자원의 성격에 따라 구분한다. 크게 프로세스 관리자, 메모리 관리자, 장치 관리자, 파일 관리자로 나눌 수 있다. 프로세스 관리자프로세스들을 생성하고 삭제하며 CPU에 할당하기 위한 스케줄을 결정한다. 프로세스: 실행 중인 프로그램 또는 작업. 컴퓨터의 핵심적인 부분: CPU, 메모리 CPU로 명령어 처리, 명령어는 메모리에 저장되어 있음. 실행 중인 프로그램은 메모리 상에 프로세스로 존재. 동작을 하려면 CPU를 이용하여 명령어를 처리해야 함. 프로세스의 상태(준비, 실행, 대기 등)를 관리하며 상태 전이를 처리한다. 메모리 관리자메모리(주기억장치) 공간에 대한 각각의 요규가 유효한지 체크하고 적법한 요구라면 메모리 관리자가 주기억장치에서 아직 사용 중이지 않은 부분을 할당한다. 메모리 할당 및 회수 메모리 공간 보호 운영체제가 점유하고 있는 주기억장치의 공간을 지킴 장치 관리자컴퓨터 시스템의 모든 장치를 관리한다. ex) 비디오 디스플레이, 키보드, 프린터, 디스크 드라이브, 네트워크 장치 등 시스템의 장치를 할당하고 작동을 시작하며 마지막으로 장치를 반환한다. 파일 관리자컴퓨터 시스템의 모든 파일을 관리한다. 파일의 접근 제한을 관리. 파일을 열어 자원을 할당하거나 파일을 닫아 자원을 회수하는 일 등을 수행한다. Reference방송대 컴퓨터과학과 운영체제 1강","link":"/2019/03/16/2019-03-05-operating-systems-configuration/"},{"title":"운영체제","text":"운영체제컴퓨터의 하드웨어 자원을 관리하고 컴퓨터 프로그램이 동작하기 위한 서비스를 제공하는 시스템 소프트웨어.ex) 윈도우, 맥 OS, 리눅스 등.. 운영체제의 역할컴퓨터 시스템의 운영 컴퓨터 시스템의 자원을 제어 및 관리 하여 컴퓨터 시스템을 효율적으로 운영하는 역할. 자원이란 컴퓨터 시스템을 구성하고 있는 하드웨어 혹은 소프트웨어. 하드웨어 자원: CPU, 메모리, 키보드, 마우스, 네트워크 카드 등… 소프트웨어 자원: 각종 프로그램 데이터 등… 사용자 지원 사용자의 명령을 해석하여 실행. 사용자와 하드웨어 사이의 매개체 역할 수행. 컴퓨터 시스템과 운영체제운영체제가 없던 초기 컴퓨터 시스템에서는… 사용자가 응용 프로그램을 수행시키면 응용 프로그램이 직접 컴퓨터 시스템의 자원을 제어해야만 했다. 응용 프로그램에서 하드웨어를 다룰 수 있는 기능들을 모두 가지고 있었고 이때믄에 응용 프로그램 개발자는 하드웨어에 대한 방법을 잘 알아야 했다. 하나의 하드웨어를 여러 사용자가 공유해서 사용하는 경우 응용 프로그램들 끼리 효울적인 자원 분할이 어려웠다. 이런 문제점을 극복하기 위해 하드웨어와 응용 프로그램 사이에 운영체제를 두고 하드웨어에 대한 제어는 운영체제만 하도록 했다. 응용 프로그램은 하드웨어에 대한 자세한 정보를 모르더라도 운영체제에 부탁만 하면 운영체제가 대신 하드웨어를 제어하고 그 결과를 응용 프로그램에 제공해 주게 되었다. 여러 응용 프로그램이 동시에 수행되더라도 운영체제가 중간에서 충돌 없이 자원을 효율적으로 나눠 줌으로써 컴퓨터 시스템이 안정적으로 동작할 수 있게 되었다. 이러한 형태로 운영체제가 동작하려면 응용프로그램이 직접 하드웨어에 접근하는 것을 강제로 막을 필요가 있다. 응용 프로그램이 하드웨어를 직접 제어할 수 있는 방법이 여전히 존재한다면 시스템의 안정성을 보장할 수 없기 때문이다. 슈퍼바이저 모드(커널 모드) 운영체제의 커널이 동작되는 모드. 하드웨어를 직접 제어할 수 있는 CPU 명령어 사용 가능. 보호 모드(사용자 모드) 응용 프로그램이 동작되는 모드. 하드웨어를 직접 제어할 수 있는 CPU 명령어 사용 불가능 보호 모드에서 동작하는 응용 프로그램이 하드웨어에 대한 제어가 필욯한 경우에는 운영체제에 부탁을 해야만 하고, 그 경우 보호 모드에서 슈퍼바이저 모드로 변경이 되고 운영체제의 커널이 동작하여 하드웨어를 제어하게 된다.이 때 응용 프로그램이 운영체제에 서비스를 요청하는 메커니즘을 시스템 호출이라고 한다. 보호 모드 사용 시 하드웨어 접근이 필요한 경우…==&gt; 보호 모드 사용 중 -&gt; 시스템 호출 -&gt; 보호 모드에서 슈퍼바이저 모드로 변경 -&gt; 커널 동작 -&gt; 하드웨어 제어 -&gt; 응용 프로그램에게 결과를 돌려줌 -&gt; 보호 모드로 돌아옴 커널 운영체제의 핵심 요소. 응용 프로그램과 하드웨어 수준의 처리 사이의 가교 역할을 함. 일체형 커널 운영체제의 모든 서비스가 커널 내에 포함되어 있다. 커널 내부 요소들이 서로 효율적으로 상호작용을 할 수 있다. 모든 요소가 커널 내부에 존재하기 떄문에 하나의 요소에서라도 오류가 발생하면 시스템 전체에 장애를 일으킬 수 있다. UNIX, Linux. 마이크로 커널 운영체제의 대부분의 요소들을 커널 외부로 분리. 커널 내부에는 메모리 관리, 멀티태스킹, 프로세스 간 통신(IPC) 등의 최소한의 요소들만 남겨놓음. 새로운 서비스를 추가하여 운영체제를 확장하기 쉬움. 커널 외부의 요소에 문제가 발생하더라도 커널 자체에는 영향이 없기 때문에 유지보수가 용이하여 안정성이 우수함. 커널 외부 요소들 사이에 데이터 전달이 필요한 경우에는 프로세스 간 통신(IPC)을 통해야만 하기 떄문에 성능 저하가 발생한다. Reference방송대 컴퓨터과학과 운영체제 1강","link":"/2019/03/16/2019-03-04-operating-systems-first/"},{"title":"운영체제의 유형","text":"운영체제의 유형운영체제는 응답시간의 속도와 데이터 입력의 방식에 따라 일괄처리, 대화형, 실시간, 하이브리드 운영체제의 네 가지 유형으로 분류된다. 일괄처리(batch processing) 운영체제 초창기 컴퓨터에서 사용되었던 유형으로 작업을 모아서 처리하는 방식. 사용자와 상호작용 없이 순차적으로 실행한다. OMR카드, OCR카드를 입력장치로 이용. 효율성 평가는 처리량과 반환시간으로 함. 처리량: 주어진 전체 시간 안에 처리된 작업의 수 반환시간: 작업의 생성 시점부터 종료 시점 까지의 소요 시간 대화형(interactive) 운영체제 시분할 운영체제라고도 함. 시간 단위로 잘라서 다양한 요청들을 차례 차례 돌아가며 처리할 수 있도록 함. 이용자에게 즉각적인 피드백을 제공하고 응답시간은 사용 중인 이용자의 수에 따라 수 분 또는 수초 안에 처리됨. 일괄처리 운영체제 보다 빠르지만 실시간 운영체제보다는 느린 응답시간. 응답시간: 요청한 시점부터 반응이 시작되는 시점까지의 소요시간. 실시간 운영체제 모든 운영체제 중 응답시간이 가장 빠름. 처리의 결과가 현재의 결정에 영향을 주기 때문에 데이터의 처리가 극도로 빨라야 하는 환경에서 사용된다. ex) 우주선 비행 시스템, 미사일 제어, 증권거래 관리 시스템, 은행 입출금 시스템 등… 하이브리드 운영체제 일괄처리 운영체제와 대화형 운영체제의 결합. 각 이용자가 터미널을 통해 접속하고 빠른 응답시간을 얻을 수 있기 때문에 대화형 운영체제. 대화형 작업량이 많지 않을 경우 운영체제는 실제로 백그라운드에서 배치 프로그램을 받아들이고 실행한다. 현재 사용되고 있는 대부분의 대형 컴퓨터 시스템은 하이브리드 운영체제.","link":"/2019/03/16/2019-03-05-operating-systems-types/"},{"title":"프로세스 제어 블록","text":"프로세스 제어 블록(PCB)프로세스를 관리하기 위해 운영체제는 각 프로세스마다 프로세스 제어블록(PCB)을 두고서 여기에 해당 프로세스의 정보를 보관한다. 프로세스가 진행함에 따라 PCB의 내용은 변경된다.프로세스가 종료되면 해당 프로세스 제어 블록도 없어지게 된다. 프로세스 상태프로세스의 현재 상태를 나타낸다. 프로세스 번호(PID)프로세스의 기준이 되는 ID를 나타낸다. 프로그램 카운터(PC)프로세스 수행을 위한 다음 명령의 주소를 표시한다. 레지스터(register)CPU의 레지스터에 해당하는 정보들을 포함한다.실행상테에서 다른 상태로 전이될 때 CPU의 레지스터 정보를 이곳에 저장시켜서 나중에 다시 실행상태로 전이될 때 복구시켜 프로세스의 정확한 수행을 계속할 수 있도록 한다. 메모리프로세스가 저장된 주소와 가상 메모리를 사용하는 경우에는 가상주소와 실제 주소의 사상정보, 기준 레지스터와 경계 레지스터 등의 정보를 포함한다. 프로세스 우선순위우선순위를 이용하여 스케줄링 시 어떤 작업을 선택 할 것인가를 결정하는데 필요한 정보를 포함한다. 회계 정보주로 성능 측정과 순위에 대한 목적을 위한 정보로서, CPU 사용 시간, 프로세스의 시스템 존재 시간, 메모리 사용량, 보조기억장치 사용량, 기타 시스템 프로그램의 사용 실태 등 다양한 정보를 포함하고 있다. Reference방송대 컴퓨터과학과 운영체제 2강","link":"/2019/03/17/2019-03-06-operating-systems-pcb/"},{"title":"프로세스의 생성과 종료","text":"프로세스 생성운영체제가 새로은 프로세스를 생성하고 실행하려면 프로세스 관리를 위한 프로세스 제어 블록을 만든 후에 프로세스에 주소 공간을 할당해야 한다. 새로운 프로세스에 프로세스 식별자 할당. 프로세스의 모든 구성 요소를 포함할 수 있는 주소 공간과 프로세스 제어 블록 공간 할당. 프로세스 제어 블록 초기화. 준비 큐에 삽입. 일반적으로 프로세스는 작업을 수행하기 위해 자원이 필요하다. 한 프로세스가 자식 프로세스를 생성하면 생성된 자식 프로세스는 운영체제로 부터 직접 자원을 얻거나 부모 프로세스 자원의 일부를 얻는다. 하나의 프로세스가 프로세스 생성 시스템 호출을 통해 새로운 프로세스를 생성할 수 있다. ex) fork() 호출하는 프로세스: 부모 프로세스 생성되는 프로세스: 자식 프로세스 시스템 프로세스와 사용자 프로세스 모두 자식 프로세스를 생성할 수 있다. 즉 부모 프로세스가 될 수 있다. 부모 프로세스는 자식 프로세스에게 자원을 나눠주거나 공유할 수 잇도록 한다. 보통 자식 프로세스의 자원은 부모 프로세스의 자원으로 제한하는데 과도한 자식 프로세스 생성에 따른 시스템 과부하 방지를 위해서이다. 프로세스 종료프로세스의 마지막 명령이 실행을 마치는 경우 또는 프로세스 종료 시스템 호출을 통하는 경우(ex: exit()) 프로세스는 종료된다. 프로세스 종료 후 부모 프로세스에게 실행 결과를 되돌려 준다. 프로세스 종료 시스템 호출은 부모 프로세스에 의해서만 호출 된다. 부모 프로세스는 다음과 같은 이유 때문에 자식 프로세스의 실행을 종료시킬 수 있다. 자식 프로세스가 할당된 자원의 사용을 초과할 때. 자식 프로세스에게 할당된 작업이 더 이상 필요치 않을 때. 부모 프로세스가 종료되면 자식 프로세스도 모두 종료된다. Reference방송대 컴퓨터과학과 운영체제 2강","link":"/2019/03/06/2019-03-06-operating-systems-process-gerating/"},{"title":"프로세스","text":"프로세스실행 중인 프로그램. 프로그램: 동작을 하지 않는 정적, 수동적 개체 프로세스: 동작을 하는 능동적 개체 프로세스의 동작은 CPU가 그 프로세스의 명령들을 실행하는 것이다. 자원: CPU, 메모리, 입출력장치, 파일 등 동작: CPU가 프로세스의 명령을 실행 운영체제는 실행할 준비가 된 프로세스들이 적절히 CPU를 배정받아 효율적으로 작업을 처리할 수 있도록 관리해야 한다. 프로세스 간의 관계독립적 프로세스시스템에서 실행 중인 다른 프로세스의 영향을 받지도 않고 주지도 않는 프로세스. 프로세스의 상태와 데이터는 다른 프로세스와 공유되지 않는다. 프로세스의 실행은 결정적이며 재생 가능하다. 프로세스의 실행은 타 프로세스와 무관하게 중단되거나 재시작될 수 있다. 유기적 프로세스시스템에서 실행 중인 따른 프로세스의 영향을 주고받으며 동작하는 프로세스. 프로세스의 상태와 데이터는 다른 프로세스와 공유된다 프로세스의 실행은 비결정적며 재생 불가능하다. 프로세스 관리자 프로세스를 생성 및 삭제함. 프로세스 실행(CPU 할당)을 위한 스케줄 결정. 프로세스의 상태를 관리하며 상태 전이를 처리. 프로세스의 상태 변화시스템에서 프로세스가 처리될 때 프로세스는 생성, 준비, 실행, 대기, 종료의 다섯 가지 중 하나의 상태에 있게 된다. 생성처음 작업이 시스템에 주어진 상태. 프로세스가 생성되는 중이다. 생성 -&gt; 준비미리 정의된 정책에 따라 스케줄러에 의해 호출되는데 이때 다양한 자원들이 어떻게 필요한지 파악하는 작업을 함. 준비실행 준비가 되어 CPU 할당을 기다리는 상태. 필요한 자원들은 다 할당받은 후 CPU 할당만 기다리고 있음. 준비 -&gt; 실행사전에 정의된 알고리즘ㅁ에 따라 스케줄러에 의해 프로세스가 처리 된다. 이 과정을 디스패치 라고 한다. 실행프로세스가 CPU를 할당 받아 작업을 처리하고 있는 상태이다. 대기I/O 작업 같은 이벤트를 처리하기 위해 프로세스의 작업이 보류되는 상태이다. 실행 -&gt; 준비할당시간의 만료나 높은 우선순위의 프로세스가 오는 경우 스케줄러에 의해서 처리된다. 실행 -&gt; 대기I/O 처리, 페이지 교환 같은 명령어 등에 의해 일어난다. 이러한 작업은 상대적으로 오랜 시간이 걸리기 때문에 그동안 CPU를 다른 프로세스에 할당하여 활용하기 위함이다. 종료프로세스의 실행이 종료되었다. Reference방송대 컴퓨터과학과 운영체제 2강","link":"/2019/03/16/2019-03-06-operating-systems-process/"},{"title":"이진 탐색","text":"이진탐색 탐색: 배열 형태로 주어진 데이터에서 원하는 값을 가진 데이터를 찾는 문제. 이진 탐색: 정렬된 상태의 데이텅에 대해 적용 가능한 효과적인 탐색 방법. 탐색 방법배열은 오름차순 정렬 되어 있다고 가정한다. ###분할배열의 가운데 원소를 기준으로 왼쪽 부분배열과 오른쪽 부분배열로 분할한다. 탐색키 x가 가운데 원소와 같으면 가운데 원소에 해당하는 배열의 인덱스를 반환하고 종료한다. ###정복x가 가운데 원소보다 작으면 왼쪽 부분배열을 대상으로 이진 탐색을 순환호출 하고, 크면 오른쪽 부분배열을 대상으로 이진 탐색을 순환호출한다. 탐색을 다시 수행할 때마다 탐색 범위가 절반으로 줄어든다. 결합.부분배열에 대해서 이진 탐색의 결과가 직접 반환되므로 결과를 결합할 필요가 없다. 알고리즘재귀함수1234567891011121314151617181920int binarySearch(int arr[], int leftIndex, int rightIndex, int x) { // 탐색 실패 if (leftIndex &gt; rightIndex) { return -1; } int mid = (leftIndex + rightIndex) / 2; if (x == arr[mid]) { return mid; } if (x &lt; arr[mid]) { // 왼족 배열 탐색 return binarySearch(arr, leftIndex, mid - 1, x); } else { // 오른쪽 배열 탐색 return binarySearch(arr, mid + 1, rightIndex, x); }}; 반복함수12345678910111213141516171819202122int binarySearch_Iteration(int arr[], int index, int x) { int leftIndex = 0, rightIndex = index - 1; while(leftIndex &lt;= rightIndex) { int mid = (leftIndex + rightIndex) / 2; if (x == arr[mid]) { return mid; } if (x &lt; arr[mid]) { // 왼쪽 부분배열 탐색 rightIndex = mid - 1; } else { // 오른쪽 부분배열 탐색 leftIndex = mid + 1; } } // 탐색키가 존재하지 않을 경우 return -1; }; 이진 탐색에서는 분할 될 때마다 입력 크기가 절반으로 감소 하며, 탐색 대상의 개수가 1이 되면 더는 분할이 수행되지 않고 탐색 성공 여부가 결정된다. 성능 분석T(n) = 입력 크기 n에 대한 탐색 과정에서의 모든 비교 횟수의 합 = 맨 바깥 수준에서의 비교 횟수 + 순환 호출에서의 비교 횟수. 맨 바깥 수준에서의 비교 횟수는 상수이므로 1.순환 호출에서의 비교 횟수는 비교 할 때마다 절반 씩 데이터를 나누므로 $\\frac{n}{2}$. T(n) = T($\\frac{n}{2}$) + O(1)(n &gt; 1), T(1) = 1;T(n) = O($logn$) 특징 입력이 정렬된 리스트에 대해서만 적용이 가능하다. 데이터의 삽입/삭제 연산을 수행하면 데이터의 이동이 발생한다. 평균 $\\frac{2}{n}$개의 데이터 이동이 발생하므로 삽입/삭제가 빈번한 응용에는 부적합하다. Reference방송대 컴퓨터과학과 알고리즘 3강","link":"/2019/03/17/2019-03-11-algorithms-binary-search/"},{"title":"분할정복 방법","text":"분할정복 방법순환적으로 문제를 푸는 하향식 접근 방법. 주어진 문제의 입력을 더 이상 나눌 수 없을 때까지 두 개 이상의 작은 문제들로 순환적으로 분할하고, 이렇게 분할된 작은 문제들을 각각 해결한 후 이들의 해를 결합하여 원래의 문제의 해를 구하는 방식. 분할정복 방법 처리 과정분할주어진 문제를 여러 개의 작은 문제로 분할한다. 정복작은 문제들을 순환적으로 분할한다. 만약 작은 문제가 더 이상 분할되지 않을 정도로 충분히 작다면 순환호출 없이 작은 문제의 해를 구한다. (정복) 결합작은 문제에 대해 정복된 해를 결합하여 원래 문제의 해를 구한다. 분할정복 방법의 특징 분할된 작은 문제는 원래의 문제에 비해 입력 크기만 작아졌을 뿐 문제 자체는 원래 문제와 동일하다. 분할된 문제는 서로 독립적이기 때문에 각각의 작은 문제를 다시 순환적으로 분할하고 그 결과를 통합하는 것이 가능하다. 분할정복 방법을 적용한 알고리즘이진 탐색 크기가 n인 문제를 크기가 n/2인 두 개의 작은 문제로 분할한다. 그 중 하나의 작은 문제는 처리 대상에서 제외한다. 합병 정렬 크기가 n인 문제를 크기가 n/2인 두 개의 작은 문제로 분할한다. 퀵 정렬크기가 n인 문제를 쿠기는 감소하지만 일정하지 않은 크기의 두 개의 작은 문제로 분할한다. 선택 문제크기가 n인 문제를 크기는 감소하지만 일정하지 않은 크기의 두 개의 작은 문제로 분할한다. 그중 하나의 작은 문제는 처리 대상에서 제외한다. Reference방송대 컴퓨터과학과 알고리즘 3강","link":"/2019/03/11/2019-03-11-algorithms-divide-and-conquer/"},{"title":"퀵 정렬","text":"퀵 정렬특정 원소를 기준으로 주어진 배열을 두 부분배열로 분할하고, 각 부분배열에 대해서 퀵 정렬을 순환적으로 적용하는 방식.특정 원소를 피벗 이라고 부름. 즉, 피벗이 제자리를 잡조록 하여 정렬하는 방식. 피벗의 왼쪽 부분배열엔 피벗보다 작은 값이, 오른쪽 부분배열엔 피벗보다 큰 값이 온다. 피벗: 두 부분배열로 분할할 때 기준에 되는 특정 원소. 보통 주어진 배열의 첫 번째 원소로 지정한다. 분할피벗을 기준으로 주어진 배열을 두 부분배열로 분할한다. 정복두 부분배열에 대해서 퀵 정렬을 순환적으로 적용하여 각 부분배열을 정렬한다. 결합필요 없음 알고리즘1234567891011121314151617181920212223242526272829303132333435363738394041424344void swap(int arr[], int a, int b){ int temp = arr[a]; arr[a] = arr[b]; arr[b] = temp;}// 배열의 맨 오른쪽 index엔 무한대 값이 있다고 가정한다.int partition(int arr[], int leftIndex, int rightIndex) {// 맨 왼쪽을 피벗으로 잡기 때문에 l_hold는 피벗의 위치 + 1, r_hold는 배열의 마지막 index int pivot = arr[leftIndex], l_hold = leftIndex + 1, r_hold = rightIndex; while (l_hold &lt;= r_hold) { // l_hold는 피벗보다 큰 값을 찾는다. while (l_hold &lt;= rightIndex &amp;&amp; arr[l_hold] &lt; pivot) { l_hold++; } // r_hold는 피벗보다 작은 값을 찾는다. while (r_hold &gt; leftIndex &amp;&amp; arr[r_hold] &gt;= pivot) { r_hold--; } if (l_hold &lt; r_hold) { // arr[l_hold]와 arr[r_hold]의 값을 교환한다. swap(arr, l_hold, r_hold); } } // 피벗과 arr[r_hold]값을 교환한다. swap(arr, leftIndex, r_hold); return r_hold;}void quickSort(int arr[], int leftIndex, int rightIndex) { if (leftIndex &lt;= rightIndex) { int pivot = partition(arr, leftIndex, rightIndex); // 두 부분배열로 분할 quickSort(arr, leftIndex, pivot - 1); // 왼쪽 부분배열에 대해 순환호출 quickSort(arr, pivot + 1, rightIndex); // 오른쪽 부분배열에 대해서 순환호출 } } 성능 분석퀵 정렬 알고리즘은 한 번의 분할과 두 번의 순환 호출로 구성된다. 분할 함수 수행 시간피벗을 제외한 배열의 원소들은 피벗과 최대 2번 비교 하게 된다. 전체적으로는 입력 크기 n에 비례하는 Θ(n) 시간이 걸린다. 퀵 정렬 수행 시간퀵 정렬 수행 시간 = 한 번의 분할 + 두번의 킉정렬 순환 호출.배열 부분 시 두 부분배열의 크기가 다르기 때문에 배열이 어떤 크기의 두 부분배열로 분할되느냐에 따라 수행 시간이 다르다. 최악의 경우극심한 불균형적 분할. 피벗만 제자리를 잡고, 나머지 모든 원소가 하나의 부분배열로 분할되는 경우 피벗이 항상 부분배열의 최솟값, 또는 최댓값이 되는 경우 입력 데이터가 정렬되어 있고 피벗을 배열의 처음 원소로 지정한 경우 T(n) = T(n-1) + T(0) + Θ(n) (n &gt; 0) // 한쪽은 데이터가 없으므로 T(0)T(0) = 0 =&gt; T(n) = T(n - 1) + Θ(n)=&gt; T(n) = O($n^2$) 최선의 경우가장 균형적인 분할. 피벗을 중심으로 항상 동일한 크기의 두 부분배열로 분할되는 경우 피벗이 항상 부분배열의 중간값이 되는 경우 T(n) = T($\\frac{n}{2}$) + T($\\frac{n}{2}$) + Θ(n) (n &gt; 1)T(1) = 1 =&gt; T(n) = 2T($\\frac{n}{2}$) + Θ(n)=&gt; T(n) = O($n log n$) 평균적인 경우부분배열의 모든 분할 비율에 따른 수행 시간의 평균. 피벗은 동일한 확률로서 분할 후 배열의 어느 곳에나 위치 가능 T(1) = T(0) = 0T(n) = $\\frac{1}{n}\\sum_{i = 1}^{n}(T(i - 1) + T(n - i)) + O(n) (n &gt;= 2)$ =&gt; T(n) = O($n log n$) 특징 최선/ 평균의 경우 O($n log n$) 최악의 경우 O($n^2$) 즉 피벗 선택의 임의성만 보장되면 평균적인 성능을 보일 가능성이 매우 높다. 그래서 배열에서 임의로 값을 선택해서 배열의 처음 원소와 서로 교환 후 정렬 수행하면 최악의 경우를 피할 가능성이 커진다. Reference방송대 컴퓨터과학과 알고리즘 3강","link":"/2019/03/17/2019-03-11-algorithms-quick-sort/"},{"title":"합병정렬","text":"합병정렬배열을 동일한 크기의 두 개의 부분배열로 분할하고 각각의 부분 배열을 순환적으로 정렬한 후, 정렬된 두 부분배열을 합병하여 하나의 정렬된 배열을 만든다. 분할입력의 크기가 n인 배열을 n/2개의 원소를 가진 두 부분배열로 분할한다. 정복각각의 부분배열에 대해서 합병 정렬을 순환적으로 적용하여 각 부분배열을 정렬한다. 결합정렬된 두 부분배열을 합병하여 하나의 정렬된 배열을 만든다. 알고리즘123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657void merge(int arr[], int sorted[], int leftIndex, int mid, int rightIndex) { int l_hold = leftIndex, r_hold = mid + 1; int resultIndex = leftIndex; // 결과 배열의 index while(l_hold &lt;= mid &amp;&amp; r_hold &lt;= rightIndex) { // 부분배열 두개를 비교하여 작은 값을 선택한다. if (arr[l_hold] &lt; arr[r_hold]) { sorted[resultIndex] = arr[l_hold]; l_hold++; } else { sorted[resultIndex] = arr[r_hold]; r_hold++; } resultIndex++; } // 왼쪽 부분배열에 남아있는 모든 원소를 새로은 배열로 이동시킨다. while (l_hold &lt;= mid) { sorted[resultIndex] = arr[l_hold]; resultIndex ++; l_hold ++; } // 오른쪽 부분배열에 남아있는 모든 원소를 새로은 배열로 이동시킨다. while (r_hold &lt;= rightIndex) { sorted[resultIndex] = arr[r_hold]; resultIndex ++; r_hold ++; } // 원본 배열에 정렬된 배열을 이동 시킨다. for (int i = leftIndex; i &lt;= rightIndex; i++) { arr[i] = sorted[i]; }}void mergeSort (int arr[], int sorted[], int leftIndex, int rightIndex) { if (leftIndex &lt; rightIndex) { // 각각 n/2크기를 가진 두 부분배열로 나누기 위해 가운데 값 정함. int mid = (leftIndex + rightIndex) / 2; // 왼쪽 부분배열의 순환호출 mergeSort(arr, sorted, leftIndex, mid); // 오른쪽 부분배열의 순환호출 mergeSort(arr, sorted, mid + 1, rightIndex); // 정렬된 두 부분배열의 합병 merge(arr, sorted, leftIndex, mid, rightIndex); }} 성능 분석합병 함수 수행 시간합병 함수 수행 시간 = 부분배열[n/2] + 부분배열[n/2] = 배열[n] 두 부분 배열을 합병하면 최악의 경우 결과 배열엔 n + m개의 원소가 저장되는에 이때 최악의 경우 n + m - 1회의 비교가 필요하다. 최소 비교횟수: $\\frac{n}{2}$ 최대 비교횟수: ($\\frac{n}{2}$ + $\\frac{n}{2}$ - 1) = n - 1;=&gt; 입력 데이터 개수만큼의 저장 장소가 추가로 필요하다. 결국 합병을 하는데 걸리는 시간은 입력 크기 n에 비례하므로 Θ(n)이 된다. 합병 정렬 수행 시간합병 정렬 수행시간 = 크기 n/2인 두번의 합병 정렬 순환 호출 + 한번의 합병 T(1) = 1;T(n) = T($\\frac{n}{2}$) + T($\\frac{n}{2}$) + Θ(n); =&gt; T(n) = 2T($\\frac{n}{2}$) + Θ(n)=&gt; T(n) = O($n log n$) Reference방송대 컴퓨터과학과 알고리즘 4강","link":"/2019/03/18/2019-03-17-algorithms-merge-sort/"},{"title":"소프트웨어 위기 현상 및 소프트웨어 공학","text":"소프트웨어 위기 현상급격한 컴퓨터 하드웨어 기술의 발전으로 인해 사용자의 요구사항이 다양해지면서 해결해야 할 문제는 복잡해졌으나 상대적으로 소프트웨어 기술의 진보가 더딤을 일컫는 말. 개발 일정이 계획보다 지연된다. 초과 비용이 발생한다. 제품의 신뢰도가 결여된다. 빈번하게 명세와 불일치하는 부분이 나타난다. 품질 저하와 유지보수의 어려움이 생긴다. 소프트웨어 위기 현상의 원인 소프트웨어 공학의 훈련을 받은 전문 인력의 부족. 소프트웨어에 관한 경영층의 인식 부족. 일관성 있는 방법론 및 지원 도구의 문제. 소프트웨어 개발 생산성 저하. 소프트웨어 자체의 복잡성 증가. 소프트웨어 공학소프트웨어 위기 현상의 해결책으로 표현하기 위해 만들어진 용어.고품질 소프트웨어의 경제적이고 빠른 생산과 유지보수를 위한 전문 작업과 연구 분야가 되었다. 신롸성 있고 요구기능을 효율적으로 수행하는 소프트웨어를 경제적으로 생산하기 위해 건전한 공학적 원리와 방법을 만들고 사용하는 것. 초기 NATO 컨퍼런스에서 바우어 교수가 제시한 정의 소프트웨어의 개발, 운영, 유지보수에 체계적이고 숙달되고 정량화된 접근 방법을 적용하는 것. 즉 소프트웨어에 공학 기술을 적용하는 것 또는 이러한 접근 방법에 관한 연구 분야. IEEE 소프트웨어 공학 표준 용어집에 정의되어 있다. 인간에게 유용한 소프트웨어 제품을 만드는 과정에 과학적 지식을 적용함으로써 실제적 문제의 비용 효율적 해결책을 다루는 일 소프트웨어 공학 환경소프트웨어 개발이 단순히 코드의 생성이 아님을 인식하고 문서화와 프로젝트 관리의 중요성이 인식되었다.개발 과정 초기의 요구사항 명세화 작업에 많은 노력을 기울임으로써 오류를 줄이고 비용을 절약할 수 있다.변경이나 재사용을 염두에 둔 작업 등이 품질, 비용 및 생산성을 향상시킬 수 있다. 이렇게 다양한 해결 방법들을 통합적으로 다루기 위해 등장한 것이 소프트웨어 공학환경이다. 소프트웨어 공학 환경의 최하위층에 소프트웨어 공학 원리가 위치하고 그 위에 방법과 기술이 위치하며 그 위에 방법론이, 그리고 최상위층에 도구가 위치한다. 각 계층은 그 아래 게층에 기초를 두고 있으며, 아래 계층보다 변화 가능성이 높다. 스포트웨어 공학 원리소프트웨어 프로세스와 제품의 바람직한 측변들을 기술하는 일반적이고 추상적인 설명이다.추상화, 분할 정복, 계층적 조직의 원리 등이 이것에 해당한다. 방법과 기술 방법: 행위를 통제하는 체계적이고 일반적인 가이드라인 또는 구조화된 접근 방법. 소프트웨어 제품을 정의, 기술, 추상화, 수정, 정제 및 문서화하는 데 필요한 모든 행위들을 포함한다. 기술: 방법에 비해 보다 기계적으로 적용되나 제한된 적용성을 가진다. 방법론과 도구 방법론: 프로세스(what)과 방법(how)를 함께 기술하는 것. 방법론의 목적은 문제 해결을 위해 사용되어야 할 방법들과 기술들을 지정함으로써 특정 방식의 해법을 권장하는 것이다. 도구: 기술과 방법, 그리고 방법론들의 적용을 지원하기 위해 개발된다. 도구를 사용하는 것을 자동화라고 하며 소프트웨어 제품 개발에 필요한 방법들을 구현하기 위해 컴퓨터를 활용하는 것을 말한다. Reference방송대 컴퓨터과학과 소프트웨어 공학 1강","link":"/2019/03/23/2019-03-23-software-engineering-crisis-engineering/"},{"title":"데이터 통신 시스템","text":"데이터 통신 시스템원거리에 떨어져 있는 데이터 발생지와 목적지 사이에 정보를 신속하고 정확하게 전송하고 처리하기 위해 데이터 전송과 데이터 처리를 상호 유기적 으로 결합한 시스템. 데이터 통신 시스템의 기능 전송 시스템 활용 접속 동기화 교환관리 오류검출 및 정정 흐름제어 주소지정 라우팅 복구 메시지 형식화 보호 시스템 관리 데이터 통신 시스템의 구성 요소 단말장치 데이터 통신 시스템에서 최종적으로 데이터를 송신하거나 수신하는 기능을 수행하는 장치. 단말기 또는 터미널이라고도 불린다. 키보드와 모니터, 프린터 등과 같이 컴퓨터와 연결되는 모든 주변장치를 의미한다. 입출력 기능, 기억 기능 및 전송제어 기능으로 구분된다. 입출력 기능외부로부터 정보를 받아들이고, 역으로 데이터 통신 시스템에서 처리한 결과를 외부에 출력한다. 기억 기능단말장치에 디스크나 소용량 기억장치를 부가하여 송,수신 데이터를 일시적으로 기억하거나 정보의 자체적이고 지역적인 처리를 수행한다. 전송제어 기능컴퓨터와 단말장치 간에 정확한 데이터의 송수신이 가능하도록 전송제어를 수행한다. 데이터 전송회선 단말장치로부터 통신제어장치까지의 데이터 전송 경로. 신호변환장치와 통신회선으로 구분된다. 신호변환장치 송신측이 전송한 데이터는 신호변환장치를 통과하면서 전기적 신호로 변환된 후 통신회선을 통해 수신측 신호변환장치에 전달된다. 수신측 신호변환장치는 전기적 신호를 원래의 데이터로 변환하여 통신제어장치에 전달한다. 대표적인 신호변환장치는 변복조기와 디지털 서비스 유니트가 있다. 통신제어장치 컴퓨터와 신호변환장치 사이에 위치하며, 단말장치와의 통신에 있어 각종 제어 기능을 분담한다. 통신제어장치는 데이터 전송회선과의 전기적 접속을 이루며 문자의 조립, 분해 기능과 버퍼링, 오류검출, 오류제어용 확장 비트 부가, 전송 제어, 회선의 감지, 접속제어 기능을 갖는다. 컴퓨터컴퓨터의 중앙처리장치에는 통신제어 프로그램이 내장되어 있어 통신제어장치로부터 입력된 데이터를 처리하고, 데이터 통신 시스템 전체를 제어한다. 통신 소프트웨어 데이터 전송회선과 통신제어장치를 이용하여 컴퓨터와 단말장치 사이에서 정보를 송수신하기 위한 프로그램. 주요 기능: 데이터 송수신, 통신 하드웨어의 제어, 이용자 접속의 제어 Reference방송대 컴퓨터과학과 정보통신망 1강","link":"/2019/03/24/2019-03-24-information-network-data-communication-system/"},{"title":"컴퓨터 통신망","text":"컴퓨터 통신망의 출현지역적으로 떨어진 컴퓨터와 컴퓨터를 서로 통신망으로 연결시켜 컴퓨터 자원을 공유하려는 이유에서 컴퓨터 통신망이 출현하게 되었다. 데이터 통신 기술데이터 처리에 있어서 데이터 통신은 매우 중요한 역할을 한다. 통신망으로 서로 연결되어 있지 않은 컴퓨터, stand-alone 컴퓨터에서도 데이터 통신은 없어서는 안될 중요한 기능이다. A컴퓨터와 B컴퓨터가 송•수신을 할 때 통신 시스템을 거쳐서 원하는 데이터의 송 • 수신이 가능하다. 데이터 처리 기술컴퓨터를 이용하는 데이터 처리 기술이 데이터 통신 분야에도 큰 영향을 미치고 있다.현재의 디지털 신호 전송 방식은 컴퓨터를 활용함으로써 음성뿐만 아니라 문자 데이터, 화상 데이터 등도 모두 디지털화 하여 고품질의 데이터 전송이 가능하게 만들었다. 즉, 통신 기술이 아날로그 방식에서 디지털 방식으로 전이됨으로써 얻게 되는 많은 장점은 컴퓨터 시스템의 데이터 처리 기술 덕분이다. 분산 시스템컴퓨터 자원을 공유하고 그들의 확장과 축소를 용이하도록 하며 오류에 대한 신뢰도를 높일 수 있도록 컴퓨터 자원을 분산시켜 작업을 처리하는 시스템. 여러군데다가 자원을 분산시켜 놓음으로써 한쪽에서 고장이 나도 다른쪽에서 데이터를 가져올 수 있기 때문에 오류에 대한 신뢰도가 높아짐. 강연결 분산 시스템분산된 거리가 짧고 처리기 사이의 상호 작용이 많은 분산 시스템. ex) 자료흐름기계, 멀티프로세서 약연결 분산 시스템분산된 거리가 비교적 길고 처리기 사이의 상호 작용이 비교적 적은 분산 시스템. ex) 근거리 통신망(LAN), 원거리 통신망(WAN), 도시권 통신망(MAN). 컴퓨터 통신망의 정의 및 구성 요소 통신 넓은 의미로는 ‘거리상 서로 떨어진 사람 또는 장치들 사이에 여러 종류의 매개체를 이용하여 정보를 전달하는 활동’을 뜻하며 좁은 의미로는 ‘원격통신’을 뜻한다. 원격통신: 전자적 신호나 전자기적 파장을 이용하여 정보를 전송하는 것. 데이터 통신: 컴퓨터 시스템에 의한 데이터를 처리하는 기술과 데이터를 전송하는 기술이 결합된 것. 데이터 통신망: 데이터 통신 기술과 망 기술이 융합된 개념. 컴퓨터 통신망(컴퓨터 망): 자원과 정보를 공유할 수 있게 해 주기 위해 통신 채널들로 상호 연결된 컴퓨터들과 기타 하드웨어 및 소프트웨어 구성 요소들의 집합체. 서버, 클라이언트, 전송 매체, 네트워킹 장치, 프로토콜, 애플리케이션 등의 구성 요소로 이루어진다. 서버: 컴퓨터 서비스에서 특정 서비스를 제공해 주는 컴퓨터. 클라이언트: 서비스를 받고자 하는 컴퓨터 또는 단말. 전송 매체: 컴퓨터 통신망에서 서버 및 클라이언트를 상호연결 시키고 데이터 전송이 가능하도로고 하기 위해 사용되는 장비. 네트워킹 장치: 서버와 클라이언트를 컴퓨터 통신망에 연결시키기 위해 필요한 연결 장치. 프로토콜: 서버와 클라이언트가 통신하기 위해 미리 정해 놓은 규칙. 애플리케이션: 컴퓨터 통신망을 통해 서버가 클라이언트에게 제공하는 서비스 또는 그것을 위한 프로그램. 컴퓨터 통신망의 서비스 e-mail 파일 전송 원격 처리 원격 회의 분산 데이터베이스 시스템 Web Service Social Network Service 그외 등등… 컴퓨터 통신망의 역사 SAGE(Semi-Automatic Ground Environment) 시스템: 1958년 미국에서 군사 목적으로 개발된 컴퓨터와 통신을 결합시킨 최초의 컴퓨터 통신 시스템. SABRE(Semi-Automatic Business Research Environment) 시스템: 1961년에 발표된 여객기의 좌석 예약과 회사 업무를 종합적으로 처리하기 위한 상업적인 컴퓨터 통신 시스템. CTSS(Compatible Time Sharing System): 다수 사용자의 공동 이용을 위해 미국의MIT 대학에서 개발한 시분할 시스템(time sharing system). ARPANET: 1969년 이후 가동되어 1990년까지 운영되었으며 인터넷의 전신이 된 컴퓨터 네트워크 시스템. ALOHA(Additive Links Online Hawaii Area) 시스템: 1968년 하와이 대학에서 실험적으로 시작한 무선 패킷 교환방식의 통신 시스템. SNA(System Network Architecture) : 1974년에 IBM에서 발표한 컴퓨터 간의 접속을 용이하게 하고, 이용 형태의 다양화·복잡화를 대체하기 위한 체계화된 네트워크 구조. 컴퓨터 통신망의 활용 목적자원의 공유컴퓨터 통신망이 구축되면 사용자 또는 컴퓨터의 지리적 위치에 관계 없이 컴퓨터 통신망에 연결된 사람이면 누구든지 컴퓨터 자원을 자유롭게 이용할 수 있다. 신뢰도의 향상 및 안정성 보장컴퓨터 통신망이 구축되면 한대의 컴퓨터가 고장나더라도 복구될 때까지 다른 컴퓨터를 사용할 수 있으므로 신뢰도및 안정성이 향상된다. 처리 기능의 분산컴퓨터 통신망이 구축되면 처리 기능을 지역적으로 분산시킴으로써 전체 시스템의 처리 능력을 향상시킬 수 있다. Reference방송대 컴퓨터과학과 정보통신망 1강","link":"/2019/03/24/2019-03-24-information-network-first/"},{"title":"컴퓨터 보안 개념","text":"컴퓨터 보안다양한 형태의 정보 중 컴퓨팅 환경이 관여된 모든 상황에 대한 정보보호. 정보보호: 저장되어 있거나 전달 중인 정보를 허락되지 않은 접근, 수정, 훼손, 유출 등의 위협으로부터 보호하기 위한 정책 및 기법. 컴퓨터 보안의 목표기밀성, 무결성, 가용성이 컴퓨터 보안의 가장 중요한 목표 이다. 기밀성허락되지 않은 자가 정보의 내용을 알 수 없도록 하는 것.기밀성을 지키기 위해서는 허락되지 않은 자가 정보에 접근을 아예 못하도록 할 수도 있고, 정보에 접근하더라도 무의미한 내용만 보이도록 할 수 있다. ex)고객의 개인정보를 제 3자에게 알려지는 것을 방지하기 위해 보호하는 것. 무결성허락되지 않은 자가 정보를 함부로 수정할 수 없도록 하는 것.만약 허락되지 않은 자에 의한 수정이 발생했다면 이를 확인할 수 있는것 역시 무결성을 지키는 방법이다. ex)데이터베이스에 고객의 정보가 저장되어 있다면 그 내용이 임의로 수정되지 않도록 보호하는 것.고객 본인이 본인의 회원정보를 확인할 때 이 과정에서도 내용이 위변조 되지 않도록 보호하는 것. 가용성허락된 자가 정보에 접근하고자 할 때 이것이 방해받지 않도록 하는 것.즉, 정보에 대한 접근권한이 있는 자는 필요할 때 언제든지 정보를 사용할 수 있어야 한다.결국 가용성은 정해진 시간 내에 정보를 볼 수 있음을 보장한다. ex)고객이 회원정보를 수정하기 위해 회원정보를 확인하고자 할 때 즉시 조회가 가능하게 하는 것. 그 외 목표들부인방지, 인증, 접근제어 등이 있다. 부인방지정보에 관여한 자가 이를 부인하지 못하도록 하는 것. ex)정보를 보낸 사람이 나중에 정보를 보냈다는 것을 부인하지 못하도록 하는 발신 부인방지.정보를 받은 사람이 나중에 받지 않았다는 것을 부인하지 못하도록 하는 수신 부인방지. 인증정보 또는 정보를 이용하는 사용자가 정말 주장하는 정보 또는 사용자가 맞는지 확인할 수 있고 신뢰할 수 있는 것. 접근제어정보에 대해 허락한 접근만 허용하고 그 외의 접근은 허용하지 않는 것.접근권한이 있는 자는 정보에 대한 접근을 허용하고 접근권한이 없는 자는 정보에 접근하지 못하게 하는 것이다. 이때 접근권한은 정보나 사용자에 따라 다양하게 부여될 수 있다. 정보화 환경과 역기능과거 정보통신기술이 미약하던 시대에는 정보의 전달이 대부분 인편에 의존하였기 때문에 정보의 전파가 굉장히 느렸다. 그러다가 통신회선이 깔리면서 전보나 전화를 통해 정보의 전파속도가 빨라졌고, 이제는 인터넷을 통해 지구 반대편에서 일어나는 일도 실시간으로 알 수 있을 만큼 정보는 빠르게 움직이고 있다. 이처럼 정보화 사회가 선진화 됨에 따라 악성 댓글, 스팸 메일, 개인정보 유출, 금전적인 목적을 대상으로 하는 피싱이나 파밍, 스미싱 등에 따른 개인적인 피해가 증가하고 있으며 불건전 정보 유통, 사생활 침해 등과 같은 부작용이 심각한 사회문제로 대두되고 있다. 이러한 문제점은 보이스 피싱, 문자 메시지나 인스턴트 메시지를 이용한 스미싱, 랜섬웨어 같은 새로운 수법이 등장하면서 대처를 더욱 어렵게 하고 있다. 주요 기반 시설이 점차 정보통신 네트워크에 의해 관리 및 통제 됨에 따라 정보통신 인프라의 위협이 주요 기반 시설의 위협으로까지 확장되고 있으며, 결국 이는 국가 안보적인 측면에서 위험이 될 수 있다. Reference방송대 컴퓨터과학과 컴퓨터 보안 1강","link":"/2019/04/07/2019-04-07-computer-security-first/"},{"title":"암호의 개념","text":"암호의 정의 암호: 두 사람이 안전하지 않은 채녈을 통하여 정보를 주고받더라도 제3자는 이 정보의 내용을 알 수 없도록 하는 것. 안전하지 않은 채널: 이 채널을 통해 지나다니는 메시지를 누구든지 볼 수 있다는 의미. 암호문: 제3자가 보더라도 그 내용을 알 수 없도록 변환된 메시지. 평문: 변환되기 전인 원래의 메시지. 암호화: 평문을 암호문으로 변환하는 것. 복호화: 암호문을 다시 평문으로 변환하는 것. 결국 암호는 송신자와 수신자가 서로 약속한 방식을 이용하여 송신자는 평문을 암호화하여 암호문을 만들어 보내고 수신자는 암호문을 복호화하여 평문을 만듦으로써 서로 정보를 주고 받는 것. 여기서 약속한 방식이란 특정한 암호 알고리즘 및 특정한 키를 의미한다. 키는 암호화와 복호화를 위한 가장 중요한 열쇠로 제 3자에게 알려져서는 안된다. 암호는 정보보호 핵심 목표 중 기밀성을 보장하기 위한 필수적인 기술이다. 암호의 역사처음에는 암호를 주로 군사와 정치적인 목적으로 사용했다.최근에는 일상생활과도 깊게 관계를 맺고 있으며, 인터넷뱅킹에 사용되는 인증서, 보안 키패드, 소프트웨어의 시리얼 키뿐만 아니라 전자투표 등에서 점차 널리 쓰이고 있다. 컴퓨터와 통신이 결합함에 따라 불법 사용자의 봉쇄 또는 데이터의 위조 및 변조를 막는 수단으로도 이용되고 있다. 고대 암호최초의 암호는 기원전 480년에 스파르타에서 추방되어 페르시아에 살던 데마라토스가 페르시아의 침략계획 소식을 나무판에 조각하여 적은 후 밀랍을 발라 스파르타에 보낸 것. 스테가노그래피: 실제로 전달하고자 하는 정보 자체를 숨기는 것. 어떤 스테가노그래피 방식이 사용되었는지 알면 제 3자가 비교적 쉽게 숨겨진 정보를 찾을 수 있기 때문에 엄밀히 말하면 최초의 암호라고 하기는 힘듦. 전치법 평문에 있는 문자들의 순서를 바꿈으로써 암호화 하는 기법. 암호화를 하는 쪽과 복호화를 하는 쪽이 미리 정해놓은 문자 배열규칙에 따라 암호화와 복호화를 수행하는 방식. 암호문에 사용되는 문자들은 평문에서 사용된 문자들이 그대로 이용되며 단지 위치만 바뀐다. ex)컴퓨터보안재미있는과목입니다~! -&gt; 컴안는니퓨재과다터미목~보있입! 치환법 평문의 문자들을 다른 문자로 치환함으로써 암호화 하는 기법. 암호화를 하는 쪽과 복호화를 하는 쪽이 미리 정해 놓은 문자 치환규칙에 따라 암호화와 복호화를 수행하는 방식. 암호문에 사용되는 문자들은 평문에서 사용된 문자들과 달라지지만 대응되는 각 문자의 위치는 바뀌지 않는다. 시저암호 알파벳 26글자를 알파벳 순서로 세 자씩 오른쪽으로 이동시킨 뒤, 해당되는 글자로 치환하여 암호화를 함. 시프트 암호 각 문자를 알파벳 순서로 k번째 뒤 문자로 치환하는 방법. k는 0부터 25가지의 정수 중 하나가 됨. 암호화와 복호화를 하는 두 사람이 미리 k값을 약속해야 하며 이 k 값이 바로 키가 됨. 근대 암호 16세기: 프랑스 외교관 비즈네르가 시프트 암호를 개선하여 새로운 비즈네르 암호라는 치환법을 고안함. 비즈네르 암호는 여러 개의 정수값을 키로 이용함. 20세기: 플레이페어 암호, 힐 암호 등 다양한 암호 방식이 등장함. 20세기 들어서는 통신기술의 발전과 기계식 계산기에 대한 연구를 바탕으로 두 차례의 세계 대전을 통해 암호 설계와 해독에 대한 필요성이 높아지면서 암호에 대한 연구가 더욱 활발하게 진행됨. 1949년: 섀년이 일회성 암호체계가 안전함을 증명했고 암호체계 설계의 두 가지 기본원칙인 혼돈과 확산 이론을 제시함. 혼돈은 평문과 암호문사이의 상관관계를 숨김. 확산은 평문의 통계적 성격을 암호문 전반에 확산시켜 숨기는 역할을 함. 현대 암호10970년대에 표준 암호 알고리즘과 공개 키 알고리즘의 등장으로 큰 변화가 일어남. 표준 암호 알고리즘의 등장.컴퓨터가 점차 발전하면서 데이터 보호에 대한 필요성도 증가하여 미국 NBS는 1977년 표준 암호 알고리즘으로 DES를 공표함.DES는 대표적인 대칭키 알고리즘으로 2001년 새로운 표준 알고리즘인 AES가 공표될 떄까지 널리 이용됨. 공개 키 알고리즘의 등장1076년 디피와 헬먼이 공개키 암호의 개념을 제시함.공개키 암호는 암호화와 복호화에 다른 키를 사용함. 이 개념을 이용하여 1978년 리베스트, 샤미르, 애들먼은 소인수분해 문제에 기반을 둔 RSA 공개키 알고리즘을 개발함. 대칭키 암호화와 복호화에 같은 키 하나를 사용하는 암호 방식. 대칭키 암호는 평문을 암호화할 때 키 K를 이용하여 암호문을 만들었으면 나중에 복호화 할 때도 동일한 키 K를 이용해야만 원래의 평문을 만들 수 있다. 비밀키: 대칭키 암호에서 사용하는 키. 암호와와 복호와 속도가 빠르다. 비밀키를 제 3자에게 노출하지 않으면서 송신자와 수신자가 나누어 가지기 어렵다. 블록 암호: 암호문을 만들기 위해 평문을 고정된 크기의 블록으로 나누어서 각 블록마다 암호화 과정을 수행하여 블록단위로 암호문을 얻는 대칭키 암호 방식. 스트림 암호: 평문과 같은 길이의 키 스트림을 생성하여 평문과 키를 비트 단위로 XOR하여 암호문을 얻는 대칭키 암호 방식. DES, AES, IDEA, SEED, CRYPTON, RC5, FEAL, MISTY, Skipjack, RC4 등의 대칭키 암호 알고리즘 들이 있다. 공개키 암호화와 복호화에 두 개의 서로 다른 키를 사용하는 암호 방식. 공개키 암호는 평문을 암호화 할 때 K1을 이용하여 암호문을 만들면 나중에 복호화 할 때는 다른 키 K2를 이용해야만 원래의 평문을 만들 수 있다. 공개키: 공개되어 있어서 누구나 공개키를 이용하여 암호화 할 수 있다. 개인키: 아무에게도 공개하지 않고 자신만 알고 있어야 하며 오직 자신만 개인키를 이용하여 복호화 할 수 있다. 키관리가 쉽고 키 분배 문제도 해결하였다. 대칭키 암호에 비해 속도가 느리다. 데이터를 암호화 할 때는 대칭키 암호방식을 많이 쓰며 이때 필요한 대칭키 암호의 비밀키를 교환할 때는 공개키 암호 방식을 쓴다. RSA 암호 알고리즘, EIGamal 암호 알고리즘, Rabin 암호 알고리즘, NTRU 암호 알고리즘 등의 공개키 암호 알고리즘 들이 있다. Reference방송대 컴퓨터과학과 컴퓨터 보안 2강","link":"/2019/04/21/2019-04-21-compouter-security-secret-code/"},{"title":"Mac 개발환경 설정","text":"맥북을 포맷하면서 개발환경을 새로 세팅하다가 기록해놓으면 좋을 것 같아서 기록함. Mac Homebrew 설치 Homebrew Mac 패키지 관리자는 Homebrew 사용 중. git 설치 1brew install git Front-end개인 프로젝트 진행 시 Node.js + yarn 환경을 사용함.개발툴은 vsocde 사용함. Node.js 설치 Node.js LTS 버전 사용 중. yarn 설치 1brew install yarn yarn vscode 설치 공통 Extensions Atom One Dark Theme Git History Material IconTheme Prettier JavaScript / React.js 관련 Extensions eslint ES7 React/Redux/GraphQL/React-Native snippets C자료구조나 알고리즘 공부 시 c로 코드를 작성 중. gcc 설치 1brew install gcc c로 작성 중인 프로젝트 폴더에 tasks.json 파일 작성. 1234567891011121314151617181920212223242526{ \"version\": \"2.0.0\", \"tasks\": [ { \"type\": \"shell\", \"label\": \"gcc build active file\", \"command\": \"/usr/bin/gcc\", \"args\": [ \"-g\", \"${file}\", \"-o\", \"${fileDirname}/${fileBasenameNoExtension}\" ], \"options\": { \"cwd\": \"/usr/bin\" }, \"problemMatcher\": [ \"$gcc\" ], \"group\": { \"kind\": \"build\", \"isDefault\": true } } ]} c 관련 vscode Extenstions 설치 필요함. C/C++ Code Runner","link":"/2019/04/25/2019-04-25-etc-development-env-setting/"},{"title":"Node.js","text":"Node.js?Node.js는 크롬 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임이다. Node.js는 이벤트 기반, 논블로킹 I/O모델을 사용해 가볍고 효울적이다.런타임은 특정 언어로 만든 프로그램들을 실행할 수 있는 환경을 뜻한다. 따라서 Node.js는 JavaScript 프로그램을 컴퓨터에서 실행할 수 있게 해준다. 자바스크립트 애플리케이션이 서버로서 기능하기 위한 도구를 제공하므로 서버 역할도 수행할 수 있다. 노드는 V8과 libuv라는 라이브러리를 사용한다. libuv 라이브러리는 노드의 특성인 이벤트 기반, 논블로킹 I/O모델을 구현하고 있다. Node.js 특징이벤트 기반이벤트 기반이란 이벤트(클릭이나 네트워크 요청 등)가 발생할 때 미리 지정해둔 작업을 수행하는 방식을 의미한다. 이벤트 기반 시스템에서는 특정 이벤트가 발생할 때 무엇을 할지 미리 등록해두어야 한다. 이것을 이벤트 리스너에 콜백 함수를 등록한다고 포현한다. 콜백함수: javaScript 에서는 함수를 다른 함수의 파라미터로 전달할 수 있다. 파라미터로 전달된 함수를 다른 내부에서 호출하는 것이 콜백 함수 이다. 콜백은 일반적으로 일회성 응답에 대한 로직을 정의하는데 사용된다. 노드도 이벤트 기반 방식으로 동작하므로 이벤트가 발생하면 이벤트 리스너에 등록해둔 콜백함수를 호출한다. 발생한 이벤트가 없거나 발생했던 이벤트를 다 처리하면 노드는 다음 이벤트가 발생할 때까지 대기한다. 여러 이벤트가 동시에 발생했을 때 어떤 순서로 콜백 함수를 호출할지를 이벤트 루프가 판단한다. 이벤트 루프: 이벤트 발생 시 호출할 콜백 함수들을 관리하고, 호출된 콜백 함수의 실행 순서를 결정하는 역할을 담당한다. 노드가 종료될 때가지 이벤트 처리를 위한 작업을 반복하므로 루프라고 불린다.태스크 큐: 이벤트 발생 후 호출되어야 할 콜백 함수들이 기다리는 공간이다. 콜백들이 이벤트 루프가 정한 순서대로 줄을 서 있으므로 콜백 큐라고 부른다.백그라운드: 타이머나 I/O 작업 콜백 또는 이벤트 리스너들이 대기하는 곳이다. Non-Blocking I/ONon-Blocking이란 이전 작업이 완료될 때까지 멈추지 않고 다음 작업을 수행함을 뜻한다. 이벤트 루프를 잘 활용하면 오래 걸리는 함수를 벡그라운드로 보내서 다음 코드가 먼저 실행되게 하고, 그 함수가 다시 태스크 큐를 거쳐 호출 스택으로 올라오기를 기다리는 논블로킹 방식으로 오래 걸리는 작업을 효율적으로 처리할 수 있다. 현재 노드 프로세스 외의 다른 컴퓨팅 자원을 사용할 수 있는 I/O 작업이 주로 논블로킹 방식으로 시간적 이득을 많이 본다. I/O작업을 할 대 노드는 논블로킹 방식으로 동작한다. Bloking 1234567var ccontent = file.read('a.txt');대기 후... // 위의 file.read 작업이 끝나야 밑의 작업들이 마저 실행 됨doShow(contents);var result = doAdd(10, 10); 동기는 프로그램이 어떤 작업을 시작 했을 때 그 작업이 다 끝난 후에야 다른 작업을 할 수 있다.이러한 방식은 프로그램이 실행하는 중간중간 대기 시간이 발생하면서 속도가 느려지는 문제가 생긴다. Non-Blocking 12345file.read(\"a.txt\", contents =&gt; { doShow(contents); // file.read 작업이 끝나면 콜백 함수 실행});var result = doAdd(10, 10); // 다른 작업을 이어 나감 싱글 스레드멀티 스레드인 시스템에서는 여러 개의 스레드가 일을 나눠서 처리할 수 있으나 노드는 싱글 스레드이므로 주어진 작업을 혼자서 처리해야 한다.자바스크립트와 노드에서 논블로킹이 중요한 이유는 바로 싱글 스레드이기 때문이다. 한 번에 한 가지 일밖에 처리하지 못하므로 어떠한 작업에서 블로킹이 발생하면 다음 일을 처리하지 못한다. 노드 프로세스도 내부적으로는 스레드를 여러개 가지고 있다. 하지만 직접 제어할 수 있는 스레드는 하나뿐이므로 싱글 스레드라고 부른다. 싱글 스레드 여러 개를 사용해 멀티 스레딩과 비슷한 기능을 하게 할 수 있다. 하지만 엄밀히 말하면 멀티 스레딩이라기 보다는 멀티 프로세싱에 가깝다. 노드는 스레드를 늘리는 대신 프로세스 자체를 복사해 여러 작업을 동시에 처리하는 멀티 프로세싱 방식을 택했다. 자바스크립트 언어 자체가 싱글 스레드 특성을 띠고 있기 때문이다. 싱글 스레드여서 멀티 스레드 방식보다는 컴퓨터를 적게 사용하는 장점이 있지만 CPU 코어를 하나밖에 사용하지 못하는 단점도 있다. 단일 스레드 이벤트 루프Node.js는 단일 쓰레드 이벤트 루프 모델을 사용한다. 단일 스레드 이벤트 루프 모델 처리 단계 클라이언트가 Node.js 서버에게 Request 를 날린다. Node.js 서버는 내부적으로 제한된 스레드 풀을 유지 관리하여 클라잉언트 요청에 서비스를 제공한다. Node.js 서버는 여러 Request 를 받고 Queue 에 저장한다. 이 Queue 를 이벤트 대기 Queue 라고 한다. Node.js 서버는 내부적으로 Event Loop 를 가지고 있다. (요청을 수신하고 처리하기 위해 무한 루프를 사용하기 때문에 Event Loop 라는 이름을 가지고 있다.) Event Loop 는 단일스레드만 사용한다. 이것이 Node.js 프로세싱 모델의 핵심이다. Event Loop 는 Event Queue 에 Request 가 있는지 체크한다. Event Queue 가 빈 상태라면 Request 를 무기한 기다린다. Request 가 있으면 Event Queue 로 부터 Request 를 꺼내 처리를 시작한다. 만약 Bloking IO 작업을 요구하지 않는 경우라면 Request 를 처리하고 Response 를 준비한 다음 클라이언트에게 보낸다. 데이터베이스, 파일시스템, 외부 서비스와의 상호작용과 같은 Bloking IO 작업을 요구하는 경우라면 다른 접근 방식을 따른다. 내부 스레드 풀에서 스레드 가용성 확인한다. Client Request 를 스레드 하나에 할당한다. 스레드가 해당 요청을 처리하고, 처리하며, IO 작업을 차단하고, 응답을 준비한 후 이벤트 루프로 반환한다. 이벤트 루프가 차례로 해당 응답을 해당 클라이언트에 전송한다. Node.js를 쓰면 좋은 곳노드는 개수는 많지만 크기는 작은 데이터를 실시간으로 주고 받는데 적합하다. 입출력이 잦은 어플리케이션노드는 libuv 라이브러리를 사용하여 I/O 작업을 논블로킹 방식으로 처리하기 때문에 스레드 하나가 많은 수의 I/O를 혼자서도 감당할 수 있다. 데이터 스트리밍 어플리케이션 데이터를 실시간으로 다루는 어플리케이션 JSON API 기반 어플리케이션요즘은 XML 대신 JSON을 사용해서 데이터를 주고 받는데 JSON이 자바스크립트 형식이어서 노드에서는 쉽게 처리할 수 있다. 싱글페이지 어플리케이션노드는 자바스크립트 런타임이기 때문에 용도가 서버에만 한정된 것이 아니라 웹, 모바일, 데스크톱 애플리케이션 개발에도 사용된다. 코드가 CPU 연산을 많이 요구하면 블로킹이 발생해 스레드 하나가 감당하기 어렵기 때문에 CPU 부하가 큰 작업에는 적합하지 않다. Reference Node.js 교과서 [Node.JS] 강좌 01편: 소개 Node JS Architecture – Single Threaded Event Loop-nodejs의 내부 동작 원리 (libuv, 이벤트루프, 워커쓰레드, 비동기)","link":"/2018/07/17/2018-07-12-nodejs-first-nodejs/"},{"title":"컴퓨터 구조 개요","text":"컴퓨터컴퓨터(computer)는 진공관, 트랜지스터 등의 전자 회로를 이용하여 방대한 정보를 저장하고 자동적으로 계산하고 입력된 데이터를 정해진 방법에 따라 처리하는 장치(device)다. (출처: 위키백과) 일반적으로 컴퓨터를 말할 때 시스템이란 용어를 덧붙여 컴퓨터 시스템이라 부른다. 시스템이란 그 시스템에 부여된 목적을 달성하기 위하여 상호작용 하는 구성요소들의 집합으로 정의된다.따라서 컴퓨터를 제대로 이해하기 위해서는 ‘시스템 측면에서 컴퓨터는 무엇으로 구성되어 있는가?’, ‘구성요소는 각각 무슨 기능을 갖는가?’, ‘입력과 출력은 무엇인가?’ 등을 살펴보아야 한다. 컴퓨터 시스템의 전체적 구성12345678910컴퓨터 시스템 ├─ 하드웨어 │ ├─ 입력장치 │ ├─ 출력장치 │ ├─ 기억장치 │ ├─ 중앙처리장치 │ └─ 시스템버스 └─ 소프트웨어 ├─ 시스템 소프트웨어 └─ 응용 소프트웨어 컴퓨터 시스템을 구체적으로 살펴보면 크게 하드웨어와 소프트웨어 측면으로 구분할 수 있다. 하드웨어는 컴퓨터의 기계적인 장치를 의미하며 소프트웨어는 하드웨어를 제어하여 원하는 결과를 얻을 수 있도록 하는 모든 종류의 프로그램을 의미한다.소프트웨어는 컴퓨터에서 사용할 수 있는 명령어들의 조합으로 구현되는데 이를 프로그램이라 부른다. 시스템 소프트웨어는 컴파일러, 어셈블러, 로더, 운영체제 같이 컴퓨터 시스템의 운영을 제어하고 지원하는 프로그램을 말하며 응용 소프트웨어는 워드프로세서, 데이터베이스, 스프레드시트 등과 같이 사용자 편의를 위해 만들어놓은 프로그램을 말한다. 컴퓨터 하드웨어 구성요소입력장치컴퓨터는 사용자로부터 데이터를 명령어와 함께 받아들여서 그 명령어에 따라 데이터를 처리하는 기계이다. 이때 입력장치란 사용자가 입력하는 데이터와 명령어를 받아들여 컴퓨터가 알 수 있는 형태로 변환하여 기억장치나 중앙처리장치에 전달해 주는 장치를 말한다.기본적인 입력장치로 키보드를 사용한다. 키보드상의 문자 각각에 해당되는 키를 누르면 이에 대응하는 전기적 신호가 컴퓨터로 전달된다. 다른 입력장치로는 마우스, 마이크, 스캐너 등이 있다. 출력장치컴퓨터는 입력장치로부터 데이터와 명령어를 받아들여서 그 명령대로 데이터를 처리하고 이에 대한 결과를 생성시킨다. 출력장치란 이렇게 생성된 결과를 사람이 알아볼 수 있는 형태로 변환해 주는 장치를 말한다.최근 가장 많이 사용되고 있는 출력장치로는 LCD(Liquid Crystal Display)가 있는데 이것은 인가전압에 따른 액정의 투과도 변화를 이용하여 각종 장치에서 발생되는 여러가지 전기적인 정보를 시각정보로 변화시켜 전달하는 방법을 주로 사용한다. 또다른 출력장치로는 데이터를 화면이 아니라 종이에 나타내 보여주는 프린터가 있다. 기억장치입력장치로부터 컴퓨터 내부로 전달되는 모든 데이터는 2진수로 바뀌어 기억장치에 저장된다. 데이터 저장 역할을 하는 기억장치는 그 특성과 역할에 따라 캐시와 주기억장치, 그리고 보조기억장치로 나뉜다. 주기억장치주기억장치는 컴퓨터에서 중앙처리장치가 처리할 데이터와 명령어들을 저장한다. 대표적으로 RAM과 ROM이 있다. RAM: 전원이 공급되는 동안에는 데이터를 계속 기억하고 있으나 전원 공급이 끊기면 기억된 내용이 없어지는 휘발성 기억장치이다. SRAM: 일단 기억소자에 정보가 저장되면 전원이 유지되는 한 그 데이터를 상실하지 않는다. DRAM: 전원이 공급되는 동안에도 일정 주기로 충전을 해주어야 데이터를 상실하지 않기 떄문에 DRAM을 채용한 컴퓨터 시스템에서는 재충전이 필요한 하드웨어 회로가 포함된다. 특수한 경우를 제외하면 대부분 가격이 저렴한 DRAM으로 구성되며 이러한 DRAM은 데이터를 처리하는 중앙처리장치에 비해 속도가 매우 느리므로 중앙처리장치는 주기억장치에서 데이터를 가져올 때 시간이 많이 낭비된다. ROM: 전원 공급이 끊겨도 이전의 정보가 계속 기억되는 비휘발성 기억장치이다. 캐시주기억장치의 단점을 해결하기 위해 데이터가 중앙처리장치에 신속하게 전달될 수 있도록 하기 위해 사용되는 주기억장치와 중앙처리장치 사이에 위치한 기억장치를 캐시라고 한다. 캐시는 일반적으로 가격이 비싸고 부피가 큰 대신 매우 빠른 SRAM으로 구성되며 보통 수백 MB까지의 용량을 갖는다. 보조기억장치캐시나 주기억장치는 전원이 꺼지면 현재까지 저장한 내용을 잃어버린다. 컴퓨터 사용자가 현재 기억장칭에 저장한 내용을 전원을 끄고 난 다음에도 사용할 수 있도록 해주는 기억장치를 보조기억장치라 한다. 대량의 데이터를 저장하기 위해 사용하며 자기디스크와 자기테이프, CD-ROM 등이 있다. 중앙처리장치중앙처리장치는 컴퓨터의 두뇌에 해당하는 부분이다. 산술/논리연산장치산술/논리연산장치는 중앙처리장치의 가장 중요한 요소로서 사칙연산을 포함한 산술연산과 참과 거짓을 판별하는 논리연산을 수행하는 장치이다. 제어장치제어장치는 중앙처리장치 내부에서 일어나는 모든 동작을 제어하고 관리하는 장치이다. 기억장치로부터 명령을 읽고 해석하여 해석된 결과에 따라 명령을 수행하기 위한 제어신호를 만드는 장치이다. 레지스터레지스터는 중앙처리장치에 있는 내부기억장치로서 연산처리를 위한 데이터나 결과 등을 일시적으로 보관해두는 장치이다. 고속의 연산처리나 편리한 프로그래밍에 도움을 주지만 가격이 비싸므로 중앙처리장치 내의 레지스터의 수는 제한적이다. 시스템버스컴퓨터 구조에서 버스란 두 개 이상의 장치를 연결해 주는 통신선로를 말한다. 일반적으로 하나의 버스는 여러 개의 통신선으로 구성되어 있고 각 선은 2진수 0과 1로 표현되는 신호를 전송할 수 있다. 따라서 한 버스가 8개의 선으로 구성된 경우에는 8개의 신호를 동시에 전송할 수 있다.컴퓨터 시스템은 다양한 시스템 계층에서의 구성요소들 간에 통신을 가능하게 하는 많은 종류의 버스를 포함하고 있다. 이러한 버스의 종류 중 입력장치와 출력장치, 기억장치, 중앙처리장치를 연결해주는 버스를 시스템버스라고 한다. 이러한 시스템버스는 전송되는 데이터가 의미하는 내용에 따라 주소버스, 데이터버스, 제어버스로 구분된다. 컴퓨터 시스템의 분류마이크로컴퓨터마이크로컴퓨터는 가장 널리 사용되고 있는 범용 컴퓨터로서 연산장치, 제어장치, 기억장치, 입출력장치 등을 하나의 칩으로 만든 마이크로 프로세서를 중앙처리장치로 채택한 컴퓨터로서, 단일 칩 마이크로 컴퓨터라고 한다. 대표적으로 PC(Personal Computer)가 있다. 미니컴퓨터미니컴퓨터는 외형적으로 마이크로컴퓨터보다 조금 크고, 메인프레임 컴퓨터 보다는 작은 컴퓨터로 단위부서와 같은 작은 규모의 조직에서 사용할 수 있는 소규모 컴퓨터이다. 슈퍼 미니컴퓨터가 등장하면서 많은 범용 컴퓨터의 응용을 흡수하였고 컴퓨팅 서버, 파일 서버, 네트워크 서버 등 각종 서버의 등장으로 인해 도태되었다. 메인프레임 컴퓨터메인프레임 컴퓨터는 고속의 입출력 처리능력을 가지고 있으며 대용량의 저장장치를 보유한 컴퓨터이다. 대규모의 데이터베이스 저장 및 관리용으로 사용된다. 슈퍼 컴퓨터슈퍼컴퓨터는 병렬처리가 가능한 복잡한 구조로 되어 있으며 복잡한 연산을 초고속으로 계산하기 위한 컴퓨텅이다. 이 컴퓨터는 아주 복잡한 과학 계산을 위한 것으로 연산속도가 무엇보다 중요하다. 환경, 에너지, 우주 및 항공, 지원탐사 등에 응용된다. 파이프라인 슈퍼컴퓨터파이프라인 슈퍼컴퓨터는 1개의 중앙처리장치 내에 다수 개의 연산장치를 갖고 있는 컴퓨터로서 각 연산장치는 파이프라이닝 구조를 이용하여 고속의 벡터 계산이 가능하다. 대규모 병렬처리 컴퓨터대규모 병렬처리 컴퓨터는 하나의 시스템 내에 상호 연결된 수백 혹은 수천개 이상의 처리장치를 갖고 있으며 처리장치들이 하나의 큰 작업을 나누어서 병렬로 처리하는 구조를 갖는다.","link":"/2018/09/16/2018-10-03-computer-architecture-first/"},{"title":"TypeScript로 생성한 React 프로젝트에서 테스트 환경 구축 및 테스트 실행하기","text":"개인 프로젝트를 작업 하고 있던 도중 테스트 환경을 도입해보고 싶어서 열심히 끄적이다가 기록을 남기기로 했다.TypeScript로 생성된 React 프로젝트에 테스트 환경 을 구축 해보고 테스트 까지 한번 해보자. 해당 프로젝트는 create-react-app 으로 생성되었다. 테스트 환경 설정123yarn add --dev jest @types/jestyarn add --dev enzyme enzyme-adapter-react-16yarn add --dev @types/enzyme @types/enzyme-adapter-react-16 먼저 테스트에 필요한 모듈들을 설치해주자. TypeScript 환경이기 때문에 각 모듈들의 @types도 설치해줘야 한다. 1yarn add --dev enzyme-to-json @types/enzyme-to-json 스냅샷의 가독성을 위해 enzyme-to-json 모듈도 설치하였다. setupTest.ts1234import * as Enzyme from \"enzyme\";import ReactSixteenAdapter from \"enzyme-adapter-react-16\";Enzyme.configure({ adapter: new ReactSixteenAdapter() }); CRA로 만든 프로젝트라면 위의 소스 파일 처럼 테스트 설정을 해줘야 한다.테스트 파일 작성 중 계속 오류가 발생하길래 리서치를 하던 도중 여기에서 제시했던 대로 파일을 작성하니 정상 작동 되었다. package.json123456789101112{// ... 생략\"jest\": { // ... 생략 \"setupTestFrameworkScriptFile\": \"&lt;rootDir&gt;/test/setupTest.ts\", \"snapshotSerializers\": [ \"enzyme-to-json/serializer\" ], // ... 생략 },// ... 생략} package.json 파일에 위에처럼 enzyme, enzyme-to-json을 위한 설정만 추가해주면 설정은 끝난다. 컴포넌트 작성123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import * as React from \"react\";import classNames from \"classnames\";import Portal from \"react-minimalist-portal\";import ReactCSSTransitionGroup from \"react-addons-css-transition-group\";import \"./Modal.scss\";interface ModalProps { backdropClassName: string; children: React.ReactNode; modalClassName: string; isOpen: boolean; onClose: any; size: string;}interface ModalStates { isOpen: boolean;}export default class Modal extends React.Component&lt;ModalProps, ModalStates&gt; { public static defaultProps = { backdropClassName: \"\", children: null, modalClassName: \"\", isOpen: false, onClose: () =&gt; {}, size: \"sm\" }; handleIgnoreEvent: any = event =&gt; { event.stopPropagation(); }; handleClose: any = event =&gt; { event.stopPropagation(); this.props.onClose(); }; render(): JSX.Element { const { backdropClassName, children, isOpen, modalClassName, onClose, size } = this.props; if (!isOpen) { return null; } return ( &lt;Portal&gt; &lt;div className={classNames( \"modal-backdrop\", { open: isOpen }, backdropClassName )} onClick={onClose} &gt; &lt;ReactCSSTransitionGroup transitionName=\"example\" transitionAppear={true} transitionAppearTimeout={300} transitionLeave={true} transitionEnterTimeout={300} transitionLeaveTimeout={500} &gt; &lt;div className={classNames(\"modal\", modalClassName, size)} onClick={this.handleIgnoreEvent} &gt; &lt;button type=\"button\" onClick={onClose}&gt; 닫기 &lt;/button&gt; {children} &lt;/div&gt; &lt;/ReactCSSTransitionGroup&gt; &lt;/div&gt; &lt;/Portal&gt; ); }} 간단하게 모달 컴포넌트를 작성했다. 이 모달 컴포넌트를 테스트 해 볼 것이다. 테스트코드 작성123456789101112131415161718192021222324252627import * as React from \"react\";import * as Enzyme from \"enzyme\";import Modal from \"./Modal\";describe(\"&lt;Modal /&gt;\", () =&gt; { let component = null; let isOpen = true; // 모달 컴포넌트 랜더링 it(\"Modal Render...\", () =&gt; { component = Enzyme.shallow( &lt;Modal backdropClassName=\"test-backdrop\" modalClassName=\"test-modal\" isOpen={isOpen} size=\"sm\" onClose={() =&gt; { isOpen = false; }} &gt; &lt;div&gt;Modal Test&lt;/div&gt; &lt;/Modal&gt; ); expect(component).toMatchSnapshot(); });}); 맨 먼저 스냅샷 테스트코드를 작성했다. describe는 테스트 무리를 가지고 있는 함수이다. 두개의 parameter를 받는데 첫번째는 테스트에 붙이는 의미있는 이름이고 두번째는 여러개의 테스트를 포함한 함수이다. descirbe는 중첩해서 사용할 수도 있다. it은 테스트 자체가 되는 함수 이며 두개의 parameter를 받는다. 첫번째는 test의 이름이고 두번째는 테스트의 본문을 유지한다. expect는 여러 가지 유효성 검사기에 대한 액세스를 제공하여 여러 가지를 검증한다. shallow는 Enzyme에서 제공하는 rendering API 이다. rednering API에는 mount, render가 더 있는데 각각 작동하는 방식이 다르므로 상황에 맞춰서 알맞은 것을 골라서 사용하면 된다. 12345678910111213141516171819describe(\"&lt;Modal /&gt;\", () =&gt; { // ... 생략 // 모달이 닫겨 있을 때 it(\"Modal close...\", () =&gt; { component.setProps({ isOpen: false }); expect(component.find(\".modal-backdrop\").exists()).toBe(false); }); // 모달이 열려 있을 때 it(\"Modal open...\", () =&gt; { component.setProps({ isOpen: true }); expect(component.find(\".modal-backdrop\").exists()).toBe(true); }); // ... 생략}); isOpen props를 받아서 모달의 출력 여부를 판단하므로 isOpen의 값에 따라 모달이 존재 하는지 안하는지 확인하는 테스트 코드를 작성 했다.isOpen이 false 일 때는 컴포넌트의 render 함수가 null을 리턴하므로 false 값이 나와야 하고 isOpen이 true 일 때는 모달이 정상적으로 출력되므로 true 값이 나와야 한다. toBe 메소드는 값이 예상한 값인지 확인한다. find 메소드는 인자로 받은 selector을 통하여 컴포넌트 안에서 특정 DOM을 찾을 수 있게 해준다. exists 메소드는 찾는 노드나 selector의 존재 유무를 판단해준다. setProps 메소드로 root 컴포넌트의 props를 설정하고 재랜더링 할 수 있다. 1234567891011121314151617181920212223242526272829303132describe(\"&lt;Modal /&gt;\", () =&gt; { // ... 생략 // 모달이 열려 있을 때 it(\"Modal open...\", () =&gt; { component.setProps({ isOpen: true }); expect(component.find(\".modal-backdrop\").exists()).toBe(true); }); // 모달 안을 클릭 했을 때 it(\"Modal click...\", () =&gt; { component.find(\".modal\").simulate(\"click\", { stopPropagation() {} }); const lastChild = component .find(\".modal\") .children() .last(); console.log(lastChild.debug()); lastChild.simulate(\"click\", { stopPropagation() {} }); expect(component.find(\".modal\").exists()).toBe(true); }); // 모달 닫기 버튼을 눌러 닫을 때 it(\"Modal is closing...\", () =&gt; { component.find(\"button\").simulate(\"click\"); expect(component.find(\".modal-backdrop\").exists()).toBe(false); });}); 이벤트가 발생했을 때 컴포넌트가 원하는 대로 작동하는지 확인하는 테스트 코드를 작성했다.모달이 출력되었을 때 모달 및 모달 안의 자식 DOM들을 클릭했을 때도 모달이 닫기면 안되기 때문에 모달 안의 DOM을 눌렀을 떄 모달이 닫기는지 안닫기는지 테스트 하고 있다.모달 안에서 닫기 버튼을 눌렀을 때는 모달이 닫겨야 하므로 버튼 테스트도 작성했다.모달 안의 DOM을 클릭 할 때 stopPropagation 이벤트가 발생하므로 가짜 함수를 추가 하였다.(참조) debug 메소드는 디버깅 목적으로 HTML과 유사한 wrapper 문자열을 반환한다. simulate 메소드는 이벤트를 시뮬레이션 한다. 첫번째 파라미터는 시뮬레이터 할 이벤트 이름을 넣고 두번째 파라미터에는 이벤트에 전달 되는 모의 이벤트 객체가 들어간다. 테스트1yarn run test 위의 명령어로 테스트를 실행할 수 있다. 테스트를 실행하면 스냅샷 폴더가 생긴다. 1234567891011121314151617181920212223242526272829303132333435// Jest Snapshot v1, https://goo.gl/fbAQLPexports[`&lt;Modal /&gt; Modal Render... 1`] = `&lt;Portal&gt; &lt;div className=\"modal-backdrop open test-backdrop\" onClick={[Function]} &gt; &lt;CSSTransitionGroup transitionAppear={true} transitionAppearTimeout={300} transitionEnter={true} transitionEnterTimeout={300} transitionLeave={true} transitionLeaveTimeout={500} transitionName=\"example\" &gt; &lt;div className=\"modal test-modal sm\" onClick={[Function]} &gt; &lt;button onClick={[Function]} type=\"button\" &gt; 닫기 &lt;/button&gt; &lt;div&gt; Modal Test &lt;/div&gt; &lt;/div&gt; &lt;/CSSTransitionGroup&gt; &lt;/div&gt;&lt;/Portal&gt;`; 이런식으로 스냅샷이 생성된다. 테스트에 성공하면 위의 스샷 처럼 성공 메시지들이 출력된다.debug로 child elements가 제대로 출력되는지 console.log를 찍었기 떄문에 console.log 결과물이 같이 출력되었다. 테스트에 실패하면 실패한 테스트 코드 위치와 원하는 테스트 값, 실제로 나온 테스트 결과값을 보여준다. 마무리테스트코드를 작성해본건 이번이 처음이라 틀린 부분이 있을 수도 있다 ㅠ. 이번 포스팅을 기회로 테스트 습관을 들이도록 노력해봐야겠다. 수정해야 할 부분이나 보완되어야 할 부분이 있으면 언제든 피드백 부탁드립니다. 소스 코드 전체 보기 ReferenceTesting with TypeScript, Enzyme, and ReactEnzyme[React] 테스팅 코드 작성하기","link":"/2019/02/14/2019-02-11-typescript-react-test/"},{"title":"선택 문제","text":"선택 문제n개의 원소가 임의의 순서로 저장된 배열에서 i번째로 작은 원소를 찾는 문제. i = 1 이면 최솟값. i = n/2 이면 중간값. i = n 이면 최댓값. 직관적인 방법으로는 오름차순으로 정렬한 후 i 번째 원소를 찾으면 되는데 이떄 성능은 o($n log n$)이다.또 다른 직관적인 방법으로는 최솟값 찾는 과정을 i번 반복한다. i-1번째까지는 최솟값을 찾은 후 삭제한다. 이 경우에는 최솟값을 찾는데 걸리는 사긴 O(n)을 i번 반복하기 때문에 성능은 O(in)이다. 최솟값 찾기각 데이터를 하나씩 모드 비교한다. 1234567891011int findMinimum (int arr[], int length) { int min = arr[0]; for (int i = 1; i &lt; length; i++) { if (arr[i] &lt; min) { min = arr[i]; } } return min;} n개의 데이터에서 대해서 최소한 length - 1번의 비교가 필요하므로 성능은 O(n)이다. 최솟값과 최대값 모두 찾기.최솟값과 최댓값을 모두 찾으려면 최솟값을 찾은 후에 최댓값을 찾거나 최댓값을 찾은 후 최솟값을 찾으면 된다. 1234567891011121314151617181920212223242526272829303132333435void findMinMax(int arr[], int length) { int min = arr[0]; int max = arr[1]; // arr[0]과 arr[1]을 사용하여 최솟값/최댓값 초기화. if (min &gt; max) { max = arr[0]; min = arr[1]; } for(int i = 2; i &lt; length; i += 2) { int small = 0, large = 0; // 두 데이터 중에서 작은 값과 큰 값을 결정. if (i &lt; length &amp;&amp; i + 1 &lt; length &amp;&amp; arr[i] &lt; arr[i + 1]) { small = arr[i]; large = arr[i + 1]; } else { small = arr[i + 1]; large = arr[i]; } // 작은 값과 최솟 값을 비교. if (small &lt; min) { min = small; } // 큰 값과 최댓 값을 비교. if (large &gt; max) { max = large; } } printf(\"최댓값: %d, 최솟값: %d\\n\", max, min);} 위의 알고리즘을 이용하면 $(3/2 * n) - 2$번의 비교를 통해서 최솟값과 최댓값을 동시에 찾을 수 있다. i번째로 작은 원소 찾기: 최악 $O(n^2)$, 평균 O(n)퀵 정렬의 분할 함수 Partition()을 이용하면 모든 원소를 정렬하지 않고도 i번째로 작은 원소를 구할 수 있다. i = j 일때 피벗이 찾고자 하는 i 번째 원소. i &lt; j 일때 왼쪽 부분배열에 대해 순환 적용. i &gt; j 일때 오른쪽 부분배열에 대해 순환 적용. 분할피벗을 기준으로 주어진 배열을 두 부분배열로 분할한다. i가 피벗의 인덱스와 같으면 피벗의 값을 반환하고 종료한다. 정복인덱스 i가 포함된 부분배열에 대해서 선택 알고리즘을 순환적으로 적용한다. 결합필요 없다. 알고리즘1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void swap(int arr[], int a, int b) { int temp = arr[a]; arr[a] = arr[b]; arr[b] = temp;}// 퀵정렬에 사용된 분할 함수를 그대로 사용하면 된다.int partition(int arr[], int leftIndex, int rightIndex) {// 맨 왼쪽을 피벗으로 잡기 때문에 l_hold는 피벗의 위치 + 1, r_hold는 배열의 마지막 index int pivot = arr[leftIndex], l_hold = leftIndex + 1, r_hold = rightIndex; while (l_hold &lt;= r_hold) { // l_hold는 피벗보다 큰 값을 찾는다. while (l_hold &lt;= rightIndex &amp;&amp; arr[l_hold] &lt; pivot) { l_hold++; } // r_hold는 피벗보다 작은 값을 찾는다. while (r_hold &gt; leftIndex &amp;&amp; arr[r_hold] &gt;= pivot) { r_hold--; } if (l_hold &lt; r_hold) { // arr[l_hold]와 arr[r_hold]의 값을 교환한다. swap(arr, l_hold, r_hold); } } // 피벗과 arr[r_hold]값을 교환한다. swap(arr, leftIndex, r_hold); return r_hold;}int findNumber(int arr[], int leftIndex, int rightIndex, int findNum) { int pivot = partition(arr, leftIndex, rightIndex); // 두 부분배열로 분할 if (findNum == pivot) { return arr[pivot]; } if (findNum &lt; leftIndex) { // 왼쪽 부분배열에 대해 순환호출 return findNumber(arr, leftIndex, pivot - 1, findNum); } else { // 오른쪽 부분배열에 대해서 순환호출 return findNumber(arr, pivot + 1, rightIndex, findNum); }} 성능분석최악의 경우 = 퀵 정렬의 최악의 경우 분할 함수가 항상 하나의 부분배열만 생성하는 경우. 오름차순으로 정렬된 상태에서 i = n을 찾는 경우. 분할 함수 호출할 떄 마다 피벗의 인덱스는 1씩 증가. -&gt; Partition()을 O(n)번 호출. O($n^2$). 해결책은 항상 일정한 비율의 두 부분배열로 분할 시키면 된다. 평균적인 경우에는 O(n). i번째로 작은 원소 찾기: 최악 O(n), 평균 O(n)특정한 성질을 만족하도록 피벗을 선택하되 항상 일정한 비율의 두 부분배열로 분할 시킨다. 그러면 항상 하나의 부분배열만으로 분할되는 문제를 피하여 최악의 수행 시간 O($n^2$)를 개선할 수 있다. 피벗 선택 방법 크기가 n인 배열의 원소를 5개씩 묶어 $n/5$개의 그룹을 형성한다. 이떄 n이 5의 배수가 되지 않아 그룹을 형성하지 못한 채 남은 원소들은 그대로 남겨둔다. 각 그룹에 대해서 중간 값을 찾는다. $n/5$개의 중간값들을 대상으로 다시 중간값을 찾는다. 이렇게 계산된 ‘중간값들의 중간값’을 피벗으로 사용하여 주어진 배열을 분할한다. 알고리즘1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// 삽입 정렬 함수void insertionSort(int arr[], int leftIndex, int rightIndex){ int i, j, key; for(i = leftIndex + 1; i &lt;= rightIndex; i++){ key = arr[i]; // 현재 삽입될 숫자인 i번째 정수를 key 변수로 복사 // 현재 정렬된 배열은 i-1까지이므로 i-1번째부터 역순으로 조사한다. // j 값은 음수가 아니어야 되고 // key 값보다 정렬된 배열에 있는 값이 크면 j번째를 j+1번째로 이동 for(j=i-1; j&gt;=0 &amp;&amp; arr[j]&gt;key; j--){ arr[j+1] = arr[j]; // 레코드의 오른쪽으로 이동 } arr[j+1] = key; }}// 분할 함수int partition(int arr[], int leftIndex, int rightIndex, int pivot) { int swapIndex = leftIndex; for (int i = leftIndex; i &lt;= rightIndex; i++) { if (arr[i] &lt; pivot) { int temp = arr[i]; arr[i] = arr[swapIndex]; arr[swapIndex] = temp; swapIndex += 1; } } return swapIndex - 1;}int selection (int arr[], int leftIndex, int rightIndex, int findIndex) { int arrLength = rightIndex - leftIndex + 1; int medianNum = arrLength / 5; if (0 &gt; findIndex &amp;&amp; findIndex &gt; arrLength) { return -1; } // 배열의 길이가 5보다 같거나 작으면 findIndex - 1번째 원소를 찾아 봔한한다. if (arrLength &lt;= 5) { insertionSort(arr, leftIndex, rightIndex); return arr[findIndex - 1]; } int *maidanArr = (int *) malloc(sizeof(int) * medianNum); // 배열 arr에서 5개씩 원소를 묶어 n/5 개의 그룹을 만든 후 각 그룹에서 중간값을 구해 배열 maidanArr을 만든다. for (int i = 0; i &lt; medianNum; i++) { maidanArr[i] = selection(arr, leftIndex + (5 * i), (leftIndex + (5 * (i+1)-1)), leftIndex + (5 * i) + 2); } // 중간값들의 중간값을 계산하기 위해 선택 함수를 순환호출한다. int pivot = selection(maidanArr, 0, medianNum - 1, (medianNum / 2) + 1); // pivot을 사용하여 배열 arr을 분할한다. int pivotIndex = partition(arr, leftIndex, rightIndex, pivot); int rank = pivotIndex - leftIndex + 1; if (findIndex &lt;= rank) { return selection(arr, leftIndex, pivotIndex, findIndex); } else { return selection(arr, pivotIndex + 1, rightIndex, findIndex); }} Reference방송대 컴퓨터과학과 알고리즘 4강프로그래밍 면접 문제 10 : Kth Largest Element in Array","link":"/2019/05/10/2019-03-17-algorithms-selection/"},{"title":"소프트웨어","text":"소프트웨어컴퓨터 프로그램과 관련 데이터의 묶음.포괄적 의미에서 소프트웨어란 소스 코드는 물론 모든 관련 문서까지 포함하는데 실행 파일, 설계 문서, 설치 파일, 시스템 메뉴얼과 설치 메뉴얼 및 사용자가 소프트웨어를 사용하는 데 도움을 주도록 작성된 사용자 메뉴얼 등을 포함한다. 국제전기전자공학회(IEEE)의 정의에 따르면 소프트웨어는 컴퓨터 프로그램, 프로시저의 규칙, 관련된 문서와 데이터의 묶음이다. 소프트웨어의 중요성 사업체의 의사결정을 지원하는 엔진이다. 현대적 과학 탐구와 공학적 문제 해결을 지원하는 기본 도구이다. 교통, 의료, 원거리 통신, 군사. 산업체 등에 사용되는 모든 종류의 컴퓨터 시스템에 내장되어 있다. 이렇게 소프트웨어가 사회와 문화에 주는 영향력은 점점 커지고 있다. 소프트웨어의 분류기능적 측면시스템 소프트웨어컴퓨터를 운영하기 위한 목적의 소프트웨어로 응용 소프트웨어를 실행시키기 위한 플랫폼을 제공한다. ex) 운영체제, 장치 드라이버, 컴파일러, DBMS, 유틸리티 프로그램 등… 응용 소프트웨어사용자의 실제 업무를 수행하는 프로그램들로 특정 용도에 사용되도록 만들어진 것. ex) 워드프로세서, 스프레드시트, 웹 브라우저, 그래픽처리 프로그램, 게임 프로그램 및 데이터베이스 관리 시스템 등… 고객 측면일반 소프트웨어요구사항이 매우 일반적이고 안정적이며, 소프트웨어 엔지니어가 사용 용도를 잘 알고 있는 경우에 불특정 다수를 대상으로 설게된 소프트웨어.공개 시장에서 판매되며 다수의 경쟁 제품이 있을 수 있다. ex) 데이터베이스 관련 제품, 워드프로세서, 사무용 소프트웨어 패키지, ERP/CRM 패키지, 운영체제 등… 맞춤형 소프트웨어응용 도메인, 사용 환경 및 요구사항이 특별한 고객을 위해 개발되는 맞춤 소프트웨어.특정 산업에서 나타나는 고유의 업무 프로세스를 위해 작성된다. ex) 프로세스 제어 시스템, 교통 관제 시스템, 병원 관리 시스템 등… 소프트웨어의 성질 소프트웨어는 무형의 인공물이머 물질적인 성질을 가지지 않는다. 물질적인 성질을 가지는 하드웨어와는 그 특성이 다르다. 대부분의 소프트웨어는 기존 컴포넌트들의 조립을 통해 만들어지지 않고 요구사항에 맞추어 새롭게 만들어진다. 소프트웨어에 대한 요구사항이 매우 복잡하기 때문에 기존 컴폰넌트를 조립하여 새로운 요구사항을 만족시키기는 매우 어렵다. 최근에는 ‘CBD(Component Based Development) 분석 방법론’이라고 컴포넌트 기반의 개발 방법이 있긴 하다. 설계 과정의 품질 보등 활동이 소프트웨어의 결정적인 요소가 된다. 소프트웨어 개발 비용의 대부분이 노동력에 투입된다. 소프트웨어는 상대적으로 변경이 용이하다. 이것을 ‘소프트웨어의 유연성 또는 순응성’이라고 한다. 소프트웨어는 마모디지 않는다. 그러나 환경의 변화나 새로운 요구사항의 등장 또는 기대 수준의 향상으로 인해 폐기될 수 있다. 소프트웨어 유지보수는 하드웨어와 달리 많은 경우에 설계의 변경이 요구 된다. 소프트웨어의 응용 분야시스템 소프트웨어다른 소프트웨어를 지원할 목적으로 시스템상에서 실행되는 프로그램.시스템 소프트웨어가 존재하지 않는다면 컴퓨터 시스템은 작동될 수 없다. 실시간 소프트웨어이벤트 발생과 처리가 실시간으로 이루어지는 시스템. ex) 은행 업무 시스템, 좌석 예약 시스템 등… 내장형 소프트웨어대형 시스템의 일부로 하드웨어에 내장되어 특정 조건하에서 고유의 기능을 수행하도록 작성된 소프트웨어.자동차, 세탁기, 전자레인지, 주유기, 인공위성 및 많은 자동 제어 시스템에 내장된 소프트웨어. 비즈니스 소프트웨어사업 목적의 업무를 처리하기 위해 설계된 소프트웨어. ex) 회계 업무 패키지, 경영 정보 시스템, 급여 관리 패키지 및 재고 관리 목적의 소프트웨어 등… 개인용 소프트웨어개인 사용자를 위한 소프트웨어. ex) 워드 프로세서, 스프레드시트, 그래픽 프로그램, 멀티미디어, 오락 프로그램, 네트워크 유틸리티 등… 인공지능 소프트웨어단순한 수치게산이나 정형적인 프로시저를 사용하지 못하는 복잡한 문제를 해결하기 위한 소프트웨어. ex) 로보틱스, 전문가 시스템, 화상/음성 인식, 인공 신경망, 정리 증명 등… 웹 기반 소프트웨어웹 브라우저에서 표현되거나 실행되는 소프트웨어. 공학용/과학용 소프트웨어공학이나 과학 분야의 특정 원리나 공식을 사용하여 해당 분야의 특정 기능을 수행하도록 설계된 소프트웨어. 좋은 소프트웨어의 기준소프트웨어의 특성을 좌우하는 여러 품질 기준이 존재한다.사용성이나 신뢰도와 같이 사용자가 인지할 수 있는 것을 ‘외부 품질’ 이라고 한다.‘내부 품질’의 향상은 개발자가 외부 품질을 개선하는데 도움을 줄 수 있다. 잘 작성된 요구사항이나 설계 문서는 보통의 사용자가 볼 수는 없으나 대부분의 외부 품질 요소들을 개선할 때 반드시 필요한 것이다. 소프트웨어의 신뢰도사용자가 소프트웨어를 신뢰하는 정도를 의미한다.오랜 시간 작동되며, 알려진 치명적 오류가 없으며, 오류발생 후에 무난히 복구되며, 강건하다는 의미를 포함한다. 일반적으로 행위 분석을 통한 통계값으로 신뢰도를 측정한다. 다른 방법으로는 고장 확률 또는 고장 빈도를 시간 함수로 정의하는 것이다. 소프트웨어는 시간에 지남에 따라 오류 발견 및 수정으로 고장 빈도는 꾸준히 감소되면서 안정 상태가 되고 폐기될 때까지 유지된다. 그러나 경우에 따라 소프트웨어 고장 함수가 욕조 곡선과 유사한 형태를 가지는 경우가 있다. 욕조 곡선: 시스템 안전 공학 용어로써 고장률 유형을 설명하는데 이용된다. 소프트웨어 버그를 수정하거나 새로운 기능을 추가하면서 생기는 사이드 이펙트. 엔지니어가 예상하지 못했던 하드웨어나 운영체제를 변경하는 경우. 사용자가 소프트웨어에 익숙해지면서 적정 용량이나 성능을 초과하는 입력을 주어 소프트웨어가 스트레스를 받게 되고, 그때 충분히 테스트되지 못한 기능들이 사용되어 오류가 발생하기 때문. 소프트웨어의 정확성명세서와 일치하게 작동하는 능력.사용자의 요구를 만족시키는 능력. 소프트웨어의 행위가 요구사항에 비추어 아주 작은 차이가 있는 경우에 이것은 결함으로 간주되고 소프트웨어는 정확하지 못하다는 뜻이 된다. 그러나 이런 경우가 무조건 소프트웨어의 실제 고장으로 연결되지는 않고 따라서 신뢰도가 있다고 판단될 수 있다. 소프트웨어의 성능지정된 시간 안에 컴퓨터 시스템에서 처리할 수 있는 작업량.주어진 시간 동안에 보다 많은 작업을 수행할 수 있는 경우에 성능이 높다고 한다. 소프트웨어의 사용성시스템을 본래의 설계 목적에 따라 효율성 있게 사용할 수 있는 정도를 의미한다. 소프트웨어의 상호운영성소프트웨어 시스템이 다른 시스템과 공존하며 협력할 수 있는 능력을 의미한다. 소프트웨어의 유지보수성소프트웨어는 유연하기 때문에 변경되기 쉽다.상대적으로 변경시키기 쉬운 소프트웨어가 유지보수성이 높다고 한다. 유지보수 작업은 새로운 기능 추가, 기존 기능의 개선, 환경의 변화에 따른 기존 기능의 수정, 그리고 존재하는 오류를 수정하는 경우로 나누어 생각할 수 있다. 소프트웨어의 이식성다른 환경에서 쉽게 동작이 가능하다면 소프트웨어의 이식성이 좋다고 한다. 소프트웨어에서 환경이란 소프트웨어가 탑재되는 하드웨어, 운영체제 또는 상호작용하는 다른 시스템을 말한다. 소프트웨어의 검사성다른 기술 품질 요소들을 포함하여 소프트웨어의 속성들을 쉽게 검사할 수 있는 경우에 검사성이 좋다고 한다. 검사성을 측정하는 손쉬운 방법 중 하나는 성능이나 정확성과 같은 품질 요소를 검사하기 위한 코드를 삽입하는 것이다. 소프트웨어의 추적성요구사항 변경을 처리하기 위해서는 특정 요구사항을 제안한 관련자와 제안 이유, 이것에 영향받는 다른 요구사항들, 그리고 어느 설계 문서와 어느 소스 코드에 반영되었는지 파악 할 수 있어야 한다. 요구사항으로부터 요구사항을 제안한 관련자를 파악. 관련성이 있는 요구사항들을 파악. 요구사항으로부터 관련 설계 문서를 파악. 설계 문서로부터 관련 코드 조각을 파악. 요구사항으로부터 테스트 계획서를 파악. 테스트 계획서로부터 테스트 케이스를 파악. Reference방송대 컴퓨터과학과 소프트웨어 공학 1강","link":"/2019/03/23/2019-03-23-software-engineering-first/"}],"tags":[{"name":"Computer Architecture","slug":"Computer-Architecture","link":"/tags/Computer-Architecture/"},{"name":"React.js","slug":"React-js","link":"/tags/React-js/"},{"name":"Data structure","slug":"Data-structure","link":"/tags/Data-structure/"},{"name":"Operating systems","slug":"Operating-systems","link":"/tags/Operating-systems/"},{"name":"Algorithms","slug":"Algorithms","link":"/tags/Algorithms/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Compiler","slug":"Compiler","link":"/tags/Compiler/"},{"name":"etc","slug":"etc","link":"/tags/etc/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"Software engineering","slug":"Software-engineering","link":"/tags/Software-engineering/"},{"name":"Information network","slug":"Information-network","link":"/tags/Information-network/"},{"name":"Computer security","slug":"Computer-security","link":"/tags/Computer-security/"}],"categories":[{"name":"Base","slug":"Base","link":"/categories/Base/"},{"name":"Computer Architecture","slug":"Base/Computer-Architecture","link":"/categories/Base/Computer-Architecture/"},{"name":"Data Structure","slug":"Base/Data-Structure","link":"/categories/Base/Data-Structure/"},{"name":"Operating systems","slug":"Base/Operating-systems","link":"/categories/Base/Operating-systems/"},{"name":"Algorithms","slug":"Base/Algorithms","link":"/categories/Base/Algorithms/"},{"name":"Front-end","slug":"Front-end","link":"/categories/Front-end/"},{"name":"Back-end","slug":"Back-end","link":"/categories/Back-end/"},{"name":"JavaScript","slug":"Front-end/JavaScript","link":"/categories/Front-end/JavaScript/"},{"name":"React.js","slug":"Front-end/React-js","link":"/categories/Front-end/React-js/"},{"name":"memo","slug":"Front-end/memo","link":"/categories/Front-end/memo/"},{"name":"Node.js","slug":"Back-end/Node-js","link":"/categories/Back-end/Node-js/"},{"name":"Compiler","slug":"Base/Compiler","link":"/categories/Base/Compiler/"},{"name":"Css","slug":"Front-end/Css","link":"/categories/Front-end/Css/"},{"name":"etc","slug":"etc","link":"/categories/etc/"},{"name":"TypeScript","slug":"Front-end/TypeScript","link":"/categories/Front-end/TypeScript/"},{"name":"Software engineering","slug":"Base/Software-engineering","link":"/categories/Base/Software-engineering/"},{"name":"Information network","slug":"Base/Information-network","link":"/categories/Base/Information-network/"},{"name":"Computer security","slug":"Base/Computer-security","link":"/categories/Base/Computer-security/"}]}