<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>경아&#39;s 개발일기</title>
  
  <subtitle>프론트엔드 개발자 경아</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="http://dev.kyoungah.com/"/>
  <updated>2019-04-25T15:05:12.628Z</updated>
  <id>http://dev.kyoungah.com/</id>
  
  <author>
    <name>경아</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mac 개발환경 설정</title>
    <link href="http://dev.kyoungah.com/2019/04/25/2019-04-25-etc-development-env-setting/"/>
    <id>http://dev.kyoungah.com/2019/04/25/2019-04-25-etc-development-env-setting/</id>
    <published>2019-04-25T14:46:25.000Z</published>
    <updated>2019-04-25T15:05:12.628Z</updated>
    
    <content type="html"><![CDATA[<p>맥북을 포맷하면서 개발환경을 새로 세팅하다가 기록해놓으면 좋을 것 같아서 기록함.</p><h2 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h2><ol><li>Homebrew 설치<ul><li><a href="https://brew.sh/index_ko" target="_blank" rel="noopener">Homebrew</a></li><li>Mac 패키지 관리자는 Homebrew 사용 중.</li></ul></li></ol><ol start="2"><li>git 설치  <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure></li></ol><h2 id="Front-end"><a href="#Front-end" class="headerlink" title="Front-end"></a>Front-end</h2><p>개인 프로젝트 진행 시 Node.js + yarn 환경을 사용함.<br>개발툴은 vsocde 사용함.</p><ol><li><p>Node.js 설치 </p><ul><li><a href="https://nodejs.org/ko/" target="_blank" rel="noopener">Node.js</a></li><li>LTS 버전 사용 중.</li></ul></li><li><p>yarn 설치 </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install yarn</span><br></pre></td></tr></table></figure><ul><li><a href="https://yarnpkg.com/en/" target="_blank" rel="noopener">yarn</a></li></ul></li><li><p>vscode 설치 </p><ul><li>공통 Extensions<ul><li>Atom One Dark Theme </li><li>Git History</li><li>Material IconTheme</li><li>Prettier </li></ul></li><li>JavaScript / React.js 관련 Extensions<ul><li>eslint</li><li>ES7 React/Redux/GraphQL/React-Native snippets</li></ul></li></ul></li></ol><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>자료구조나 알고리즘 공부 시 c로 코드를 작성 중.</p><ol><li><p>gcc 설치</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install gcc</span><br></pre></td></tr></table></figure></li><li><p>c로 작성 중인 프로젝트 폴더에 tasks.json 파일 작성.</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="hljs-attr">"version"</span>: <span class="hljs-string">"2.0.0"</span>,</span><br><span class="line">  <span class="hljs-attr">"tasks"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="hljs-attr">"type"</span>: <span class="hljs-string">"shell"</span>,</span><br><span class="line">      <span class="hljs-attr">"label"</span>: <span class="hljs-string">"gcc build active file"</span>,</span><br><span class="line">      <span class="hljs-attr">"command"</span>: <span class="hljs-string">"/usr/bin/gcc"</span>,</span><br><span class="line">      <span class="hljs-attr">"args"</span>: [</span><br><span class="line">        <span class="hljs-string">"-g"</span>,</span><br><span class="line">        <span class="hljs-string">"$&#123;file&#125;"</span>,</span><br><span class="line">        <span class="hljs-string">"-o"</span>,</span><br><span class="line">        <span class="hljs-string">"$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;"</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="hljs-attr">"options"</span>: &#123;</span><br><span class="line">        <span class="hljs-attr">"cwd"</span>: <span class="hljs-string">"/usr/bin"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="hljs-attr">"problemMatcher"</span>: [</span><br><span class="line">        <span class="hljs-string">"$gcc"</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="hljs-attr">"group"</span>: &#123;</span><br><span class="line">        <span class="hljs-attr">"kind"</span>: <span class="hljs-string">"build"</span>,</span><br><span class="line">        <span class="hljs-attr">"isDefault"</span>: <span class="hljs-literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>c 관련 vscode Extenstions 설치 필요함.</p><ul><li>C/C++</li><li>Code Runner</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;맥북을 포맷하면서 개발환경을 새로 세팅하다가 기록해놓으면 좋을 것 같아서 기록함.&lt;/p&gt;
&lt;h2 id=&quot;Mac&quot;&gt;&lt;a href=&quot;#Mac&quot; class=&quot;headerlink&quot; title=&quot;Mac&quot;&gt;&lt;/a&gt;Mac&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Homebre
      
    
    </summary>
    
      <category term="etc" scheme="http://dev.kyoungah.com/categories/etc/"/>
    
    
      <category term="etc" scheme="http://dev.kyoungah.com/tags/etc/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript</title>
    <link href="http://dev.kyoungah.com/2019/04/25/2019-01-14-typescript-first/"/>
    <id>http://dev.kyoungah.com/2019/04/25/2019-01-14-typescript-first/</id>
    <published>2019-04-25T05:59:19.483Z</published>
    <updated>2019-04-25T05:59:19.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><ul><li>Microsoft에서 개발한 오픈 소스 프로그래밍 언어.</li><li>TypeScript는 JavaScript의 Superset이다. JavaScript의 모든 기능을 사용할 수 있고 그 위에 TypeScript만의 문법을 추가한 언어이다. </li><li>TypeScript는 Compiled Language 이다. TypeScript 컴파일러가 TypeScript를 JavaScript로 컴파일 해준다. 때문에 Transpile이라는 용어를 사용하기도 한다.</li></ul><h3 id="정적-타입-언어-vs-동적-타입-언어"><a href="#정적-타입-언어-vs-동적-타입-언어" class="headerlink" title="정적 타입 언어 vs 동적 타입 언어"></a>정적 타입 언어 vs 동적 타입 언어</h3><p>정적 타입 언어 </p><ul><li>미리 타입을 지정해놓고 시작하는 언어 <ul><li>미리 타입을 지정해놓기 때문에 타입 에러로 인한 문제점을 초기에 발견할 수 있다.</li></ul></li></ul><p>동적 타입 언어 </p><ul><li>타입이 없는 언어</li><li>실행 도중에 변수에 예상치 못한 타입이 들어와 오류가 생길 수 있다. 코드 덩어리가 커지면 오류를 잡아내기도 어렵고 동시 다발적으로 문제 생기는 경우가 많은데 이 때문에 정적 타입을 채용한 것이 TypeScript.</li><li>테스트 코드를 많이 애용하면 정적 타입 언어가 필요 없으나 테스트 커버리지를 엄청 올리는 일이 가면 갈수록 힘들어진다. 미리 타입 체킹을 하며 오류를 막아 주는 것이 TypeScript 이다.</li></ul><h2 id="TypeScript-5분-튜토리얼"><a href="#TypeScript-5분-튜토리얼" class="headerlink" title="TypeScript 5분 튜토리얼"></a>TypeScript 5분 튜토리얼</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure><p>TypeScript를 전역으로 설치해주자.</p><h3 id="helloTypeScript-ts"><a href="#helloTypeScript-ts" class="headerlink" title="helloTypeScript.ts"></a>helloTypeScript.ts</h3><figure class="highlight typescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greeter</span>(<span class="hljs-params">person: <span class="hljs-built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello <span class="hljs-subst">$&#123;person&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greeter(<span class="hljs-string">"typescript"</span>);</span><br></pre></td></tr></table></figure><p>TypeScript 공식 사이트에서 튜토리얼을 보고 간단하게 작성해 보았다. </p><p><img src="/images/frontend/typescript-first-1.png" alt="parameter에 타입을 지정해주면 타입이 맞지 않을 때 오류를 출력해준다."></p><p><img src="/images/frontend/typescript-first-2.png" alt="parameter에 타입을 생략하면 any로 타입이 설정된다."></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc helloTypeScript.ts</span><br></pre></td></tr></table></figure><p>tsc 명령어로 TypeScript를 컴파일 할 수 있다.</p><p><img src="/images/frontend/typescript-first-3.png" alt="tsc 명령어로 ts파일을 컴파일 하면 js 파일이 생성된다."></p><p><img src="/images/frontend/typescript-first-4.png" alt="컴파일된 js 파일에도 타입이 지정되어 있을까 확인해봤더니 타입이 지정되지는 않았다."></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://moon9342.github.io/typescript-introduction" target="_blank" rel="noopener">TypeScript 강좌(1) - Introduction</a><br><a href="https://www.inflearn.com/course/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%BD%94%EB%A6%AC%EC%95%84-1705-%EA%B8%B0%EC%B4%88-%EC%84%B8%EB%AF%B8%EB%82%98" target="_blank" rel="noopener">타입스크립트 코리아 : 기초 세미나</a><br><a href="https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html" target="_blank" rel="noopener">TypeScript in 5 minutes</a><br><a href="http://itmining.tistory.com/65" target="_blank" rel="noopener">정적언어(타입)과 동적언어(타입)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;TypeScript&quot;&gt;&lt;a href=&quot;#TypeScript&quot; class=&quot;headerlink&quot; title=&quot;TypeScript&quot;&gt;&lt;/a&gt;TypeScript&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Microsoft에서 개발한 오픈 소스 프로그래밍 언어.&lt;
      
    
    </summary>
    
      <category term="Front-end" scheme="http://dev.kyoungah.com/categories/Front-end/"/>
    
      <category term="TypeScript" scheme="http://dev.kyoungah.com/categories/Front-end/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="http://dev.kyoungah.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>props</title>
    <link href="http://dev.kyoungah.com/2019/04/25/2018-09-28-reactjs-props/"/>
    <id>http://dev.kyoungah.com/2019/04/25/2018-09-28-reactjs-props/</id>
    <published>2019-04-25T05:59:19.480Z</published>
    <updated>2019-04-25T05:59:19.480Z</updated>
    
    <content type="html"><![CDATA[<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>props는 Component 속성을 설정할 때 사용하는 요소이다. Component는 props를 받고 props의 값에 따라 다르게 렌더링 하거나 작동할 수 있다.<br>PropTypes 속성의 종류는 <a href="https://reactjs.org/docs/typechecking-with-proptypes.html" target="_blank" rel="noopener">React 공식 문서</a>에서 확인할 수 있다.</p><h4 id="부모-컴포넌트"><a href="#부모-컴포넌트" class="headerlink" title="부모 컴포넌트"></a>부모 컴포넌트</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> Child <span class="hljs-keyword">from</span> <span class="hljs-string">'./Child'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> (</span><br><span class="line">      &lt;Child singer=<span class="hljs-string">"Nell"</span> song=<span class="hljs-string">"Home"</span>/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Parent;</span><br></pre></td></tr></table></figure><p>props값은 해당 컴포넌트를 불러와 사용하는 부모 컴포넌트에서만 설정할 수 있다. </p><h4 id="자식-컴포넌트"><a href="#자식-컴포넌트" class="headerlink" title="자식 컴포넌트"></a>자식 컴포넌트</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 자식 컴포넌트</span></span><br><span class="line"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> &#123; singer, song &#125; = <span class="hljs-keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        지금 듣고 있는 노래는 &#123;singer&#125;의 &#123;song&#125;입니다.</span><br><span class="line">      &lt;<span class="hljs-regexp">/div&gt;</span></span><br><span class="line"><span class="hljs-regexp">    );</span></span><br><span class="line"><span class="hljs-regexp">  &#125;</span></span><br><span class="line"><span class="hljs-regexp">&#125;</span></span><br><span class="line"><span class="hljs-regexp"></span></span><br><span class="line"><span class="hljs-regexp">export default Child;</span></span><br></pre></td></tr></table></figure><p>props에 접근할 때는 this 키워드를 사용하여 접근한다. </p><p><img src="/images/frontend/reactjs-props-1.png" alt="실행결과"></p><p>부모 Component에서 자식 Component로 전달되며 받아온 props는 수정할 수 없다. </p><p><img src="/images/frontend/reactjs-props-2.png" alt="Object.isFrozen 메소드로 동결되어 있는것을 확인할 수 있다. props값을 바꾸려고 하면 에러가 난다."></p><h3 id="propTypes"><a href="#propTypes" class="headerlink" title="propTypes"></a>propTypes</h3><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">"prop-types"</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// ... 생략</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.propTypes = &#123;</span><br><span class="line">  singer: PropTypes.string,</span><br><span class="line">  song: PropTypes.string.isRequired <span class="hljs-comment">// 필수적으로 존재해야 한다. </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Child;</span><br></pre></td></tr></table></figure><p>컴포넌트의 필수 props를 지정하거나 props 타입을 지정할 때는 propTypes를 사용한다. propTypes를 지정하려면 <strong>prop-types</strong> 모듈이 필요하다.<br>필수 props를 지정하고 싶을 땐 propTypes를 설정할 때 isRequired를 사용하면 된다. </p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> &lt;Child singer=&#123;123&#125; song="Home" /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/frontend/reactjs-props-3.png" alt="잘못된 타입으로 props를 넘겨줘 보았다."><br>props의 타입을 propTypes에서 설정한 타입과 다른 타입으로 넘겨주면 렌더링은 되나 개발자 도구에 오류 메시지가 출력된다. </p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> &lt;Child singer="Nell" /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/frontend/reactjs-props-4.png" alt="필수 props를 제외해 보았다."><br>필수 props가 빠졌을 때도 렌더링은 되나 개발자 도구에 오류 메시지가 출력된다. </p><h3 id="defaultProps"><a href="#defaultProps" class="headerlink" title="defaultProps"></a>defaultProps</h3><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">"prop-types"</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// ... 생략</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.propTypes = &#123;</span><br><span class="line">  singer: PropTypes.string,</span><br><span class="line">  song: PropTypes.string.isRequired</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Child.defaultProps = &#123;</span><br><span class="line">  singer: <span class="hljs-string">"Hoobastank"</span>,</span><br><span class="line">  song: <span class="hljs-string">"Without A Fight"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Child;</span><br></pre></td></tr></table></figure><p>defaultProps를 사용해서 prop의 기본 값을 설정할 수 있다. defaultProps는 prop-types 모듈이 필요 없다. </p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> &lt;Child /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/frontend/reactjs-props-5.png" alt="defaultProps 적용"><br>props를 지정해주지 않으면 defaultProps에 있는 기본 값이 적용된다. </p><h3 id="transform-class-properties"><a href="#transform-class-properties" class="headerlink" title="transform-class-properties"></a>transform-class-properties</h3><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">"prop-types"</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">static</span> propTypes = &#123;</span><br><span class="line">    singer: PropTypes.string,</span><br><span class="line">    song: PropTypes.string.isRequired</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">static</span> defaultProps = &#123;</span><br><span class="line">    singer: <span class="hljs-string">"Hoobastank"</span>,</span><br><span class="line">    song: <span class="hljs-string">"Without A Fight"</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> &#123; singer, song &#125; = <span class="hljs-keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        지금 듣고 있는 노래는 &#123;singer&#125;의 &#123;song&#125;입니다.</span><br><span class="line">      &lt;<span class="hljs-regexp">/div&gt;</span></span><br><span class="line"><span class="hljs-regexp">    );</span></span><br><span class="line"><span class="hljs-regexp">  &#125;</span></span><br><span class="line"><span class="hljs-regexp">&#125;</span></span><br><span class="line"><span class="hljs-regexp"></span></span><br><span class="line"><span class="hljs-regexp">export default Child;</span></span><br></pre></td></tr></table></figure><p>propTypes, defaulProps를 클래스 내부에서 정의할 수도 있다. 이 문법을 사용하려면 transform-class-properties babel 플러그인이 필요한데 create-react-app으로 생성한 프로젝트는 기본적으로 적용되어 있기 때문에 따로 설정할 필요가 없다. </p><h3 id="typescript"><a href="#typescript" class="headerlink" title="typescript"></a>typescript</h3><p>typeScript를 사용하여 props에 타입을 줘보자. </p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;</span><br><span class="line"></span><br><span class="line">interface ChildProps &#123;</span><br><span class="line">  singer: string;</span><br><span class="line">  song: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface ChildState &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span>&lt;<span class="hljs-title">ChildProps</span>, <span class="hljs-title">ChildState</span>&gt; </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">static</span> defaultProps = &#123;</span><br><span class="line">    singer: <span class="hljs-string">"Hoobastank"</span>,</span><br><span class="line">    song: <span class="hljs-string">"Without A Fight"</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> &#123; singer, song &#125; = <span class="hljs-keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        지금 듣고 있는 노래는 &#123;singer&#125;의 &#123;song&#125;입니다.</span><br><span class="line">      &lt;<span class="hljs-regexp">/div&gt;</span></span><br><span class="line"><span class="hljs-regexp">    );</span></span><br><span class="line"><span class="hljs-regexp">  &#125;</span></span><br><span class="line"><span class="hljs-regexp">&#125;</span></span><br><span class="line"><span class="hljs-regexp"></span></span><br><span class="line"><span class="hljs-regexp">export default Child;</span></span><br></pre></td></tr></table></figure><p><img src="/images/frontend/reactjs-props-6.png" alt="잘못된 타입을 지정했더니 렌더링 조차 되지 않고 오류를 출력한다."></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;mallGb=KOR&amp;barcode=9791160505238&amp;orderClick=LAG&amp;Kc=" target="_blank" rel="noopener">리액트를 다루는 기술</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;props&quot;&gt;&lt;a href=&quot;#props&quot; class=&quot;headerlink&quot; title=&quot;props&quot;&gt;&lt;/a&gt;props&lt;/h2&gt;&lt;p&gt;props는 Component 속성을 설정할 때 사용하는 요소이다. Component는 props를 받고
      
    
    </summary>
    
      <category term="Front-end" scheme="http://dev.kyoungah.com/categories/Front-end/"/>
    
      <category term="React.js" scheme="http://dev.kyoungah.com/categories/Front-end/React-js/"/>
    
    
      <category term="React.js" scheme="http://dev.kyoungah.com/tags/React-js/"/>
    
  </entry>
  
  <entry>
    <title>암호의 개념</title>
    <link href="http://dev.kyoungah.com/2019/04/21/2019-04-21-compouter-security-secret-code/"/>
    <id>http://dev.kyoungah.com/2019/04/21/2019-04-21-compouter-security-secret-code/</id>
    <published>2019-04-21T09:26:49.000Z</published>
    <updated>2019-04-25T05:59:19.491Z</updated>
    
    <content type="html"><![CDATA[<h2 id="암호의-정의"><a href="#암호의-정의" class="headerlink" title="암호의 정의"></a>암호의 정의</h2><ul><li><strong>암호</strong>: 두 사람이 안전하지 않은 채녈을 통하여 정보를 주고받더라도 제3자는 이 정보의 내용을 알 수 없도록 하는 것.<ul><li>안전하지 않은 채널: 이 채널을 통해 지나다니는 메시지를 누구든지 볼 수 있다는 의미.</li></ul></li><li><strong>암호문</strong>: 제3자가 보더라도 그 내용을 알 수 없도록 변환된 메시지.</li><li><strong>평문</strong>: 변환되기 전인 원래의 메시지.</li><li><strong>암호화</strong>: 평문을 암호문으로 변환하는 것.</li><li><strong>복호화</strong>: 암호문을 다시 평문으로 변환하는 것.</li></ul><p>결국 암호는 송신자와 수신자가 서로 약속한 방식을 이용하여 송신자는 평문을 암호화하여 암호문을 만들어 보내고 수신자는 암호문을 복호화하여 평문을 만듦으로써 서로 정보를 주고 받는 것. 여기서 약속한 방식이란 특정한 암호 알고리즘 및 특정한 키를 의미한다. 키는 암호화와 복호화를 위한 가장 중요한 열쇠로 제 3자에게 알려져서는 안된다. </p><p>암호는 정보보호 핵심 목표 중 기밀성을 보장하기 위한 필수적인 기술이다.</p><h2 id="암호의-역사"><a href="#암호의-역사" class="headerlink" title="암호의 역사"></a>암호의 역사</h2><p>처음에는 암호를 주로 군사와 정치적인 목적으로 사용했다.<br>최근에는 일상생활과도 깊게 관계를 맺고 있으며, 인터넷뱅킹에 사용되는 인증서, 보안 키패드, 소프트웨어의 시리얼 키뿐만 아니라 전자투표 등에서 점차 널리 쓰이고 있다.</p><p>컴퓨터와 통신이 결합함에 따라 불법 사용자의 봉쇄 또는 데이터의 위조 및 변조를 막는 수단으로도 이용되고 있다.</p><h3 id="고대-암호"><a href="#고대-암호" class="headerlink" title="고대 암호"></a>고대 암호</h3><p>최초의 암호는 기원전 480년에 스파르타에서 추방되어 페르시아에 살던 데마라토스가 페르시아의 침략계획 소식을 나무판에 조각하여 적은 후 밀랍을 발라 스파르타에 보낸 것.</p><ul><li><strong>스테가노그래피</strong>: 실제로 전달하고자 하는 정보 자체를 숨기는 것.</li><li>어떤 스테가노그래피 방식이 사용되었는지 알면 제 3자가 비교적 쉽게 숨겨진 정보를 찾을 수 있기 때문에 엄밀히 말하면 최초의 암호라고 하기는 힘듦.</li></ul><h4 id="전치법"><a href="#전치법" class="headerlink" title="전치법"></a>전치법</h4><ul><li>평문에 있는 문자들의 순서를 바꿈으로써 암호화 하는 기법.</li><li>암호화를 하는 쪽과 복호화를 하는 쪽이 미리 정해놓은 문자 배열규칙에 따라 암호화와 복호화를 수행하는 방식.</li><li>암호문에 사용되는 문자들은 평문에서 사용된 문자들이 그대로 이용되며 단지 위치만 바뀐다.</li></ul><p>ex)<br><img src="/images/base/compouter-security-secret-code-1.png" alt="스파르타의 봉 암호 (출처: 위키백과)"><br>컴퓨터보안재미있는과목입니다~! -&gt; 컴안는니퓨재과다터미목~보있입!</p><h4 id="치환법"><a href="#치환법" class="headerlink" title="치환법"></a>치환법</h4><p><img src="/images/base/compouter-security-secret-code-2.png" alt="치환법 (출처: 위키백과)"></p><ul><li>평문의 문자들을 다른 문자로 치환함으로써 암호화 하는 기법.</li><li>암호화를 하는 쪽과 복호화를 하는 쪽이 미리 정해 놓은 문자 치환규칙에 따라 암호화와 복호화를 수행하는 방식.</li><li>암호문에 사용되는 문자들은 평문에서 사용된 문자들과 달라지지만 대응되는 각 문자의 위치는 바뀌지 않는다.</li></ul><h4 id="시저암호"><a href="#시저암호" class="headerlink" title="시저암호"></a>시저암호</h4><p><img src="/images/base/compouter-security-secret-code-3.png" alt="시저암호 (출처: 위키백과)"></p><ul><li>알파벳 26글자를 알파벳 순서로 세 자씩 오른쪽으로 이동시킨 뒤, 해당되는 글자로 치환하여 암호화를 함.</li></ul><h4 id="시프트-암호"><a href="#시프트-암호" class="headerlink" title="시프트 암호"></a>시프트 암호</h4><ul><li>각 문자를 알파벳 순서로 k번째 뒤 문자로 치환하는 방법.</li><li>k는 0부터 25가지의 정수 중 하나가 됨. 암호화와 복호화를 하는 두 사람이 미리 k값을 약속해야 하며 이 k 값이 바로 키가 됨.</li></ul><h3 id="근대-암호"><a href="#근대-암호" class="headerlink" title="근대 암호"></a>근대 암호</h3><ul><li>16세기: 프랑스 외교관 비즈네르가 시프트 암호를 개선하여 새로운 비즈네르 암호라는 치환법을 고안함. 비즈네르 암호는 여러 개의 정수값을 키로 이용함.</li><li>20세기: 플레이페어 암호, 힐 암호 등 다양한 암호 방식이 등장함. 20세기 들어서는 통신기술의 발전과 기계식 계산기에 대한 연구를 바탕으로 두 차례의 세계 대전을 통해 암호 설계와 해독에 대한 필요성이 높아지면서 암호에 대한 연구가 더욱 활발하게 진행됨.</li><li>1949년: 섀년이 일회성 암호체계가 안전함을 증명했고 암호체계 설계의 두 가지 기본원칙인 혼돈과 확산 이론을 제시함.<ul><li>혼돈은 평문과 암호문사이의 상관관계를 숨김.</li><li>확산은 평문의 통계적 성격을 암호문 전반에 확산시켜 숨기는 역할을 함.</li></ul></li></ul><h3 id="현대-암호"><a href="#현대-암호" class="headerlink" title="현대 암호"></a>현대 암호</h3><p>10970년대에 표준 암호 알고리즘과 공개 키 알고리즘의 등장으로 큰 변화가 일어남. </p><h3 id="표준-암호-알고리즘의-등장"><a href="#표준-암호-알고리즘의-등장" class="headerlink" title="표준 암호 알고리즘의 등장."></a>표준 암호 알고리즘의 등장.</h3><p>컴퓨터가 점차 발전하면서 데이터 보호에 대한 필요성도 증가하여 미국 NBS는 1977년 표준 암호 알고리즘으로 DES를 공표함.<br>DES는 대표적인 대칭키 알고리즘으로 2001년 새로운 표준 알고리즘인 AES가 공표될 떄까지 널리 이용됨.</p><h3 id="공개-키-알고리즘의-등장"><a href="#공개-키-알고리즘의-등장" class="headerlink" title="공개 키 알고리즘의 등장"></a>공개 키 알고리즘의 등장</h3><p>1076년 디피와 헬먼이 공개키 암호의 개념을 제시함.<br>공개키 암호는 암호화와 복호화에 다른 키를 사용함. 이 개념을 이용하여 1978년 리베스트, 샤미르, 애들먼은 소인수분해 문제에 기반을 둔 RSA 공개키 알고리즘을 개발함.</p><h2 id="대칭키"><a href="#대칭키" class="headerlink" title="대칭키"></a>대칭키</h2><ul><li>암호화와 복호화에 같은 키 하나를 사용하는 암호 방식.<ul><li>대칭키 암호는 평문을 암호화할 때 키 K를 이용하여 암호문을 만들었으면 나중에 복호화 할 때도 동일한 키 K를 이용해야만 원래의 평문을 만들 수 있다.</li><li><strong>비밀키</strong>: 대칭키 암호에서 사용하는 키.</li></ul></li><li>암호와와 복호와 속도가 빠르다.</li><li>비밀키를 제 3자에게 노출하지 않으면서 송신자와 수신자가 나누어 가지기 어렵다.</li><li><strong>블록 암호</strong>: 암호문을 만들기 위해 평문을 고정된 크기의 블록으로 나누어서 각 블록마다 암호화 과정을 수행하여 블록단위로 암호문을 얻는 대칭키 암호 방식.</li><li><strong>스트림 암호</strong>: 평문과 같은 길이의 키 스트림을 생성하여 평문과 키를 비트 단위로 XOR하여 암호문을 얻는 대칭키 암호 방식.</li><li>DES, AES, IDEA, SEED, CRYPTON, RC5, FEAL, MISTY, Skipjack, RC4 등의 대칭키 암호 알고리즘 들이 있다.</li></ul><h2 id="공개키"><a href="#공개키" class="headerlink" title="공개키"></a>공개키</h2><ul><li>암호화와 복호화에 두 개의 서로 다른 키를 사용하는 암호 방식.</li><li>공개키 암호는 평문을 암호화 할 때 K1을 이용하여 암호문을 만들면 나중에 복호화 할 때는 다른 키 K2를 이용해야만 원래의 평문을 만들 수 있다.</li><li><strong>공개키</strong>: 공개되어 있어서 누구나 공개키를 이용하여 암호화 할 수 있다.</li><li><strong>개인키</strong>: 아무에게도 공개하지 않고 자신만 알고 있어야 하며 오직 자신만 개인키를 이용하여 복호화 할 수 있다. </li><li>키관리가 쉽고 키 분배 문제도 해결하였다.</li><li>대칭키 암호에 비해 속도가 느리다.<ul><li>데이터를 암호화 할 때는 대칭키 암호방식을 많이 쓰며 이때 필요한 대칭키 암호의 비밀키를 교환할 때는 공개키 암호 방식을 쓴다.</li></ul></li><li>RSA 암호 알고리즘, EIGamal 암호 알고리즘, Rabin 암호 알고리즘, NTRU 암호 알고리즘 등의 공개키 암호 알고리즘 들이 있다.</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920020759&amp;condLscValue=001&amp;condYr=&amp;condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 컴퓨터 보안 2강</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;암호의-정의&quot;&gt;&lt;a href=&quot;#암호의-정의&quot; class=&quot;headerlink&quot; title=&quot;암호의 정의&quot;&gt;&lt;/a&gt;암호의 정의&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;암호&lt;/strong&gt;: 두 사람이 안전하지 않은 채녈을 통하여 정보를 주
      
    
    </summary>
    
      <category term="Base" scheme="http://dev.kyoungah.com/categories/Base/"/>
    
      <category term="Computer security" scheme="http://dev.kyoungah.com/categories/Base/Computer-security/"/>
    
    
      <category term="Computer security" scheme="http://dev.kyoungah.com/tags/Computer-security/"/>
    
  </entry>
  
  <entry>
    <title>컴퓨터 보안 개념</title>
    <link href="http://dev.kyoungah.com/2019/04/07/2019-04-07-computer-security-first/"/>
    <id>http://dev.kyoungah.com/2019/04/07/2019-04-07-computer-security-first/</id>
    <published>2019-04-07T10:15:27.000Z</published>
    <updated>2019-04-25T05:59:19.490Z</updated>
    
    <content type="html"><![CDATA[<h2 id="컴퓨터-보안"><a href="#컴퓨터-보안" class="headerlink" title="컴퓨터 보안"></a>컴퓨터 보안</h2><p>다양한 형태의 정보 중 컴퓨팅 환경이 관여된 모든 상황에 대한 정보보호. </p><ul><li>정보보호: 저장되어 있거나 전달 중인 정보를 허락되지 않은 접근, 수정, 훼손, 유출 등의 위협으로부터 보호하기 위한 정책 및 기법. </li></ul><h2 id="컴퓨터-보안의-목표"><a href="#컴퓨터-보안의-목표" class="headerlink" title="컴퓨터 보안의 목표"></a>컴퓨터 보안의 목표</h2><p>기밀성, 무결성, 가용성이 컴퓨터 보안의 가장 중요한 목표 이다. </p><h3 id="기밀성"><a href="#기밀성" class="headerlink" title="기밀성"></a>기밀성</h3><p>허락되지 않은 자가 정보의 내용을 알 수 없도록 하는 것.<br>기밀성을 지키기 위해서는 허락되지 않은 자가 정보에 접근을 아예 못하도록 할 수도 있고, 정보에 접근하더라도 무의미한 내용만 보이도록 할 수 있다.</p><p>ex)<br>고객의 개인정보를 제 3자에게 알려지는 것을 방지하기 위해 보호하는 것.</p><h3 id="무결성"><a href="#무결성" class="headerlink" title="무결성"></a>무결성</h3><p>허락되지 않은 자가 정보를 함부로 수정할 수 없도록 하는 것.<br>만약 허락되지 않은 자에 의한 수정이 발생했다면 이를 확인할 수 있는것 역시 무결성을 지키는 방법이다.</p><p>ex)<br>데이터베이스에 고객의 정보가 저장되어 있다면 그 내용이 임의로 수정되지 않도록 보호하는 것.<br>고객 본인이 본인의 회원정보를 확인할 때 이 과정에서도 내용이 위변조 되지 않도록 보호하는 것.</p><h3 id="가용성"><a href="#가용성" class="headerlink" title="가용성"></a>가용성</h3><p>허락된 자가 정보에 접근하고자 할 때 이것이 방해받지 않도록 하는 것.<br>즉, 정보에 대한 접근권한이 있는 자는 필요할 때 언제든지 정보를 사용할 수 있어야 한다.<br>결국 가용성은 정해진 시간 내에 정보를 볼 수 있음을 보장한다. </p><p>ex)<br>고객이 회원정보를 수정하기 위해 회원정보를 확인하고자 할 때 즉시 조회가 가능하게 하는 것.</p><h3 id="그-외-목표들"><a href="#그-외-목표들" class="headerlink" title="그 외 목표들"></a>그 외 목표들</h3><p>부인방지, 인증, 접근제어 등이 있다.</p><h4 id="부인방지"><a href="#부인방지" class="headerlink" title="부인방지"></a>부인방지</h4><p>정보에 관여한 자가 이를 부인하지 못하도록 하는 것.</p><p>ex)<br>정보를 보낸 사람이 나중에 정보를 보냈다는 것을 부인하지 못하도록 하는 발신 부인방지.<br>정보를 받은 사람이 나중에 받지 않았다는 것을 부인하지 못하도록 하는 수신 부인방지.</p><h4 id="인증"><a href="#인증" class="headerlink" title="인증"></a>인증</h4><p>정보 또는 정보를 이용하는 사용자가 정말 주장하는 정보 또는 사용자가 맞는지 확인할 수 있고 신뢰할 수 있는 것.</p><h4 id="접근제어"><a href="#접근제어" class="headerlink" title="접근제어"></a>접근제어</h4><p>정보에 대해 허락한 접근만 허용하고 그 외의 접근은 허용하지 않는 것.<br>접근권한이 있는 자는 정보에 대한 접근을 허용하고 접근권한이 없는 자는 정보에 접근하지 못하게 하는 것이다. 이때 접근권한은 정보나 사용자에 따라 다양하게 부여될 수 있다.</p><h2 id="정보화-환경과-역기능"><a href="#정보화-환경과-역기능" class="headerlink" title="정보화 환경과 역기능"></a>정보화 환경과 역기능</h2><p>과거 정보통신기술이 미약하던 시대에는 정보의 전달이 대부분 인편에 의존하였기 때문에 정보의 전파가 굉장히 느렸다. 그러다가 통신회선이 깔리면서 전보나 전화를 통해 정보의 전파속도가 빨라졌고, 이제는 인터넷을 통해 지구 반대편에서 일어나는 일도 실시간으로 알 수 있을 만큼 정보는 빠르게 움직이고 있다. </p><p>이처럼 정보화 사회가 선진화 됨에 따라 악성 댓글, 스팸 메일, 개인정보 유출, 금전적인 목적을 대상으로 하는 피싱이나 파밍, 스미싱 등에 따른 개인적인 피해가 증가하고 있으며 불건전 정보 유통, 사생활 침해 등과 같은 부작용이 심각한 사회문제로 대두되고 있다. 이러한 문제점은 보이스 피싱, 문자 메시지나 인스턴트 메시지를 이용한 스미싱, 랜섬웨어 같은 새로운 수법이 등장하면서 대처를 더욱 어렵게 하고 있다.</p><p>주요 기반 시설이 점차 정보통신 네트워크에 의해 관리 및 통제 됨에 따라 정보통신 인프라의 위협이 주요 기반 시설의 위협으로까지 확장되고 있으며, 결국 이는 국가 안보적인 측면에서 위험이 될 수 있다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920020759&amp;condLscValue=001&amp;condYr=&amp;condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 컴퓨터 보안 1강</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;컴퓨터-보안&quot;&gt;&lt;a href=&quot;#컴퓨터-보안&quot; class=&quot;headerlink&quot; title=&quot;컴퓨터 보안&quot;&gt;&lt;/a&gt;컴퓨터 보안&lt;/h2&gt;&lt;p&gt;다양한 형태의 정보 중 컴퓨팅 환경이 관여된 모든 상황에 대한 정보보호. &lt;/p&gt;
&lt;ul&gt;
&lt;li
      
    
    </summary>
    
      <category term="Base" scheme="http://dev.kyoungah.com/categories/Base/"/>
    
      <category term="Computer security" scheme="http://dev.kyoungah.com/categories/Base/Computer-security/"/>
    
    
      <category term="Computer security" scheme="http://dev.kyoungah.com/tags/Computer-security/"/>
    
  </entry>
  
  <entry>
    <title>데이터 통신 시스템</title>
    <link href="http://dev.kyoungah.com/2019/03/24/2019-03-24-information-network-data-communication-system/"/>
    <id>http://dev.kyoungah.com/2019/03/24/2019-03-24-information-network-data-communication-system/</id>
    <published>2019-03-24T10:35:01.000Z</published>
    <updated>2019-04-25T05:59:19.490Z</updated>
    
    <content type="html"><![CDATA[<h2 id="데이터-통신-시스템"><a href="#데이터-통신-시스템" class="headerlink" title="데이터 통신 시스템"></a>데이터 통신 시스템</h2><p>원거리에 떨어져 있는 데이터 발생지와 목적지 사이에 정보를 신속하고 정확하게 전송하고 처리하기 위해 데이터 전송과 데이터 처리를 상호 유기적 으로 결합한 시스템.</p><h2 id="데이터-통신-시스템의-기능"><a href="#데이터-통신-시스템의-기능" class="headerlink" title="데이터 통신 시스템의 기능"></a>데이터 통신 시스템의 기능</h2><ul><li>전송 시스템 활용</li><li>접속</li><li>동기화</li><li>교환관리 </li><li>오류검출 및 정정</li><li>흐름제어</li><li>주소지정</li><li>라우팅</li><li>복구</li><li>메시지 형식화 </li><li>보호</li><li>시스템 관리</li></ul><h2 id="데이터-통신-시스템의-구성-요소"><a href="#데이터-통신-시스템의-구성-요소" class="headerlink" title="데이터 통신 시스템의 구성 요소"></a>데이터 통신 시스템의 구성 요소</h2><p><img src="/images/base/information-network-data-communication-system-1.png" alt="데이터 통신 시스템의 구성 요소"></p><h3 id="단말장치"><a href="#단말장치" class="headerlink" title="단말장치"></a>단말장치</h3><ul><li>데이터 통신 시스템에서 최종적으로 데이터를 송신하거나 수신하는 기능을 수행하는 장치.</li><li>단말기 또는 터미널이라고도 불린다.</li><li>키보드와 모니터, 프린터 등과 같이 컴퓨터와 연결되는 모든 주변장치를 의미한다.</li><li>입출력 기능, 기억 기능 및 전송제어 기능으로 구분된다.</li></ul><h4 id="입출력-기능"><a href="#입출력-기능" class="headerlink" title="입출력 기능"></a>입출력 기능</h4><p>외부로부터 정보를 받아들이고, 역으로 데이터 통신 시스템에서 처리한 결과를 외부에 출력한다.</p><h4 id="기억-기능"><a href="#기억-기능" class="headerlink" title="기억 기능"></a>기억 기능</h4><p>단말장치에 디스크나 소용량 기억장치를 부가하여 송,수신 데이터를 일시적으로 기억하거나 정보의 자체적이고 지역적인 처리를 수행한다.</p><h4 id="전송제어-기능"><a href="#전송제어-기능" class="headerlink" title="전송제어 기능"></a>전송제어 기능</h4><p>컴퓨터와 단말장치 간에 정확한 데이터의 송수신이 가능하도록 전송제어를 수행한다. </p><h3 id="데이터-전송회선"><a href="#데이터-전송회선" class="headerlink" title="데이터 전송회선"></a>데이터 전송회선</h3><ul><li>단말장치로부터 통신제어장치까지의 데이터 전송 경로.</li><li>신호변환장치와 통신회선으로 구분된다.</li></ul><h4 id="신호변환장치"><a href="#신호변환장치" class="headerlink" title="신호변환장치"></a>신호변환장치</h4><ul><li>송신측이 전송한 데이터는 신호변환장치를 통과하면서 전기적 신호로 변환된 후 통신회선을 통해 수신측 신호변환장치에 전달된다.</li><li>수신측 신호변환장치는 전기적 신호를 원래의 데이터로 변환하여 통신제어장치에 전달한다. </li><li>대표적인 신호변환장치는 변복조기와 디지털 서비스 유니트가 있다. </li></ul><h3 id="통신제어장치"><a href="#통신제어장치" class="headerlink" title="통신제어장치"></a>통신제어장치</h3><ul><li>컴퓨터와 신호변환장치 사이에 위치하며, 단말장치와의 통신에 있어 각종 제어 기능을 분담한다.</li><li>통신제어장치는 데이터 전송회선과의 전기적 접속을 이루며 문자의 조립, 분해 기능과 버퍼링, 오류검출, 오류제어용 확장 비트 부가, 전송 제어, 회선의 감지, 접속제어 기능을 갖는다.</li></ul><h3 id="컴퓨터"><a href="#컴퓨터" class="headerlink" title="컴퓨터"></a>컴퓨터</h3><p>컴퓨터의 중앙처리장치에는 통신제어 프로그램이 내장되어 있어 통신제어장치로부터 입력된 데이터를 처리하고, 데이터 통신 시스템 전체를 제어한다. </p><h2 id="통신-소프트웨어"><a href="#통신-소프트웨어" class="headerlink" title="통신 소프트웨어"></a>통신 소프트웨어</h2><p><img src="/images/base/information-network-data-communication-system-2.png" alt="통신 소프트웨어"></p><ul><li>데이터 전송회선과 통신제어장치를 이용하여 컴퓨터와 단말장치 사이에서 정보를 송수신하기 위한 프로그램.</li><li>주요 기능: 데이터 송수신, 통신 하드웨어의 제어, 이용자 접속의 제어</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920014864&amp;condLscValue=001&amp;condYr=&amp;condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 정보통신망 1강</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;데이터-통신-시스템&quot;&gt;&lt;a href=&quot;#데이터-통신-시스템&quot; class=&quot;headerlink&quot; title=&quot;데이터 통신 시스템&quot;&gt;&lt;/a&gt;데이터 통신 시스템&lt;/h2&gt;&lt;p&gt;원거리에 떨어져 있는 데이터 발생지와 목적지 사이에 정보를 신속하고 
      
    
    </summary>
    
      <category term="Base" scheme="http://dev.kyoungah.com/categories/Base/"/>
    
      <category term="Information network" scheme="http://dev.kyoungah.com/categories/Base/Information-network/"/>
    
    
      <category term="Information network" scheme="http://dev.kyoungah.com/tags/Information-network/"/>
    
  </entry>
  
  <entry>
    <title>컴퓨터 통신망</title>
    <link href="http://dev.kyoungah.com/2019/03/24/2019-03-24-information-network-first/"/>
    <id>http://dev.kyoungah.com/2019/03/24/2019-03-24-information-network-first/</id>
    <published>2019-03-24T09:18:29.000Z</published>
    <updated>2019-04-25T05:59:19.490Z</updated>
    
    <content type="html"><![CDATA[<h2 id="컴퓨터-통신망의-출현"><a href="#컴퓨터-통신망의-출현" class="headerlink" title="컴퓨터 통신망의 출현"></a>컴퓨터 통신망의 출현</h2><p>지역적으로 떨어진 컴퓨터와 컴퓨터를 서로 통신망으로 연결시켜 컴퓨터 자원을 공유하려는 이유에서 컴퓨터 통신망이 출현하게 되었다.</p><h3 id="데이터-통신-기술"><a href="#데이터-통신-기술" class="headerlink" title="데이터 통신 기술"></a>데이터 통신 기술</h3><p>데이터 처리에 있어서 데이터 통신은 매우 중요한 역할을 한다. 통신망으로 서로 연결되어 있지 않은 컴퓨터, stand-alone 컴퓨터에서도 데이터 통신은 없어서는 안될 중요한 기능이다. </p><p>A컴퓨터와 B컴퓨터가 송•수신을 할 때 통신 시스템을 거쳐서 원하는 데이터의 송 • 수신이 가능하다. </p><h3 id="데이터-처리-기술"><a href="#데이터-처리-기술" class="headerlink" title="데이터 처리 기술"></a>데이터 처리 기술</h3><p>컴퓨터를 이용하는 데이터 처리 기술이 데이터 통신 분야에도 큰 영향을 미치고 있다.<br>현재의 디지털 신호 전송 방식은 컴퓨터를 활용함으로써 음성뿐만 아니라 문자 데이터, 화상 데이터 등도 모두 디지털화 하여 고품질의 데이터 전송이 가능하게 만들었다.</p><p>즉, 통신 기술이 아날로그 방식에서 디지털 방식으로 전이됨으로써 얻게 되는 많은 장점은 컴퓨터 시스템의 데이터 처리 기술 덕분이다. </p><h3 id="분산-시스템"><a href="#분산-시스템" class="headerlink" title="분산 시스템"></a>분산 시스템</h3><p>컴퓨터 자원을 공유하고 그들의 확장과 축소를 용이하도록 하며 오류에 대한 신뢰도를 높일 수 있도록 컴퓨터 자원을 분산시켜 작업을 처리하는 시스템.</p><ul><li>여러군데다가 자원을 분산시켜 놓음으로써 한쪽에서 고장이 나도 다른쪽에서 데이터를 가져올 수 있기 때문에 오류에 대한 신뢰도가 높아짐. </li></ul><h4 id="강연결-분산-시스템"><a href="#강연결-분산-시스템" class="headerlink" title="강연결 분산 시스템"></a>강연결 분산 시스템</h4><p>분산된 거리가 짧고 처리기 사이의 상호 작용이 많은 분산 시스템.</p><p>ex) 자료흐름기계, 멀티프로세서</p><h4 id="약연결-분산-시스템"><a href="#약연결-분산-시스템" class="headerlink" title="약연결 분산 시스템"></a>약연결 분산 시스템</h4><p>분산된 거리가 비교적 길고 처리기 사이의 상호 작용이 비교적 적은 분산 시스템.</p><p>ex) 근거리 통신망(LAN), 원거리 통신망(WAN), 도시권 통신망(MAN).</p><h2 id="컴퓨터-통신망의-정의-및-구성-요소"><a href="#컴퓨터-통신망의-정의-및-구성-요소" class="headerlink" title="컴퓨터 통신망의 정의 및 구성 요소"></a>컴퓨터 통신망의 정의 및 구성 요소</h2><ul><li><strong>통신</strong> 넓은 의미로는 ‘거리상 서로 떨어진 사람 또는 장치들 사이에 여러 종류의 매개체를 이용하여 정보를 전달하는 활동’을 뜻하며 좁은 의미로는 ‘원격통신’을 뜻한다.<ul><li><strong>원격통신</strong>: 전자적 신호나 전자기적 파장을 이용하여 정보를 전송하는 것.</li></ul></li><li><strong>데이터 통신</strong>: 컴퓨터 시스템에 의한 데이터를 처리하는 기술과 데이터를 전송하는 기술이 결합된 것.</li><li><strong>데이터 통신망</strong>: 데이터 통신 기술과 망 기술이 융합된 개념.</li><li><strong>컴퓨터 통신망(컴퓨터 망)</strong>: 자원과 정보를 공유할 수 있게 해 주기 위해 통신 채널들로 상호 연결된 컴퓨터들과 기타 하드웨어 및 소프트웨어 구성 요소들의 집합체. 서버, 클라이언트, 전송 매체, 네트워킹 장치, 프로토콜, 애플리케이션 등의 구성 요소로 이루어진다.<ul><li><strong>서버</strong>: 컴퓨터 서비스에서 특정 서비스를 제공해 주는 컴퓨터.</li><li><strong>클라이언트</strong>: 서비스를 받고자 하는 컴퓨터 또는 단말.</li><li><strong>전송 매체</strong>: 컴퓨터 통신망에서 서버 및 클라이언트를 상호연결 시키고 데이터 전송이 가능하도로고 하기 위해 사용되는 장비.</li><li><strong>네트워킹 장치</strong>: 서버와 클라이언트를 컴퓨터 통신망에 연결시키기 위해 필요한 연결 장치.</li><li><strong>프로토콜</strong>: 서버와 클라이언트가 통신하기 위해 미리 정해 놓은 규칙.</li><li><strong>애플리케이션</strong>: 컴퓨터 통신망을 통해 서버가 클라이언트에게 제공하는 서비스 또는 그것을 위한 프로그램.</li></ul></li></ul><h2 id="컴퓨터-통신망의-서비스"><a href="#컴퓨터-통신망의-서비스" class="headerlink" title="컴퓨터 통신망의 서비스"></a>컴퓨터 통신망의 서비스</h2><ul><li>e-mail</li><li>파일 전송</li><li>원격 처리 </li><li>원격 회의</li><li>분산 데이터베이스 시스템</li><li>Web Service </li><li>Social Network Service</li></ul><p>그외 등등…</p><h2 id="컴퓨터-통신망의-역사"><a href="#컴퓨터-통신망의-역사" class="headerlink" title="컴퓨터 통신망의 역사"></a>컴퓨터 통신망의 역사</h2><ul><li><strong>SAGE(Semi-Automatic Ground Environment) 시스템</strong>: 1958년 미국에서 군사 목적으로 개발된 컴퓨터와 통신을 결합시킨 최초의 컴퓨터 통신 시스템.</li><li><strong>SABRE(Semi-Automatic Business Research Environment) 시스템</strong>: 1961년에 발표된 여객기의 좌석 예약과 회사 업무를 종합적으로 처리하기 위한 상업적인 컴퓨터 통신 시스템.</li><li><strong>CTSS(Compatible Time Sharing System)</strong>: 다수 사용자의 공동 이용을 위해 미국의MIT 대학에서 개발한 시분할 시스템(time sharing system).</li><li><strong>ARPANET</strong>: 1969년 이후 가동되어 1990년까지 운영되었으며 인터넷의 전신이 된 컴퓨터 네트워크 시스템.</li><li><strong>ALOHA(Additive Links Online Hawaii Area) 시스템</strong>: 1968년 하와이 대학에서 실험적으로 시작한 무선 패킷 교환방식의 통신 시스템.</li><li><strong>SNA(System Network Architecture)</strong> : 1974년에 IBM에서 발표한 컴퓨터 간의 접속을 용이하게 하고, 이용 형태의 다양화·복잡화를 대체하기 위한 체계화된 네트워크 구조.</li></ul><h2 id="컴퓨터-통신망의-활용-목적"><a href="#컴퓨터-통신망의-활용-목적" class="headerlink" title="컴퓨터 통신망의 활용 목적"></a>컴퓨터 통신망의 활용 목적</h2><h3 id="자원의-공유"><a href="#자원의-공유" class="headerlink" title="자원의 공유"></a>자원의 공유</h3><p>컴퓨터 통신망이 구축되면 사용자 또는 컴퓨터의 지리적 위치에 관계 없이 컴퓨터 통신망에 연결된 사람이면 누구든지 컴퓨터 자원을 자유롭게 이용할 수 있다.</p><h3 id="신뢰도의-향상-및-안정성-보장"><a href="#신뢰도의-향상-및-안정성-보장" class="headerlink" title="신뢰도의 향상 및 안정성 보장"></a>신뢰도의 향상 및 안정성 보장</h3><p>컴퓨터 통신망이 구축되면 한대의 컴퓨터가 고장나더라도 복구될 때까지 다른 컴퓨터를 사용할 수 있으므로 신뢰도및 안정성이 향상된다. </p><h3 id="처리-기능의-분산"><a href="#처리-기능의-분산" class="headerlink" title="처리 기능의 분산"></a>처리 기능의 분산</h3><p>컴퓨터 통신망이 구축되면 처리 기능을 지역적으로 분산시킴으로써 전체 시스템의 처리 능력을 향상시킬 수 있다. </p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920014864&amp;condLscValue=001&amp;condYr=&amp;condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 정보통신망 1강</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;컴퓨터-통신망의-출현&quot;&gt;&lt;a href=&quot;#컴퓨터-통신망의-출현&quot; class=&quot;headerlink&quot; title=&quot;컴퓨터 통신망의 출현&quot;&gt;&lt;/a&gt;컴퓨터 통신망의 출현&lt;/h2&gt;&lt;p&gt;지역적으로 떨어진 컴퓨터와 컴퓨터를 서로 통신망으로 연결시켜 
      
    
    </summary>
    
      <category term="Base" scheme="http://dev.kyoungah.com/categories/Base/"/>
    
      <category term="Information network" scheme="http://dev.kyoungah.com/categories/Base/Information-network/"/>
    
    
      <category term="Information network" scheme="http://dev.kyoungah.com/tags/Information-network/"/>
    
  </entry>
  
  <entry>
    <title>소프트웨어 위기 현상 및 소프트웨어 공학</title>
    <link href="http://dev.kyoungah.com/2019/03/23/2019-03-23-software-engineering-crisis-engineering/"/>
    <id>http://dev.kyoungah.com/2019/03/23/2019-03-23-software-engineering-crisis-engineering/</id>
    <published>2019-03-23T09:13:28.000Z</published>
    <updated>2019-04-25T05:59:19.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="소프트웨어-위기-현상"><a href="#소프트웨어-위기-현상" class="headerlink" title="소프트웨어 위기 현상"></a>소프트웨어 위기 현상</h2><p>급격한 컴퓨터 하드웨어 기술의 발전으로 인해 사용자의 요구사항이 다양해지면서 해결해야 할 문제는 복잡해졌으나 상대적으로 소프트웨어 기술의 진보가 더딤을 일컫는 말.</p><ul><li>개발 일정이 계획보다 지연된다.</li><li>초과 비용이 발생한다.</li><li>제품의 신뢰도가 결여된다.</li><li>빈번하게 명세와 불일치하는 부분이 나타난다.</li><li>품질 저하와 유지보수의 어려움이 생긴다.</li></ul><h3 id="소프트웨어-위기-현상의-원인"><a href="#소프트웨어-위기-현상의-원인" class="headerlink" title="소프트웨어 위기 현상의 원인"></a>소프트웨어 위기 현상의 원인</h3><ul><li>소프트웨어 공학의 훈련을 받은 전문 인력의 부족.</li><li>소프트웨어에 관한 경영층의 인식 부족.</li><li>일관성 있는 방법론 및 지원 도구의 문제.</li><li>소프트웨어 개발 생산성 저하.</li><li>소프트웨어 자체의 복잡성 증가.</li></ul><h2 id="소프트웨어-공학"><a href="#소프트웨어-공학" class="headerlink" title="소프트웨어 공학"></a>소프트웨어 공학</h2><p>소프트웨어 위기 현상의 해결책으로 표현하기 위해 만들어진 용어.<br>고품질 소프트웨어의 경제적이고 빠른 생산과 유지보수를 위한 전문 작업과 연구 분야가 되었다. </p><ul><li>신롸성 있고 요구기능을 효율적으로 수행하는 소프트웨어를 경제적으로 생산하기 위해 건전한 공학적 원리와 방법을 만들고 사용하는 것.<ul><li>초기 NATO 컨퍼런스에서 바우어 교수가 제시한 정의</li></ul></li><li>소프트웨어의 개발, 운영, 유지보수에 체계적이고 숙달되고 정량화된 접근 방법을 적용하는 것. 즉 소프트웨어에 공학 기술을 적용하는 것 또는 이러한 접근 방법에 관한 연구 분야.<ul><li>IEEE 소프트웨어 공학 표준 용어집에 정의되어 있다. </li></ul></li><li>인간에게 유용한 소프트웨어 제품을 만드는 과정에 과학적 지식을 적용함으로써 실제적 문제의 비용 효율적 해결책을 다루는 일</li></ul><h2 id="소프트웨어-공학-환경"><a href="#소프트웨어-공학-환경" class="headerlink" title="소프트웨어 공학 환경"></a>소프트웨어 공학 환경</h2><p>소프트웨어 개발이 단순히 코드의 생성이 아님을 인식하고 문서화와 프로젝트 관리의 중요성이 인식되었다.<br>개발 과정 초기의 요구사항 명세화 작업에 많은 노력을 기울임으로써 오류를 줄이고 비용을 절약할 수 있다.<br>변경이나 재사용을 염두에 둔 작업 등이 품질, 비용 및 생산성을 향상시킬 수 있다. </p><p>이렇게 다양한 해결 방법들을 통합적으로 다루기 위해 등장한 것이 소프트웨어 공학환경이다.</p><p><img src="/images/base/software-engineering-crisis-engineering-1.png" alt="소프트웨어 공학 환경"></p><p>소프트웨어 공학 환경의 최하위층에 소프트웨어 공학 원리가 위치하고 그 위에 방법과 기술이 위치하며 그 위에 방법론이, 그리고 최상위층에 도구가 위치한다. 각 계층은 그 아래 게층에 기초를 두고 있으며, 아래 계층보다 변화 가능성이 높다. </p><h3 id="스포트웨어-공학-원리"><a href="#스포트웨어-공학-원리" class="headerlink" title="스포트웨어 공학 원리"></a>스포트웨어 공학 원리</h3><p>소프트웨어 프로세스와 제품의 바람직한 측변들을 기술하는 일반적이고 추상적인 설명이다.<br>추상화, 분할 정복, 계층적 조직의 원리 등이 이것에 해당한다. </p><h3 id="방법과-기술"><a href="#방법과-기술" class="headerlink" title="방법과 기술"></a>방법과 기술</h3><ul><li>방법: 행위를 통제하는 체계적이고 일반적인 가이드라인 또는 구조화된 접근 방법.<ul><li>소프트웨어 제품을 정의, 기술, 추상화, 수정, 정제 및 문서화하는 데 필요한 모든 행위들을 포함한다. </li></ul></li><li>기술: 방법에 비해 보다 기계적으로 적용되나 제한된 적용성을 가진다. </li></ul><h3 id="방법론과-도구"><a href="#방법론과-도구" class="headerlink" title="방법론과 도구"></a>방법론과 도구</h3><ul><li>방법론: 프로세스(what)과 방법(how)를 함께 기술하는 것.<ul><li>방법론의 목적은 문제 해결을 위해 사용되어야 할 방법들과 기술들을 지정함으로써 특정 방식의 해법을 권장하는 것이다. </li></ul></li><li>도구: 기술과 방법, 그리고 방법론들의 적용을 지원하기 위해 개발된다.<ul><li>도구를 사용하는 것을 자동화라고 하며 소프트웨어 제품 개발에 필요한 방법들을 구현하기 위해 컴퓨터를 활용하는 것을 말한다. </li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920004346&amp;condLscValue=001&amp;condYr=&amp;condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 소프트웨어 공학 1강</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;소프트웨어-위기-현상&quot;&gt;&lt;a href=&quot;#소프트웨어-위기-현상&quot; class=&quot;headerlink&quot; title=&quot;소프트웨어 위기 현상&quot;&gt;&lt;/a&gt;소프트웨어 위기 현상&lt;/h2&gt;&lt;p&gt;급격한 컴퓨터 하드웨어 기술의 발전으로 인해 사용자의 요구사항
      
    
    </summary>
    
      <category term="Base" scheme="http://dev.kyoungah.com/categories/Base/"/>
    
      <category term="Software engineering" scheme="http://dev.kyoungah.com/categories/Base/Software-engineering/"/>
    
    
      <category term="Software engineering" scheme="http://dev.kyoungah.com/tags/Software-engineering/"/>
    
  </entry>
  
  <entry>
    <title>소프트웨어</title>
    <link href="http://dev.kyoungah.com/2019/03/23/2019-03-23-software-engineering-first/"/>
    <id>http://dev.kyoungah.com/2019/03/23/2019-03-23-software-engineering-first/</id>
    <published>2019-03-23T08:31:24.000Z</published>
    <updated>2019-04-25T05:59:19.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="소프트웨어"><a href="#소프트웨어" class="headerlink" title="소프트웨어"></a>소프트웨어</h2><p>컴퓨터 프로그램과 관련 데이터의 묶음.<br>포괄적 의미에서 소프트웨어란 소스 코드는 물론 모든 관련 문서까지 포함하는데 실행 파일, 설계 문서, 설치 파일, 시스템 메뉴얼과 설치 메뉴얼 및 사용자가 소프트웨어를 사용하는 데 도움을 주도록 작성된 사용자 메뉴얼 등을 포함한다. </p><p>국제전기전자공학회(IEEE)의 정의에 따르면 <code>소프트웨어는 컴퓨터 프로그램, 프로시저의 규칙, 관련된 문서와 데이터의 묶음</code>이다. </p><h2 id="소프트웨어의-중요성"><a href="#소프트웨어의-중요성" class="headerlink" title="소프트웨어의 중요성"></a>소프트웨어의 중요성</h2><ul><li>사업체의 의사결정을 지원하는 엔진이다.</li><li>현대적 과학 탐구와 공학적 문제 해결을 지원하는 기본 도구이다. </li><li>교통, 의료, 원거리 통신, 군사. 산업체 등에 사용되는 모든 종류의 컴퓨터 시스템에 내장되어 있다.</li></ul><p>이렇게 소프트웨어가 사회와 문화에 주는 영향력은 점점 커지고 있다.</p><h2 id="소프트웨어의-분류"><a href="#소프트웨어의-분류" class="headerlink" title="소프트웨어의 분류"></a>소프트웨어의 분류</h2><h3 id="기능적-측면"><a href="#기능적-측면" class="headerlink" title="기능적 측면"></a>기능적 측면</h3><h4 id="시스템-소프트웨어"><a href="#시스템-소프트웨어" class="headerlink" title="시스템 소프트웨어"></a>시스템 소프트웨어</h4><p>컴퓨터를 운영하기 위한 목적의 소프트웨어로 응용 소프트웨어를 실행시키기 위한 플랫폼을 제공한다.</p><p>ex) 운영체제, 장치 드라이버, 컴파일러, DBMS, 유틸리티 프로그램 등…</p><h4 id="응용-소프트웨어"><a href="#응용-소프트웨어" class="headerlink" title="응용 소프트웨어"></a>응용 소프트웨어</h4><p>사용자의 실제 업무를 수행하는 프로그램들로 특정 용도에 사용되도록 만들어진 것.</p><p>ex) 워드프로세서, 스프레드시트, 웹 브라우저, 그래픽처리 프로그램, 게임 프로그램 및 데이터베이스 관리 시스템 등…</p><h3 id="고객-측면"><a href="#고객-측면" class="headerlink" title="고객 측면"></a>고객 측면</h3><h4 id="일반-소프트웨어"><a href="#일반-소프트웨어" class="headerlink" title="일반 소프트웨어"></a>일반 소프트웨어</h4><p>요구사항이 매우 일반적이고 안정적이며, 소프트웨어 엔지니어가 사용 용도를 잘 알고 있는 경우에 불특정 다수를 대상으로 설게된 소프트웨어.<br>공개 시장에서 판매되며 다수의 경쟁 제품이 있을 수 있다.</p><p>ex) 데이터베이스 관련 제품, 워드프로세서, 사무용 소프트웨어 패키지, ERP/CRM 패키지, 운영체제 등…</p><h4 id="맞춤형-소프트웨어"><a href="#맞춤형-소프트웨어" class="headerlink" title="맞춤형 소프트웨어"></a>맞춤형 소프트웨어</h4><p>응용 도메인, 사용 환경 및 요구사항이 특별한 고객을 위해 개발되는 맞춤 소프트웨어.<br>특정 산업에서 나타나는 고유의 업무 프로세스를 위해 작성된다. </p><p>ex) 프로세스 제어 시스템, 교통 관제 시스템, 병원 관리 시스템 등…</p><h2 id="소프트웨어의-성질"><a href="#소프트웨어의-성질" class="headerlink" title="소프트웨어의 성질"></a>소프트웨어의 성질</h2><ul><li>소프트웨어는 무형의 인공물이머 물질적인 성질을 가지지 않는다.<ul><li>물질적인 성질을 가지는 하드웨어와는 그 특성이 다르다.</li></ul></li><li>대부분의 소프트웨어는 기존 컴포넌트들의 조립을 통해 만들어지지 않고 요구사항에 맞추어 새롭게 만들어진다.<ul><li>소프트웨어에 대한 요구사항이 매우 복잡하기 때문에 기존 컴폰넌트를 조립하여 새로운 요구사항을 만족시키기는 매우 어렵다.</li><li>최근에는 ‘CBD(Component Based Development) 분석 방법론’이라고 컴포넌트 기반의 개발 방법이 있긴 하다. </li></ul></li><li>설계 과정의 품질 보등 활동이 소프트웨어의 결정적인 요소가 된다. </li><li>소프트웨어 개발 비용의 대부분이 노동력에 투입된다.</li><li>소프트웨어는 상대적으로 변경이 용이하다. <ul><li>이것을 ‘소프트웨어의 유연성 또는 순응성’이라고 한다.</li></ul></li><li>소프트웨어는 마모디지 않는다. <ul><li>그러나 환경의 변화나 새로운 요구사항의 등장 또는 기대 수준의 향상으로 인해 폐기될 수 있다.</li></ul></li><li>소프트웨어 유지보수는 하드웨어와 달리 많은 경우에 설계의 변경이 요구 된다.</li></ul><h2 id="소프트웨어의-응용-분야"><a href="#소프트웨어의-응용-분야" class="headerlink" title="소프트웨어의 응용 분야"></a>소프트웨어의 응용 분야</h2><h3 id="시스템-소프트웨어-1"><a href="#시스템-소프트웨어-1" class="headerlink" title="시스템 소프트웨어"></a>시스템 소프트웨어</h3><p>다른 소프트웨어를 지원할 목적으로 시스템상에서 실행되는 프로그램.<br>시스템 소프트웨어가 존재하지 않는다면 컴퓨터 시스템은 작동될 수 없다.</p><h3 id="실시간-소프트웨어"><a href="#실시간-소프트웨어" class="headerlink" title="실시간 소프트웨어"></a>실시간 소프트웨어</h3><p>이벤트 발생과 처리가 실시간으로 이루어지는 시스템.</p><p>ex) 은행 업무 시스템, 좌석 예약 시스템 등…</p><h3 id="내장형-소프트웨어"><a href="#내장형-소프트웨어" class="headerlink" title="내장형 소프트웨어"></a>내장형 소프트웨어</h3><p>대형 시스템의 일부로 하드웨어에 내장되어 특정 조건하에서 고유의 기능을 수행하도록 작성된 소프트웨어.<br>자동차, 세탁기, 전자레인지, 주유기, 인공위성 및 많은 자동 제어 시스템에 내장된 소프트웨어.</p><h3 id="비즈니스-소프트웨어"><a href="#비즈니스-소프트웨어" class="headerlink" title="비즈니스 소프트웨어"></a>비즈니스 소프트웨어</h3><p>사업 목적의 업무를 처리하기 위해 설계된 소프트웨어.</p><p>ex) 회계 업무 패키지, 경영 정보 시스템, 급여 관리 패키지 및 재고 관리 목적의 소프트웨어 등…</p><h3 id="개인용-소프트웨어"><a href="#개인용-소프트웨어" class="headerlink" title="개인용 소프트웨어"></a>개인용 소프트웨어</h3><p>개인 사용자를 위한 소프트웨어.</p><p>ex) 워드 프로세서, 스프레드시트, 그래픽 프로그램, 멀티미디어, 오락 프로그램, 네트워크 유틸리티 등…</p><h3 id="인공지능-소프트웨어"><a href="#인공지능-소프트웨어" class="headerlink" title="인공지능 소프트웨어"></a>인공지능 소프트웨어</h3><p>단순한 수치게산이나 정형적인 프로시저를 사용하지 못하는 복잡한 문제를 해결하기 위한 소프트웨어.</p><p>ex) 로보틱스, 전문가 시스템, 화상/음성 인식, 인공 신경망, 정리 증명 등…</p><h3 id="웹-기반-소프트웨어"><a href="#웹-기반-소프트웨어" class="headerlink" title="웹 기반 소프트웨어"></a>웹 기반 소프트웨어</h3><p>웹 브라우저에서 표현되거나 실행되는 소프트웨어.</p><h3 id="공학용-과학용-소프트웨어"><a href="#공학용-과학용-소프트웨어" class="headerlink" title="공학용/과학용 소프트웨어"></a>공학용/과학용 소프트웨어</h3><p>공학이나 과학 분야의 특정 원리나 공식을 사용하여 해당 분야의 특정 기능을 수행하도록 설계된 소프트웨어.</p><h2 id="좋은-소프트웨어의-기준"><a href="#좋은-소프트웨어의-기준" class="headerlink" title="좋은 소프트웨어의 기준"></a>좋은 소프트웨어의 기준</h2><p>소프트웨어의 특성을 좌우하는 여러 품질 기준이 존재한다.<br>사용성이나 신뢰도와 같이 사용자가 인지할 수 있는 것을 ‘외부 품질’ 이라고 한다.<br>‘내부 품질’의 향상은 개발자가 외부 품질을 개선하는데 도움을 줄 수 있다. 잘 작성된 요구사항이나 설계 문서는 보통의 사용자가 볼 수는 없으나 대부분의 외부 품질 요소들을 개선할 때 반드시 필요한 것이다.</p><h3 id="소프트웨어의-신뢰도"><a href="#소프트웨어의-신뢰도" class="headerlink" title="소프트웨어의 신뢰도"></a>소프트웨어의 신뢰도</h3><p>사용자가 소프트웨어를 신뢰하는 정도를 의미한다.<br>오랜 시간 작동되며, 알려진 치명적 오류가 없으며, 오류발생 후에 무난히 복구되며, 강건하다는 의미를 포함한다.</p><p>일반적으로 행위 분석을 통한 통계값으로 신뢰도를 측정한다. 다른 방법으로는 고장 확률 또는 고장 빈도를 시간 함수로 정의하는 것이다.</p><p>소프트웨어는 시간에 지남에 따라 오류 발견 및 수정으로 고장 빈도는 꾸준히 감소되면서 안정 상태가 되고 폐기될 때까지 유지된다. 그러나 경우에 따라 소프트웨어 고장 함수가 욕조 곡선과 유사한 형태를 가지는 경우가 있다.</p><blockquote><p>욕조 곡선: 시스템 안전 공학 용어로써 고장률 유형을 설명하는데 이용된다.</p></blockquote><ul><li>소프트웨어 버그를 수정하거나 새로운 기능을 추가하면서 생기는 사이드 이펙트.</li><li>엔지니어가 예상하지 못했던 하드웨어나 운영체제를 변경하는 경우.</li><li>사용자가 소프트웨어에 익숙해지면서 적정 용량이나 성능을 초과하는 입력을 주어 소프트웨어가 스트레스를 받게 되고, 그때 충분히 테스트되지 못한 기능들이 사용되어 오류가 발생하기 때문.</li></ul><h3 id="소프트웨어의-정확성"><a href="#소프트웨어의-정확성" class="headerlink" title="소프트웨어의 정확성"></a>소프트웨어의 정확성</h3><p>명세서와 일치하게 작동하는 능력.<br>사용자의 요구를 만족시키는 능력.</p><p>소프트웨어의 행위가 요구사항에 비추어 아주 작은 차이가 있는 경우에 이것은 결함으로 간주되고 소프트웨어는 정확하지 못하다는 뜻이 된다. 그러나 이런 경우가 무조건 소프트웨어의 실제 고장으로 연결되지는 않고 따라서 신뢰도가 있다고 판단될 수 있다.</p><h3 id="소프트웨어의-성능"><a href="#소프트웨어의-성능" class="headerlink" title="소프트웨어의 성능"></a>소프트웨어의 성능</h3><p>지정된 시간 안에 컴퓨터 시스템에서 처리할 수 있는 작업량.<br>주어진 시간 동안에 보다 많은 작업을 수행할 수 있는 경우에 성능이 높다고 한다. </p><h3 id="소프트웨어의-사용성"><a href="#소프트웨어의-사용성" class="headerlink" title="소프트웨어의 사용성"></a>소프트웨어의 사용성</h3><p>시스템을 본래의 설계 목적에 따라 효율성 있게 사용할 수 있는 정도를 의미한다. </p><h3 id="소프트웨어의-상호운영성"><a href="#소프트웨어의-상호운영성" class="headerlink" title="소프트웨어의 상호운영성"></a>소프트웨어의 상호운영성</h3><p>소프트웨어 시스템이 다른 시스템과 공존하며 협력할 수 있는 능력을 의미한다.</p><h3 id="소프트웨어의-유지보수성"><a href="#소프트웨어의-유지보수성" class="headerlink" title="소프트웨어의 유지보수성"></a>소프트웨어의 유지보수성</h3><p>소프트웨어는 유연하기 때문에 변경되기 쉽다.<br>상대적으로 변경시키기 쉬운 소프트웨어가 유지보수성이 높다고 한다. </p><p>유지보수 작업은 새로운 기능 추가, 기존 기능의 개선, 환경의 변화에 따른 기존 기능의 수정, 그리고 존재하는 오류를 수정하는 경우로 나누어 생각할 수 있다.</p><h3 id="소프트웨어의-이식성"><a href="#소프트웨어의-이식성" class="headerlink" title="소프트웨어의 이식성"></a>소프트웨어의 이식성</h3><p>다른 환경에서 쉽게 동작이 가능하다면 소프트웨어의 이식성이 좋다고 한다.</p><p>소프트웨어에서 환경이란 소프트웨어가 탑재되는 하드웨어, 운영체제 또는 상호작용하는 다른 시스템을 말한다. </p><h3 id="소프트웨어의-검사성"><a href="#소프트웨어의-검사성" class="headerlink" title="소프트웨어의 검사성"></a>소프트웨어의 검사성</h3><p>다른 기술 품질 요소들을 포함하여 소프트웨어의 속성들을 쉽게 검사할 수 있는 경우에 검사성이 좋다고 한다.</p><p>검사성을 측정하는 손쉬운 방법 중 하나는 성능이나 정확성과 같은 품질 요소를 검사하기 위한 코드를 삽입하는 것이다.</p><h3 id="소프트웨어의-추적성"><a href="#소프트웨어의-추적성" class="headerlink" title="소프트웨어의 추적성"></a>소프트웨어의 추적성</h3><p>요구사항 변경을 처리하기 위해서는 특정 요구사항을 제안한 관련자와 제안 이유, 이것에 영향받는 다른 요구사항들, 그리고 어느 설계 문서와 어느 소스 코드에 반영되었는지 파악 할 수 있어야 한다. </p><ul><li>요구사항으로부터 요구사항을 제안한 관련자를 파악.</li><li>관련성이 있는 요구사항들을 파악.</li><li>요구사항으로부터 관련 설계 문서를 파악.</li><li>설계 문서로부터 관련 코드 조각을 파악.</li><li>요구사항으로부터 테스트 계획서를 파악.</li><li>테스트 계획서로부터 테스트 케이스를 파악.</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920004346&amp;condLscValue=001&amp;condYr=&amp;condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 소프트웨어 공학 1강</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;소프트웨어&quot;&gt;&lt;a href=&quot;#소프트웨어&quot; class=&quot;headerlink&quot; title=&quot;소프트웨어&quot;&gt;&lt;/a&gt;소프트웨어&lt;/h2&gt;&lt;p&gt;컴퓨터 프로그램과 관련 데이터의 묶음.&lt;br&gt;포괄적 의미에서 소프트웨어란 소스 코드는 물론 모든 관련 문
      
    
    </summary>
    
      <category term="Base" scheme="http://dev.kyoungah.com/categories/Base/"/>
    
      <category term="Software engineering" scheme="http://dev.kyoungah.com/categories/Base/Software-engineering/"/>
    
    
      <category term="Software engineering" scheme="http://dev.kyoungah.com/tags/Software-engineering/"/>
    
  </entry>
  
  <entry>
    <title>합병정렬</title>
    <link href="http://dev.kyoungah.com/2019/03/18/2019-03-17-algorithms-merge-sort/"/>
    <id>http://dev.kyoungah.com/2019/03/18/2019-03-17-algorithms-merge-sort/</id>
    <published>2019-03-17T16:13:13.000Z</published>
    <updated>2019-04-25T05:59:19.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="합병정렬"><a href="#합병정렬" class="headerlink" title="합병정렬"></a>합병정렬</h2><p>배열을 동일한 크기의 두 개의 부분배열로 분할하고 각각의 부분 배열을 순환적으로 정렬한 후, 정렬된 두 부분배열을 합병하여 하나의 정렬된 배열을 만든다.</p><h3 id="분할"><a href="#분할" class="headerlink" title="분할"></a>분할</h3><p>입력의 크기가 n인 배열을 n/2개의 원소를 가진 두 부분배열로 분할한다.</p><h3 id="정복"><a href="#정복" class="headerlink" title="정복"></a>정복</h3><p>각각의 부분배열에 대해서 합병 정렬을 순환적으로 적용하여 각 부분배열을 정렬한다. </p><h3 id="결합"><a href="#결합" class="headerlink" title="결합"></a>결합</h3><p>정렬된 두 부분배열을 합병하여 하나의 정렬된 배열을 만든다.</p><p><img src="/images/base/algorithms-merge-sort-1.png" alt="합병정렬"></p><h2 id="알고리즘"><a href="#알고리즘" class="headerlink" title="알고리즘"></a>알고리즘</h2><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> sorted[], <span class="hljs-keyword">int</span> leftIndex, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> rightIndex)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> l_hold = leftIndex, r_hold = mid + <span class="hljs-number">1</span>;</span><br><span class="line">  <span class="hljs-keyword">int</span> resultIndex = leftIndex; <span class="hljs-comment">// 결과 배열의 index</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">while</span>(l_hold &lt;= mid &amp;&amp; r_hold &lt;= rightIndex) &#123;</span><br><span class="line">    <span class="hljs-comment">// 부분배열 두개를 비교하여 작은 값을 선택한다.</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (arr[l_hold] &lt; arr[r_hold]) &#123;</span><br><span class="line">      sorted[resultIndex] = arr[l_hold];</span><br><span class="line"></span><br><span class="line">      l_hold++;</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      sorted[resultIndex] = arr[r_hold];</span><br><span class="line"></span><br><span class="line">      r_hold++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resultIndex++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 왼쪽 부분배열에 남아있는 모든 원소를 새로은 배열로 이동시킨다.</span></span><br><span class="line">  <span class="hljs-keyword">while</span> (l_hold &lt;= mid) &#123;</span><br><span class="line">    sorted[resultIndex] = arr[l_hold];</span><br><span class="line"></span><br><span class="line">    resultIndex ++;</span><br><span class="line">    l_hold ++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 오른쪽 부분배열에 남아있는 모든 원소를 새로은 배열로 이동시킨다.</span></span><br><span class="line">  <span class="hljs-keyword">while</span> (r_hold &lt;= rightIndex) &#123;</span><br><span class="line">    sorted[resultIndex] = arr[r_hold];</span><br><span class="line"></span><br><span class="line">    resultIndex ++;</span><br><span class="line">    r_hold ++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 원본 배열에 정렬된 배열을 이동 시킨다.</span></span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = leftIndex; i &lt;= rightIndex; i++) &#123;</span><br><span class="line">    arr[i] = sorted[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> sorted[], <span class="hljs-keyword">int</span> leftIndex, <span class="hljs-keyword">int</span> rightIndex)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (leftIndex &lt; rightIndex) &#123;</span><br><span class="line">    <span class="hljs-comment">// 각각 n/2크기를 가진 두 부분배열로 나누기 위해 가운데 값 정함.</span></span><br><span class="line">    <span class="hljs-keyword">int</span> mid = (leftIndex + rightIndex) / <span class="hljs-number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 왼쪽 부분배열의 순환호출</span></span><br><span class="line">    mergeSort(arr, sorted, leftIndex, mid);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 오른쪽 부분배열의 순환호출</span></span><br><span class="line">    mergeSort(arr, sorted, mid + <span class="hljs-number">1</span>, rightIndex);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 정렬된 두 부분배열의 합병</span></span><br><span class="line">    merge(arr, sorted, leftIndex, mid, rightIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="성능-분석"><a href="#성능-분석" class="headerlink" title="성능 분석"></a>성능 분석</h2><h3 id="합병-함수-수행-시간"><a href="#합병-함수-수행-시간" class="headerlink" title="합병 함수 수행 시간"></a>합병 함수 수행 시간</h3><p>합병 함수 수행 시간 = 부분배열[n/2] + 부분배열[n/2] = 배열[n]</p><p>두 부분 배열을 합병하면 최악의 경우 결과 배열엔 n + m개의 원소가 저장되는에 이때 최악의 경우  n + m - 1회의 비교가 필요하다. </p><ul><li>최소 비교횟수: $\frac{n}{2}$</li><li>최대 비교횟수: ($\frac{n}{2}$ + $\frac{n}{2}$ - 1) = n - 1;<br>=&gt; 입력 데이터 개수만큼의 저장 장소가 추가로 필요하다.</li></ul><p>결국 합병을 하는데 걸리는 시간은 입력 크기 n에 비례하므로 Θ(n)이 된다. </p><h3 id="합병-정렬-수행-시간"><a href="#합병-정렬-수행-시간" class="headerlink" title="합병 정렬 수행 시간"></a>합병 정렬 수행 시간</h3><p>합병 정렬 수행시간 = 크기 n/2인 두번의 합병 정렬 순환 호출 + 한번의 합병</p><p>T(1) = 1;<br>T(n) = T($\frac{n}{2}$) + T($\frac{n}{2}$) + Θ(n);</p><p>=&gt; T(n) = 2T($\frac{n}{2}$) + Θ(n)<br>=&gt; T(n) = O($n log n$)</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920026935&amp;condLscValue=001&amp;condYr=&amp;condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 알고리즘 4강</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;합병정렬&quot;&gt;&lt;a href=&quot;#합병정렬&quot; class=&quot;headerlink&quot; title=&quot;합병정렬&quot;&gt;&lt;/a&gt;합병정렬&lt;/h2&gt;&lt;p&gt;배열을 동일한 크기의 두 개의 부분배열로 분할하고 각각의 부분 배열을 순환적으로 정렬한 후, 정렬된 두 부분배열
      
    
    </summary>
    
      <category term="Base" scheme="http://dev.kyoungah.com/categories/Base/"/>
    
      <category term="Algorithms" scheme="http://dev.kyoungah.com/categories/Base/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://dev.kyoungah.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>프로세스 제어 블록</title>
    <link href="http://dev.kyoungah.com/2019/03/17/2019-03-06-operating-systems-pcb/"/>
    <id>http://dev.kyoungah.com/2019/03/17/2019-03-06-operating-systems-pcb/</id>
    <published>2019-03-17T13:31:51.000Z</published>
    <updated>2019-04-25T05:59:19.487Z</updated>
    
    <content type="html"><![CDATA[<h2 id="프로세스-제어-블록-PCB"><a href="#프로세스-제어-블록-PCB" class="headerlink" title="프로세스 제어 블록(PCB)"></a>프로세스 제어 블록(PCB)</h2><p>프로세스를 관리하기 위해 운영체제는 각 프로세스마다 프로세스 제어블록(PCB)을 두고서 여기에 해당 프로세스의 정보를 보관한다. 프로세스가 진행함에 따라 PCB의 내용은 변경된다.<br>프로세스가 종료되면 해당 프로세스 제어 블록도 없어지게 된다. </p><p><img src="/images/base/operating-systems-pcb-1.png" alt="프로세스 제어 블록의 내용"></p><h3 id="프로세스-상태"><a href="#프로세스-상태" class="headerlink" title="프로세스 상태"></a>프로세스 상태</h3><p>프로세스의 현재 상태를 나타낸다. </p><h3 id="프로세스-번호-PID"><a href="#프로세스-번호-PID" class="headerlink" title="프로세스 번호(PID)"></a>프로세스 번호(PID)</h3><p>프로세스의 기준이 되는 ID를 나타낸다.</p><h3 id="프로그램-카운터-PC"><a href="#프로그램-카운터-PC" class="headerlink" title="프로그램 카운터(PC)"></a>프로그램 카운터(PC)</h3><p>프로세스 수행을 위한 다음 명령의 주소를 표시한다.</p><h3 id="레지스터-register"><a href="#레지스터-register" class="headerlink" title="레지스터(register)"></a>레지스터(register)</h3><p>CPU의 레지스터에 해당하는 정보들을 포함한다.<br>실행상테에서 다른 상태로 전이될 때 CPU의 레지스터 정보를 이곳에 저장시켜서 나중에 다시 실행상태로 전이될 때 복구시켜 프로세스의 정확한 수행을 계속할 수 있도록 한다.</p><h3 id="메모리"><a href="#메모리" class="headerlink" title="메모리"></a>메모리</h3><p>프로세스가 저장된 주소와 가상 메모리를 사용하는 경우에는 가상주소와 실제 주소의 사상정보, 기준 레지스터와 경계 레지스터 등의 정보를 포함한다.</p><h3 id="프로세스-우선순위"><a href="#프로세스-우선순위" class="headerlink" title="프로세스 우선순위"></a>프로세스 우선순위</h3><p>우선순위를 이용하여 스케줄링 시 어떤 작업을 선택 할 것인가를 결정하는데 필요한 정보를 포함한다.</p><h3 id="회계-정보"><a href="#회계-정보" class="headerlink" title="회계 정보"></a>회계 정보</h3><p>주로 성능 측정과 순위에 대한 목적을 위한 정보로서, CPU 사용 시간, 프로세스의 시스템 존재 시간, 메모리 사용량, 보조기억장치 사용량, 기타 시스템 프로그램의 사용 실태 등 다양한 정보를 포함하고 있다. </p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920017322&amp;condLscValue=001&amp;condYr=&amp;condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 운영체제 2강</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;프로세스-제어-블록-PCB&quot;&gt;&lt;a href=&quot;#프로세스-제어-블록-PCB&quot; class=&quot;headerlink&quot; title=&quot;프로세스 제어 블록(PCB)&quot;&gt;&lt;/a&gt;프로세스 제어 블록(PCB)&lt;/h2&gt;&lt;p&gt;프로세스를 관리하기 위해 운영체제는 
      
    
    </summary>
    
      <category term="Base" scheme="http://dev.kyoungah.com/categories/Base/"/>
    
      <category term="Operating systems" scheme="http://dev.kyoungah.com/categories/Base/Operating-systems/"/>
    
    
      <category term="Operating systems" scheme="http://dev.kyoungah.com/tags/Operating-systems/"/>
    
  </entry>
  
  <entry>
    <title>퀵 정렬</title>
    <link href="http://dev.kyoungah.com/2019/03/17/2019-03-11-algorithms-quick-sort/"/>
    <id>http://dev.kyoungah.com/2019/03/17/2019-03-11-algorithms-quick-sort/</id>
    <published>2019-03-17T10:15:00.000Z</published>
    <updated>2019-04-25T05:59:19.488Z</updated>
    
    <content type="html"><![CDATA[<h2 id="퀵-정렬"><a href="#퀵-정렬" class="headerlink" title="퀵 정렬"></a>퀵 정렬</h2><p>특정 원소를 기준으로 주어진 배열을 두 부분배열로 분할하고, 각 부분배열에 대해서 퀵 정렬을 순환적으로 적용하는 방식.<br>특정 원소를 <strong>피벗</strong> 이라고 부름. 즉, 피벗이 제자리를 잡조록 하여 정렬하는 방식. 피벗의 왼쪽 부분배열엔 피벗보다 작은 값이, 오른쪽 부분배열엔 피벗보다 큰 값이 온다.</p><ul><li>피벗: 두 부분배열로 분할할 때 기준에 되는 특정 원소. 보통 주어진 배열의 첫 번째 원소로 지정한다. </li></ul><h3 id="분할"><a href="#분할" class="headerlink" title="분할"></a>분할</h3><p>피벗을 기준으로 주어진 배열을 두 부분배열로 분할한다.</p><h3 id="정복"><a href="#정복" class="headerlink" title="정복"></a>정복</h3><p>두 부분배열에 대해서 퀵 정렬을 순환적으로 적용하여 각 부분배열을 정렬한다.</p><h3 id="결합"><a href="#결합" class="headerlink" title="결합"></a>결합</h3><p>필요 없음</p><p><img src="/images/base/algorithms-quick-sort-1.png" alt="퀵정렬"></p><h2 id="알고리즘"><a href="#알고리즘" class="headerlink" title="알고리즘"></a>알고리즘</h2><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> temp = arr[a];</span><br><span class="line">    arr[a] = arr[b];</span><br><span class="line">    arr[b] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 배열의 맨 오른쪽 index엔 무한대 값이 있다고 가정한다.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> leftIndex, <span class="hljs-keyword">int</span> rightIndex)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">// 맨 왼쪽을 피벗으로 잡기 때문에 l_hold는 피벗의 위치 + 1, r_hold는 배열의 마지막 index</span></span><br><span class="line">  <span class="hljs-keyword">int</span> pivot = arr[leftIndex], l_hold = leftIndex + <span class="hljs-number">1</span>, r_hold = rightIndex;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">while</span> (l_hold &lt;= r_hold) &#123;</span><br><span class="line">    <span class="hljs-comment">// l_hold는 피벗보다 큰 값을 찾는다.</span></span><br><span class="line">    <span class="hljs-keyword">while</span> (l_hold &lt;= rightIndex &amp;&amp; arr[l_hold] &lt; pivot) &#123;</span><br><span class="line">      l_hold++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// r_hold는 피벗보다 작은 값을 찾는다.</span></span><br><span class="line">    <span class="hljs-keyword">while</span> (r_hold &gt; leftIndex &amp;&amp; arr[r_hold] &gt;= pivot) &#123;</span><br><span class="line">      r_hold--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">if</span> (l_hold &lt; r_hold) &#123;</span><br><span class="line">      <span class="hljs-comment">// arr[l_hold]와 arr[r_hold]의 값을 교환한다.</span></span><br><span class="line">      swap(arr, l_hold, r_hold);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 피벗과 arr[r_hold]값을 교환한다. </span></span><br><span class="line">  swap(arr, leftIndex, r_hold);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> r_hold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> leftIndex, <span class="hljs-keyword">int</span> rightIndex)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (leftIndex &lt;= rightIndex) &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> pivot = partition(arr, leftIndex, rightIndex); <span class="hljs-comment">// 두 부분배열로 분할</span></span><br><span class="line"></span><br><span class="line">    quickSort(arr, leftIndex, pivot - <span class="hljs-number">1</span>);  <span class="hljs-comment">// 왼쪽 부분배열에 대해 순환호출</span></span><br><span class="line">    quickSort(arr, pivot + <span class="hljs-number">1</span>, rightIndex); <span class="hljs-comment">// 오른쪽 부분배열에 대해서 순환호출</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="성능-분석"><a href="#성능-분석" class="headerlink" title="성능 분석"></a>성능 분석</h2><p>퀵 정렬 알고리즘은 한 번의 분할과 두 번의 순환 호출로 구성된다.</p><h3 id="분할-함수-수행-시간"><a href="#분할-함수-수행-시간" class="headerlink" title="분할 함수 수행 시간"></a>분할 함수 수행 시간</h3><p>피벗을 제외한 배열의 원소들은 피벗과 최대 2번 비교 하게 된다. 전체적으로는 입력 크기 n에 비례하는 Θ(n) 시간이 걸린다.</p><h3 id="퀵-정렬-수행-시간"><a href="#퀵-정렬-수행-시간" class="headerlink" title="퀵 정렬 수행 시간"></a>퀵 정렬 수행 시간</h3><p>퀵 정렬 수행 시간 = 한 번의 분할 + 두번의 킉정렬 순환 호출.<br>배열 부분 시 두 부분배열의 크기가 다르기 때문에  배열이 어떤 크기의 두 부분배열로 분할되느냐에 따라 수행 시간이 다르다.</p><h4 id="최악의-경우"><a href="#최악의-경우" class="headerlink" title="최악의 경우"></a>최악의 경우</h4><p>극심한 불균형적 분할.</p><ul><li>피벗만 제자리를 잡고, 나머지 모든 원소가 하나의 부분배열로 분할되는 경우</li><li>피벗이 항상 부분배열의 최솟값, 또는 최댓값이 되는 경우</li><li>입력 데이터가 정렬되어 있고 피벗을 배열의 처음 원소로 지정한 경우</li></ul><p>T(n) = T(n-1) + T(0) + Θ(n) (n &gt; 0) // 한쪽은 데이터가 없으므로 T(0)<br>T(0) = 0</p><p>=&gt; T(n) = T(n - 1) + Θ(n)<br>=&gt; T(n) = O($n^2$)</p><h3 id="최선의-경우"><a href="#최선의-경우" class="headerlink" title="최선의 경우"></a>최선의 경우</h3><p>가장 균형적인 분할.</p><ul><li>피벗을 중심으로 항상 동일한 크기의 두 부분배열로 분할되는 경우 </li><li>피벗이 항상 부분배열의 중간값이 되는 경우 </li></ul><p>T(n) = T($\frac{n}{2}$) + T($\frac{n}{2}$) + Θ(n) (n &gt; 1)<br>T(1) = 1</p><p>=&gt; T(n) = 2T($\frac{n}{2}$) + Θ(n)<br>=&gt; T(n) = O($n log n$)</p><h3 id="평균적인-경우"><a href="#평균적인-경우" class="headerlink" title="평균적인 경우"></a>평균적인 경우</h3><p>부분배열의 모든 분할 비율에 따른 수행 시간의 평균.</p><ul><li>피벗은 동일한 확률로서 분할 후 배열의 어느 곳에나 위치 가능 </li></ul><p>T(1) = T(0) = 0<br>T(n) = $\frac{1}{n}\sum_{i = 1}^{n}(T(i - 1) + T(n - i)) + O(n) (n &gt;= 2)$</p><p>=&gt; T(n) = O($n log n$)</p><h2 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h2><ul><li>최선/ 평균의 경우 O($n log n$)</li><li>최악의 경우 O($n^2$)</li></ul><p>즉 피벗 선택의 임의성만 보장되면 평균적인 성능을 보일 가능성이 매우 높다. 그래서 배열에서 임의로 값을 선택해서 배열의 처음 원소와 서로 교환 후 정렬 수행하면 최악의 경우를 피할 가능성이 커진다. </p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920026935&amp;condLscValue=001&amp;condYr=&amp;condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 알고리즘 3강</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;퀵-정렬&quot;&gt;&lt;a href=&quot;#퀵-정렬&quot; class=&quot;headerlink&quot; title=&quot;퀵 정렬&quot;&gt;&lt;/a&gt;퀵 정렬&lt;/h2&gt;&lt;p&gt;특정 원소를 기준으로 주어진 배열을 두 부분배열로 분할하고, 각 부분배열에 대해서 퀵 정렬을 순환적으로 적용하는
      
    
    </summary>
    
      <category term="Base" scheme="http://dev.kyoungah.com/categories/Base/"/>
    
      <category term="Algorithms" scheme="http://dev.kyoungah.com/categories/Base/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://dev.kyoungah.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>이진 탐색</title>
    <link href="http://dev.kyoungah.com/2019/03/17/2019-03-11-algorithms-binary-search/"/>
    <id>http://dev.kyoungah.com/2019/03/17/2019-03-11-algorithms-binary-search/</id>
    <published>2019-03-16T18:03:57.000Z</published>
    <updated>2019-04-25T05:59:19.488Z</updated>
    
    <content type="html"><![CDATA[<h2 id="이진탐색"><a href="#이진탐색" class="headerlink" title="이진탐색"></a>이진탐색</h2><ul><li><strong>탐색</strong>: 배열 형태로 주어진 데이터에서 원하는 값을 가진 데이터를 찾는 문제.</li><li><strong>이진 탐색</strong>: 정렬된 상태의 데이텅에 대해 적용 가능한 효과적인 탐색 방법.</li></ul><h2 id="탐색-방법"><a href="#탐색-방법" class="headerlink" title="탐색 방법"></a>탐색 방법</h2><p>배열은 오름차순 정렬 되어 있다고 가정한다.</p><p>###분할<br>배열의 가운데 원소를 기준으로 왼쪽 부분배열과 오른쪽 부분배열로 분할한다. 탐색키 x가 가운데 원소와 같으면 가운데 원소에 해당하는 배열의 인덱스를 반환하고 종료한다.</p><p>###정복<br>x가 가운데 원소보다 작으면 왼쪽 부분배열을 대상으로 이진 탐색을 순환호출 하고, 크면 오른쪽 부분배열을 대상으로 이진 탐색을 순환호출한다. 탐색을 다시 수행할 때마다 탐색 범위가 절반으로 줄어든다.</p><h3 id="결합"><a href="#결합" class="headerlink" title="결합."></a>결합.</h3><p>부분배열에 대해서 이진 탐색의 결과가 직접 반환되므로 결과를 결합할 필요가 없다. </p><p><img src="/images/base/algorithms-binary-search-1.png" alt="이진 탐색 분할"></p><h2 id="알고리즘"><a href="#알고리즘" class="headerlink" title="알고리즘"></a>알고리즘</h2><h3 id="재귀함수"><a href="#재귀함수" class="headerlink" title="재귀함수"></a>재귀함수</h3><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> leftIndex, <span class="hljs-keyword">int</span> rightIndex, <span class="hljs-keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// 탐색 실패</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (leftIndex &gt; rightIndex) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">int</span> mid = (leftIndex + rightIndex) / <span class="hljs-number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (x == arr[mid]) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> mid;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (x &lt; arr[mid]) &#123;</span><br><span class="line">    <span class="hljs-comment">// 왼족 배열 탐색</span></span><br><span class="line">    <span class="hljs-keyword">return</span> binarySearch(arr, leftIndex, mid - <span class="hljs-number">1</span>, x);</span><br><span class="line">  &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">    <span class="hljs-comment">// 오른쪽 배열 탐색</span></span><br><span class="line">    <span class="hljs-keyword">return</span> binarySearch(arr, mid + <span class="hljs-number">1</span>, rightIndex, x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="반복함수"><a href="#반복함수" class="headerlink" title="반복함수"></a>반복함수</h3><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch_Iteration</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> leftIndex = <span class="hljs-number">0</span>, rightIndex = index - <span class="hljs-number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="hljs-keyword">while</span>(leftIndex &lt;= rightIndex) &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> mid = (leftIndex + rightIndex) / <span class="hljs-number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (x == arr[mid]) &#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (x &lt; arr[mid]) &#123;</span><br><span class="line">      <span class="hljs-comment">// 왼쪽 부분배열 탐색</span></span><br><span class="line">      rightIndex = mid - <span class="hljs-number">1</span>;</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      <span class="hljs-comment">// 오른쪽 부분배열 탐색</span></span><br><span class="line">      leftIndex = mid + <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 탐색키가 존재하지 않을 경우</span></span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>이진 탐색에서는 분할 될 때마다 입력 크기가 절반으로 감소 하며, 탐색 대상의 개수가 1이 되면 더는 분할이 수행되지 않고 탐색 성공 여부가 결정된다.</p><h2 id="성능-분석"><a href="#성능-분석" class="headerlink" title="성능 분석"></a>성능 분석</h2><p>T(n) = 입력 크기 n에 대한 탐색 과정에서의 모든 비교 횟수의 합 = 맨 바깥 수준에서의 비교 횟수 + 순환 호출에서의 비교 횟수.</p><p>맨 바깥 수준에서의 비교 횟수는 상수이므로 1.<br>순환 호출에서의 비교 횟수는 비교 할 때마다 절반 씩 데이터를 나누므로 $\frac{n}{2}$.</p><p>T(n) = T($\frac{n}{2}$) + O(1)(n &gt; 1), T(1) = 1;<br>T(n) = O($logn$)</p><h2 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h2><ul><li>입력이 정렬된 리스트에 대해서만 적용이 가능하다.</li><li>데이터의 삽입/삭제 연산을 수행하면 데이터의 이동이 발생한다.<ul><li>평균 $\frac{2}{n}$개의 데이터 이동이 발생하므로 삽입/삭제가 빈번한 응용에는 부적합하다.</li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920026935&amp;condLscValue=001&amp;condYr=&amp;condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 알고리즘 3강</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;이진탐색&quot;&gt;&lt;a href=&quot;#이진탐색&quot; class=&quot;headerlink&quot; title=&quot;이진탐색&quot;&gt;&lt;/a&gt;이진탐색&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;탐색&lt;/strong&gt;: 배열 형태로 주어진 데이터에서 원하는 값을 가진 데이터를 찾는 
      
    
    </summary>
    
      <category term="Base" scheme="http://dev.kyoungah.com/categories/Base/"/>
    
      <category term="Algorithms" scheme="http://dev.kyoungah.com/categories/Base/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://dev.kyoungah.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>프로세스</title>
    <link href="http://dev.kyoungah.com/2019/03/16/2019-03-06-operating-systems-process/"/>
    <id>http://dev.kyoungah.com/2019/03/16/2019-03-06-operating-systems-process/</id>
    <published>2019-03-16T13:34:05.000Z</published>
    <updated>2019-04-25T05:59:19.487Z</updated>
    
    <content type="html"><![CDATA[<h2 id="프로세스"><a href="#프로세스" class="headerlink" title="프로세스"></a>프로세스</h2><p>실행 중인 프로그램.</p><ul><li>프로그램: 동작을 하지 않는 정적, 수동적 개체 </li><li>프로세스: 동작을 하는 능동적 개체</li></ul><p>프로세스의 동작은 CPU가 그 프로세스의 명령들을 실행하는 것이다. </p><ul><li>자원: CPU, 메모리, 입출력장치, 파일 등</li><li>동작: CPU가 프로세스의 명령을 실행</li></ul><p>운영체제는 실행할 준비가 된 프로세스들이 적절히 CPU를 배정받아 효율적으로 작업을 처리할 수 있도록 관리해야 한다. </p><h2 id="프로세스-간의-관계"><a href="#프로세스-간의-관계" class="headerlink" title="프로세스 간의 관계"></a>프로세스 간의 관계</h2><h3 id="독립적-프로세스"><a href="#독립적-프로세스" class="headerlink" title="독립적 프로세스"></a>독립적 프로세스</h3><p>시스템에서 실행 중인 다른 프로세스의 영향을 받지도 않고 주지도 않는 프로세스.</p><ul><li>프로세스의 상태와 데이터는 다른 프로세스와 공유되지 않는다. </li><li>프로세스의 실행은 결정적이며 재생 가능하다.</li><li>프로세스의 실행은 타 프로세스와 무관하게 중단되거나 재시작될 수 있다.</li></ul><h3 id="유기적-프로세스"><a href="#유기적-프로세스" class="headerlink" title="유기적 프로세스"></a>유기적 프로세스</h3><p>시스템에서 실행 중인 따른 프로세스의 영향을 주고받으며 동작하는 프로세스.</p><ul><li>프로세스의 상태와 데이터는 다른 프로세스와 공유된다</li><li>프로세스의 실행은 비결정적며 재생 불가능하다.</li></ul><h2 id="프로세스-관리자"><a href="#프로세스-관리자" class="headerlink" title="프로세스 관리자"></a>프로세스 관리자</h2><ul><li>프로세스를 생성 및 삭제함.</li><li>프로세스 실행(CPU 할당)을 위한 스케줄 결정.</li><li>프로세스의 상태를 관리하며 상태 전이를 처리.</li></ul><h2 id="프로세스의-상태-변화"><a href="#프로세스의-상태-변화" class="headerlink" title="프로세스의 상태 변화"></a>프로세스의 상태 변화</h2><p>시스템에서 프로세스가 처리될 때 프로세스는 생성, 준비, 실행, 대기, 종료의 다섯 가지 중 하나의 상태에 있게 된다.</p><p><img src="/images/base/operating-systems-process-1.png" alt="프로세스의 상태 변화"></p><h3 id="생성"><a href="#생성" class="headerlink" title="생성"></a>생성</h3><p>처음 작업이 시스템에 주어진 상태. 프로세스가 생성되는 중이다.</p><h3 id="생성-gt-준비"><a href="#생성-gt-준비" class="headerlink" title="생성 -&gt; 준비"></a>생성 -&gt; 준비</h3><p>미리 정의된 정책에 따라 스케줄러에 의해 호출되는데 이때 다양한 자원들이 어떻게 필요한지 파악하는 작업을 함.</p><h3 id="준비"><a href="#준비" class="headerlink" title="준비"></a>준비</h3><p>실행 준비가 되어 CPU 할당을 기다리는 상태. </p><ul><li>필요한 자원들은 다 할당받은 후 CPU 할당만 기다리고 있음.</li></ul><h3 id="준비-gt-실행"><a href="#준비-gt-실행" class="headerlink" title="준비 -&gt; 실행"></a>준비 -&gt; 실행</h3><p>사전에 정의된 알고리즘ㅁ에 따라 스케줄러에 의해 프로세스가 처리 된다. 이 과정을 <strong>디스패치</strong> 라고 한다. </p><h3 id="실행"><a href="#실행" class="headerlink" title="실행"></a>실행</h3><p>프로세스가 CPU를 할당 받아 작업을 처리하고 있는 상태이다.</p><h3 id="대기"><a href="#대기" class="headerlink" title="대기"></a>대기</h3><p>I/O 작업 같은 이벤트를 처리하기 위해 프로세스의 작업이 보류되는 상태이다.</p><h3 id="실행-gt-준비"><a href="#실행-gt-준비" class="headerlink" title="실행 -&gt; 준비"></a>실행 -&gt; 준비</h3><p>할당시간의 만료나 높은 우선순위의 프로세스가 오는 경우 스케줄러에 의해서 처리된다. </p><h3 id="실행-gt-대기"><a href="#실행-gt-대기" class="headerlink" title="실행 -&gt; 대기"></a>실행 -&gt; 대기</h3><p>I/O 처리, 페이지 교환 같은 명령어 등에 의해 일어난다. 이러한 작업은 상대적으로 오랜 시간이 걸리기 때문에 그동안 CPU를 다른 프로세스에 할당하여 활용하기 위함이다. </p><h3 id="종료"><a href="#종료" class="headerlink" title="종료"></a>종료</h3><p>프로세스의 실행이 종료되었다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920017322&amp;condLscValue=001&amp;condYr=&amp;condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 운영체제 2강</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;프로세스&quot;&gt;&lt;a href=&quot;#프로세스&quot; class=&quot;headerlink&quot; title=&quot;프로세스&quot;&gt;&lt;/a&gt;프로세스&lt;/h2&gt;&lt;p&gt;실행 중인 프로그램.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;프로그램: 동작을 하지 않는 정적, 수동적 개체 &lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="Base" scheme="http://dev.kyoungah.com/categories/Base/"/>
    
      <category term="Operating systems" scheme="http://dev.kyoungah.com/categories/Base/Operating-systems/"/>
    
    
      <category term="Operating systems" scheme="http://dev.kyoungah.com/tags/Operating-systems/"/>
    
  </entry>
  
  <entry>
    <title>운영체제의 유형</title>
    <link href="http://dev.kyoungah.com/2019/03/16/2019-03-05-operating-systems-types/"/>
    <id>http://dev.kyoungah.com/2019/03/16/2019-03-05-operating-systems-types/</id>
    <published>2019-03-16T13:10:01.000Z</published>
    <updated>2019-04-25T05:59:19.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="운영체제의-유형"><a href="#운영체제의-유형" class="headerlink" title="운영체제의 유형"></a>운영체제의 유형</h2><p>운영체제는 응답시간의 속도와 데이터 입력의 방식에 따라 일괄처리, 대화형, 실시간, 하이브리드 운영체제의 네 가지 유형으로 분류된다.</p><h3 id="일괄처리-batch-processing-운영체제"><a href="#일괄처리-batch-processing-운영체제" class="headerlink" title="일괄처리(batch processing) 운영체제"></a>일괄처리(batch processing) 운영체제</h3><ul><li>초창기 컴퓨터에서 사용되었던 유형으로 작업을 모아서 처리하는 방식.</li><li>사용자와 상호작용 없이 순차적으로 실행한다.</li><li>OMR카드, OCR카드를 입력장치로 이용.</li><li>효율성 평가는 처리량과 반환시간으로 함.<ul><li>처리량: 주어진 전체 시간 안에 처리된 작업의 수 </li><li>반환시간: 작업의 생성 시점부터 종료 시점 까지의 소요 시간</li></ul></li></ul><h3 id="대화형-interactive-운영체제"><a href="#대화형-interactive-운영체제" class="headerlink" title="대화형(interactive) 운영체제"></a>대화형(interactive) 운영체제</h3><ul><li>시분할 운영체제라고도 함.</li><li>시간 단위로 잘라서 다양한 요청들을 차례 차례 돌아가며 처리할 수 있도록 함.</li><li>이용자에게 즉각적인 피드백을 제공하고 응답시간은 사용 중인 이용자의 수에 따라 수 분 또는 수초 안에 처리됨.</li><li>일괄처리 운영체제 보다 빠르지만 실시간 운영체제보다는 느린 응답시간.<ul><li>응답시간: 요청한 시점부터 반응이 시작되는 시점까지의 소요시간.</li></ul></li></ul><h3 id="실시간-운영체제"><a href="#실시간-운영체제" class="headerlink" title="실시간 운영체제"></a>실시간 운영체제</h3><ul><li>모든 운영체제 중 응답시간이 가장 빠름.</li><li>처리의 결과가 현재의 결정에 영향을 주기 때문에 데이터의 처리가 극도로 빨라야 하는 환경에서 사용된다.<ul><li>ex) 우주선 비행 시스템, 미사일 제어, 증권거래 관리 시스템, 은행 입출금 시스템 등…</li></ul></li></ul><h3 id="하이브리드-운영체제"><a href="#하이브리드-운영체제" class="headerlink" title="하이브리드 운영체제"></a>하이브리드 운영체제</h3><ul><li>일괄처리 운영체제와 대화형 운영체제의 결합.</li><li>각 이용자가 터미널을 통해 접속하고 빠른 응답시간을 얻을 수 있기 때문에 대화형 운영체제.</li><li>대화형 작업량이 많지 않을 경우 운영체제는 실제로 백그라운드에서 배치 프로그램을 받아들이고 실행한다.</li><li>현재 사용되고 있는 대부분의 대형 컴퓨터 시스템은 하이브리드 운영체제.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;운영체제의-유형&quot;&gt;&lt;a href=&quot;#운영체제의-유형&quot; class=&quot;headerlink&quot; title=&quot;운영체제의 유형&quot;&gt;&lt;/a&gt;운영체제의 유형&lt;/h2&gt;&lt;p&gt;운영체제는 응답시간의 속도와 데이터 입력의 방식에 따라 일괄처리, 대화형, 실시간,
      
    
    </summary>
    
      <category term="Base" scheme="http://dev.kyoungah.com/categories/Base/"/>
    
      <category term="Operating systems" scheme="http://dev.kyoungah.com/categories/Base/Operating-systems/"/>
    
    
      <category term="Operating systems" scheme="http://dev.kyoungah.com/tags/Operating-systems/"/>
    
  </entry>
  
  <entry>
    <title>운영체제의 구성</title>
    <link href="http://dev.kyoungah.com/2019/03/16/2019-03-05-operating-systems-configuration/"/>
    <id>http://dev.kyoungah.com/2019/03/16/2019-03-05-operating-systems-configuration/</id>
    <published>2019-03-16T13:04:34.000Z</published>
    <updated>2019-04-25T05:59:19.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="운영체제의-구성"><a href="#운영체제의-구성" class="headerlink" title="운영체제의 구성"></a>운영체제의 구성</h2><p>운영체제를 구성하는 요소는 다양하지만 컴퓨터 시스템의 자원의 성격에 따라 구분한다. 크게 프로세스 관리자, 메모리 관리자, 장치 관리자, 파일 관리자로 나눌 수 있다.</p><h3 id="프로세스-관리자"><a href="#프로세스-관리자" class="headerlink" title="프로세스 관리자"></a>프로세스 관리자</h3><p>프로세스들을 생성하고 삭제하며 CPU에 할당하기 위한 스케줄을 결정한다. </p><ul><li>프로세스: 실행 중인 프로그램 또는 작업. </li><li>컴퓨터의 핵심적인 부분: CPU, 메모리<ul><li>CPU로 명령어 처리, 명령어는 메모리에 저장되어 있음.<ul><li>실행 중인 프로그램은 메모리 상에 프로세스로 존재.</li><li>동작을 하려면 CPU를 이용하여 명령어를 처리해야 함.</li></ul></li></ul></li></ul><ul><li>프로세스의 상태(준비, 실행, 대기 등)를 관리하며 상태 전이를 처리한다. </li></ul><h3 id="메모리-관리자"><a href="#메모리-관리자" class="headerlink" title="메모리 관리자"></a>메모리 관리자</h3><p>메모리(주기억장치) 공간에 대한 각각의 요규가 유효한지 체크하고 적법한 요구라면 메모리 관리자가 주기억장치에서 아직 사용 중이지 않은 부분을 할당한다. </p><ul><li>메모리 할당 및 회수</li><li>메모리 공간 보호</li><li>운영체제가 점유하고 있는 주기억장치의 공간을 지킴</li></ul><h3 id="장치-관리자"><a href="#장치-관리자" class="headerlink" title="장치 관리자"></a>장치 관리자</h3><p>컴퓨터 시스템의 모든 장치를 관리한다.</p><ul><li>ex) 비디오 디스플레이, 키보드, 프린터, 디스크 드라이브, 네트워크 장치 등</li><li>시스템의 장치를 할당하고 작동을 시작하며 마지막으로 장치를 반환한다.</li></ul><h3 id="파일-관리자"><a href="#파일-관리자" class="headerlink" title="파일 관리자"></a>파일 관리자</h3><p>컴퓨터 시스템의 모든 파일을 관리한다.</p><ul><li>파일의 접근 제한을 관리.</li><li>파일을 열어 자원을 할당하거나 파일을 닫아 자원을 회수하는 일 등을 수행한다. </li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920017322&amp;condLscValue=001&amp;condYr=&amp;condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 운영체제 1강</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;운영체제의-구성&quot;&gt;&lt;a href=&quot;#운영체제의-구성&quot; class=&quot;headerlink&quot; title=&quot;운영체제의 구성&quot;&gt;&lt;/a&gt;운영체제의 구성&lt;/h2&gt;&lt;p&gt;운영체제를 구성하는 요소는 다양하지만 컴퓨터 시스템의 자원의 성격에 따라 구분한다.
      
    
    </summary>
    
      <category term="Base" scheme="http://dev.kyoungah.com/categories/Base/"/>
    
      <category term="Operating systems" scheme="http://dev.kyoungah.com/categories/Base/Operating-systems/"/>
    
    
      <category term="Operating systems" scheme="http://dev.kyoungah.com/tags/Operating-systems/"/>
    
  </entry>
  
  <entry>
    <title>운영체제</title>
    <link href="http://dev.kyoungah.com/2019/03/16/2019-03-04-operating-systems-first/"/>
    <id>http://dev.kyoungah.com/2019/03/16/2019-03-04-operating-systems-first/</id>
    <published>2019-03-16T12:43:35.000Z</published>
    <updated>2019-04-25T05:59:19.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="운영체제"><a href="#운영체제" class="headerlink" title="운영체제"></a>운영체제</h2><p>컴퓨터의 하드웨어 자원을 관리하고 컴퓨터 프로그램이 동작하기 위한 서비스를 제공하는 시스템 소프트웨어.<br>ex) 윈도우, 맥 OS, 리눅스 등..</p><h2 id="운영체제의-역할"><a href="#운영체제의-역할" class="headerlink" title="운영체제의 역할"></a>운영체제의 역할</h2><h3 id="컴퓨터-시스템의-운영"><a href="#컴퓨터-시스템의-운영" class="headerlink" title="컴퓨터 시스템의 운영"></a>컴퓨터 시스템의 운영</h3><ul><li>컴퓨터 시스템의 자원을 제어 및 관리 하여 컴퓨터 시스템을 효율적으로 운영하는 역할.<ul><li>자원이란 컴퓨터 시스템을 구성하고 있는 하드웨어 혹은 소프트웨어.<ul><li>하드웨어 자원: CPU, 메모리, 키보드, 마우스, 네트워크 카드 등…</li><li>소프트웨어 자원: 각종 프로그램 데이터 등… </li></ul></li></ul></li></ul><h3 id="사용자-지원"><a href="#사용자-지원" class="headerlink" title="사용자 지원"></a>사용자 지원</h3><ul><li>사용자의 명령을 해석하여 실행.</li><li>사용자와 하드웨어 사이의 매개체 역할 수행.</li></ul><h2 id="컴퓨터-시스템과-운영체제"><a href="#컴퓨터-시스템과-운영체제" class="headerlink" title="컴퓨터 시스템과 운영체제"></a>컴퓨터 시스템과 운영체제</h2><p>운영체제가 없던 초기 컴퓨터 시스템에서는…</p><ul><li>사용자가 응용 프로그램을 수행시키면 응용 프로그램이 직접 컴퓨터 시스템의 자원을 제어해야만 했다.<ul><li>응용 프로그램에서 하드웨어를 다룰 수 있는 기능들을 모두 가지고 있었고 이때믄에 응용 프로그램 개발자는 하드웨어에 대한 방법을 잘 알아야 했다. </li></ul></li><li>하나의 하드웨어를 여러 사용자가 공유해서 사용하는 경우 응용 프로그램들 끼리 효울적인 자원 분할이 어려웠다.</li></ul><p>이런 문제점을 극복하기 위해 하드웨어와 응용 프로그램 사이에 운영체제를 두고 하드웨어에 대한 제어는 운영체제만 하도록 했다. </p><ul><li>응용 프로그램은 하드웨어에 대한 자세한 정보를 모르더라도 운영체제에 부탁만 하면 운영체제가 대신 하드웨어를 제어하고 그 결과를 응용 프로그램에 제공해 주게 되었다.</li><li>여러 응용 프로그램이 동시에 수행되더라도 운영체제가 중간에서 충돌 없이 자원을 효율적으로 나눠 줌으로써 컴퓨터 시스템이 안정적으로 동작할 수 있게 되었다. </li></ul><p>이러한 형태로 운영체제가 동작하려면 응용프로그램이 직접 하드웨어에 접근하는 것을 강제로 막을 필요가 있다. 응용 프로그램이 하드웨어를 직접 제어할 수 있는 방법이 여전히 존재한다면 시스템의 안정성을 보장할 수 없기 때문이다. </p><h3 id="슈퍼바이저-모드-커널-모드"><a href="#슈퍼바이저-모드-커널-모드" class="headerlink" title="슈퍼바이저 모드(커널 모드)"></a>슈퍼바이저 모드(커널 모드)</h3><ul><li>운영체제의 커널이 동작되는 모드.</li><li>하드웨어를 직접 제어할 수 있는 CPU 명령어 사용 가능.</li></ul><h3 id="보호-모드-사용자-모드"><a href="#보호-모드-사용자-모드" class="headerlink" title="보호 모드(사용자 모드)"></a>보호 모드(사용자 모드)</h3><ul><li>응용 프로그램이 동작되는 모드.</li><li>하드웨어를 직접 제어할 수 있는 CPU 명령어 사용 불가능</li></ul><p>보호 모드에서 동작하는 응용 프로그램이 하드웨어에 대한 제어가 필욯한 경우에는 운영체제에 부탁을 해야만 하고, 그 경우 보호 모드에서 슈퍼바이저 모드로 변경이 되고 운영체제의 커널이 동작하여 하드웨어를 제어하게 된다.<br>이 때 응용 프로그램이 운영체제에 서비스를 요청하는 메커니즘을 <strong>시스템 호출</strong>이라고 한다.</p><p>보호 모드 사용 시 하드웨어 접근이 필요한 경우…<br>==&gt; 보호 모드 사용 중 -&gt; 시스템 호출 -&gt; 보호 모드에서 슈퍼바이저 모드로 변경 -&gt; 커널 동작 -&gt; 하드웨어 제어 -&gt; 응용 프로그램에게 결과를 돌려줌 -&gt; 보호 모드로 돌아옴</p><h2 id="커널"><a href="#커널" class="headerlink" title="커널"></a>커널</h2><ul><li>운영체제의 핵심 요소.</li><li>응용 프로그램과 하드웨어 수준의 처리 사이의 가교 역할을 함.</li></ul><h3 id="일체형-커널"><a href="#일체형-커널" class="headerlink" title="일체형 커널"></a>일체형 커널</h3><ul><li>운영체제의 모든 서비스가 커널 내에 포함되어 있다.</li><li>커널 내부 요소들이 서로 효율적으로 상호작용을 할 수 있다.</li><li>모든 요소가 커널 내부에 존재하기 떄문에 하나의 요소에서라도 오류가 발생하면 시스템 전체에 장애를 일으킬 수 있다.</li><li>UNIX, Linux.</li></ul><h3 id="마이크로-커널"><a href="#마이크로-커널" class="headerlink" title="마이크로 커널"></a>마이크로 커널</h3><ul><li>운영체제의 대부분의 요소들을 커널 외부로 분리.</li><li>커널 내부에는 메모리 관리, 멀티태스킹, 프로세스 간 통신(IPC) 등의 최소한의 요소들만 남겨놓음.</li><li>새로운 서비스를 추가하여 운영체제를 확장하기 쉬움.</li><li>커널 외부의 요소에 문제가 발생하더라도 커널 자체에는 영향이 없기 때문에 유지보수가 용이하여 안정성이 우수함.</li><li>커널 외부 요소들 사이에 데이터 전달이 필요한 경우에는 프로세스 간 통신(IPC)을 통해야만 하기 떄문에 성능 저하가 발생한다.</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920017322&amp;condLscValue=001&amp;condYr=&amp;condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 운영체제 1강</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;운영체제&quot;&gt;&lt;a href=&quot;#운영체제&quot; class=&quot;headerlink&quot; title=&quot;운영체제&quot;&gt;&lt;/a&gt;운영체제&lt;/h2&gt;&lt;p&gt;컴퓨터의 하드웨어 자원을 관리하고 컴퓨터 프로그램이 동작하기 위한 서비스를 제공하는 시스템 소프트웨어.&lt;br&gt;e
      
    
    </summary>
    
      <category term="Base" scheme="http://dev.kyoungah.com/categories/Base/"/>
    
      <category term="Operating systems" scheme="http://dev.kyoungah.com/categories/Base/Operating-systems/"/>
    
    
      <category term="Operating systems" scheme="http://dev.kyoungah.com/tags/Operating-systems/"/>
    
  </entry>
  
  <entry>
    <title>분할정복 방법</title>
    <link href="http://dev.kyoungah.com/2019/03/11/2019-03-11-algorithms-divide-and-conquer/"/>
    <id>http://dev.kyoungah.com/2019/03/11/2019-03-11-algorithms-divide-and-conquer/</id>
    <published>2019-03-10T17:03:57.000Z</published>
    <updated>2019-04-25T05:59:19.488Z</updated>
    
    <content type="html"><![CDATA[<h2 id="분할정복-방법"><a href="#분할정복-방법" class="headerlink" title="분할정복 방법"></a>분할정복 방법</h2><p>순환적으로 문제를 푸는 하향식 접근 방법.</p><p>주어진 문제의 입력을 더 이상 나눌 수 없을 때까지 두 개 이상의 작은 문제들로 순환적으로 분할하고, 이렇게 분할된 작은 문제들을 각각 해결한 후 이들의 해를 결합하여 원래의 문제의 해를 구하는 방식.</p><h2 id="분할정복-방법-처리-과정"><a href="#분할정복-방법-처리-과정" class="headerlink" title="분할정복 방법 처리 과정"></a>분할정복 방법 처리 과정</h2><h3 id="분할"><a href="#분할" class="headerlink" title="분할"></a>분할</h3><p>주어진 문제를 여러 개의 작은 문제로 분할한다.</p><h3 id="정복"><a href="#정복" class="headerlink" title="정복"></a>정복</h3><p>작은 문제들을 순환적으로 분할한다. 만약 작은 문제가 더 이상 분할되지 않을 정도로 충분히 작다면 순환호출 없이 작은 문제의 해를 구한다. (정복)</p><h3 id="결합"><a href="#결합" class="headerlink" title="결합"></a>결합</h3><p>작은 문제에 대해 정복된 해를 결합하여 원래 문제의 해를 구한다. </p><h2 id="분할정복-방법의-특징"><a href="#분할정복-방법의-특징" class="headerlink" title="분할정복 방법의 특징"></a>분할정복 방법의 특징</h2><ul><li>분할된 작은 문제는 원래의 문제에 비해 입력 크기만 작아졌을 뿐 문제 자체는 원래 문제와 동일하다.</li><li>분할된 문제는 서로 독립적이기 때문에 각각의 작은 문제를 다시 순환적으로 분할하고 그 결과를 통합하는 것이 가능하다.</li></ul><h2 id="분할정복-방법을-적용한-알고리즘"><a href="#분할정복-방법을-적용한-알고리즘" class="headerlink" title="분할정복 방법을 적용한 알고리즘"></a>분할정복 방법을 적용한 알고리즘</h2><h3 id="이진-탐색"><a href="#이진-탐색" class="headerlink" title="이진 탐색"></a>이진 탐색</h3><p>  <img src="/images/base/algorithms-divide-and-conquer-1.png" alt="이진 탐색"><br>  크기가 n인 문제를 크기가 n/2인 두 개의 작은 문제로 분할한다. 그 중 하나의 작은 문제는 처리 대상에서 제외한다.</p><h3 id="합병-정렬"><a href="#합병-정렬" class="headerlink" title="합병 정렬"></a>합병 정렬</h3><p><img src="/images/base/algorithms-divide-and-conquer-2.png" alt="합병 정렬"><br>  크기가 n인 문제를 크기가 n/2인 두 개의 작은 문제로 분할한다.</p><h3 id="퀵-정렬"><a href="#퀵-정렬" class="headerlink" title="퀵 정렬"></a>퀵 정렬</h3><p><img src="/images/base/algorithms-divide-and-conquer-3.png" alt="퀵 정렬"><br>크기가 n인 문제를 쿠기는 감소하지만 일정하지 않은 크기의 두 개의 작은 문제로 분할한다.</p><h3 id="선택-문제"><a href="#선택-문제" class="headerlink" title="선택 문제"></a>선택 문제</h3><p><img src="/images/base/algorithms-divide-and-conquer-4.png" alt="선택 문제"><br>크기가 n인 문제를 크기는 감소하지만 일정하지 않은 크기의 두 개의 작은 문제로 분할한다. 그중 하나의 작은 문제는 처리 대상에서 제외한다. </p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920026935&amp;condLscValue=001&amp;condYr=&amp;condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 알고리즘 3강</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;분할정복-방법&quot;&gt;&lt;a href=&quot;#분할정복-방법&quot; class=&quot;headerlink&quot; title=&quot;분할정복 방법&quot;&gt;&lt;/a&gt;분할정복 방법&lt;/h2&gt;&lt;p&gt;순환적으로 문제를 푸는 하향식 접근 방법.&lt;/p&gt;
&lt;p&gt;주어진 문제의 입력을 더 이상 나눌
      
    
    </summary>
    
      <category term="Base" scheme="http://dev.kyoungah.com/categories/Base/"/>
    
      <category term="Algorithms" scheme="http://dev.kyoungah.com/categories/Base/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://dev.kyoungah.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>알고리즘</title>
    <link href="http://dev.kyoungah.com/2019/03/11/2019-03-02-algorithms-first/"/>
    <id>http://dev.kyoungah.com/2019/03/11/2019-03-02-algorithms-first/</id>
    <published>2019-03-10T15:23:17.000Z</published>
    <updated>2019-04-25T05:59:19.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="알고리즘의-개념"><a href="#알고리즘의-개념" class="headerlink" title="알고리즘의 개념"></a>알고리즘의 개념</h2><p>알고리즘(algorithm)은 문제 해결을 위한 레시피(조리법)라고 할 수 있다. 알고리즘은 주어진 문제를 해결하기 위한 일련의 처리 과정을 단계적으로 나열한 것이다. 알고리즘의 단게적인 절차를 따르면 주어진 문제의 해를 구할 수 있다. </p><h2 id="알고리즘의-정의"><a href="#알고리즘의-정의" class="headerlink" title="알고리즘의 정의"></a>알고리즘의 정의</h2><ul><li><strong>입출력</strong><br>0개 이상의 외부 입력과 하나 이상의 출력이 있어야 한다.</li><li><strong>명확성</strong><br>각 명령은 모호하지 않고 단순 명확해야 한다.</li><li><strong>유한성</strong><br>한정된 수의 단계를 거친 후에는 반드시 종료해야 한다.</li><li><strong>유효성</strong><br>모든 명령은 컴퓨터에서 수행 가능해야 한다. </li></ul><p>알고리즘은 “주어진 문제에 대한 결과를 생성하기 위해 모호하지 않고 간단하며 컴퓨터가 수행 가능한 유한개의 일련의 명령들을 순서적으로 구성한 것” 이다. </p><p>알고리즘이 존재하는 문제일지라도 컴퓨터를 이용해서 해결하는데 현실적으로는 처리 결과를 기다릴 수 없을 정도의 상당히 긴 처리 시간을 구하는 문제도 있다. 즉 이론적으로는 알고리즘이 존재해서 ㅎ해결이 가능하지만 효율적으로 풀 수 없는 문제도 있다. 따라서 실용적인 관점에서 보면 알고리즘이 효율적이어야 한다는 것도 충분히 고려되고 만족되어야 할 중요한 조건임에 틀림없다. </p><h2 id="알고리즘의-생성"><a href="#알고리즘의-생성" class="headerlink" title="알고리즘의 생성"></a>알고리즘의 생성</h2><p>알고리즘으르 생성하려면 일련의 과정을 거쳐야 한다. </p><ol><li><p>설계<br>주어진 문제의 입출력 조건과 처리 조건 등을 분석해서 알고리즘을 설계한다. </p><ul><li>상향식 설계</li><li>하향식 설계</li></ul></li><li><p>표현 / 기술<br>설게가 완료된 알고리즘은 적절한 방법으로 표현한다. </p><ul><li>일상 언어</li><li>순서도</li><li>의사코드</li><li>프로그래밍 언어<br>…</li></ul></li><li><p>정확성 검증<br>알고리즘은 정확하고 효율적이어야만 실제 문제 해결에 안정적으로 사용될 수 있기 때문에 설계된 알고리즘의 정확성을 검증하고, 알고리즘이 얼마나 효율적인가를 분석하는 과정을 반드시 거친다. </p><ul><li>수학적 검증</li></ul></li><li><p>효율성 분석</p><ul><li>공간 복잡도</li><li>시간 복잡도</li></ul></li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920026935&amp;condLscValue=001&amp;condYr=&amp;condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 알고리즘 1강</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;알고리즘의-개념&quot;&gt;&lt;a href=&quot;#알고리즘의-개념&quot; class=&quot;headerlink&quot; title=&quot;알고리즘의 개념&quot;&gt;&lt;/a&gt;알고리즘의 개념&lt;/h2&gt;&lt;p&gt;알고리즘(algorithm)은 문제 해결을 위한 레시피(조리법)라고 할 수 있다. 
      
    
    </summary>
    
      <category term="Base" scheme="http://dev.kyoungah.com/categories/Base/"/>
    
      <category term="Algorithms" scheme="http://dev.kyoungah.com/categories/Base/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://dev.kyoungah.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>프로세스의 생성과 종료</title>
    <link href="http://dev.kyoungah.com/2019/03/06/2019-03-06-operating-systems-process-gerating/"/>
    <id>http://dev.kyoungah.com/2019/03/06/2019-03-06-operating-systems-process-gerating/</id>
    <published>2019-03-06T13:41:58.000Z</published>
    <updated>2019-04-25T05:59:19.487Z</updated>
    
    <content type="html"><![CDATA[<h3 id="프로세스-생성"><a href="#프로세스-생성" class="headerlink" title="프로세스 생성"></a>프로세스 생성</h3><p>운영체제가 새로은 프로세스를 생성하고 실행하려면 프로세스 관리를 위한 프로세스 제어 블록을 만든 후에 프로세스에 주소 공간을 할당해야 한다. </p><ol><li>새로운 프로세스에 프로세스 식별자 할당.</li><li>프로세스의 모든 구성 요소를 포함할 수 있는 주소 공간과 프로세스 제어 블록 공간 할당.</li><li>프로세스 제어 블록 초기화.</li><li>준비 큐에 삽입.</li></ol><p>일반적으로 프로세스는 작업을 수행하기 위해 자원이 필요하다. 한 프로세스가 자식 프로세스를 생성하면 생성된 자식 프로세스는 운영체제로 부터 직접 자원을 얻거나 부모 프로세스 자원의 일부를 얻는다. 하나의 프로세스가 프로세스 생성 시스템 호출을 통해 새로운 프로세스를 생성할 수 있다. ex) fork()</p><ul><li>호출하는 프로세스: 부모 프로세스 </li><li>생성되는 프로세스: 자식 프로세스</li></ul><p>시스템 프로세스와 사용자 프로세스 모두 자식 프로세스를 생성할 수 있다. 즉 부모 프로세스가 될 수 있다. </p><p>부모 프로세스는 자식 프로세스에게 자원을 나눠주거나 공유할 수 잇도록 한다. 보통 자식 프로세스의 자원은 부모 프로세스의 자원으로 제한하는데 과도한 자식 프로세스 생성에 따른 시스템 과부하 방지를 위해서이다.</p><h3 id="프로세스-종료"><a href="#프로세스-종료" class="headerlink" title="프로세스 종료"></a>프로세스 종료</h3><p>프로세스의 마지막 명령이 실행을 마치는 경우 또는 프로세스 종료 시스템 호출을 통하는 경우(ex: exit()) 프로세스는 종료된다. 프로세스 종료 후 부모 프로세스에게 실행 결과를 되돌려 준다. </p><p>프로세스 종료 시스템 호출은 부모 프로세스에 의해서만 호출 된다. 부모 프로세스는 다음과 같은 이유 때문에 자식 프로세스의 실행을 종료시킬 수 있다. </p><ul><li>자식 프로세스가 할당된 자원의 사용을 초과할 때.</li><li>자식 프로세스에게 할당된 작업이 더 이상 필요치 않을 때.</li></ul><p>부모 프로세스가 종료되면 자식 프로세스도 모두 종료된다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920017322&amp;condLscValue=001&amp;condYr=&amp;condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 운영체제 2강</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;프로세스-생성&quot;&gt;&lt;a href=&quot;#프로세스-생성&quot; class=&quot;headerlink&quot; title=&quot;프로세스 생성&quot;&gt;&lt;/a&gt;프로세스 생성&lt;/h3&gt;&lt;p&gt;운영체제가 새로은 프로세스를 생성하고 실행하려면 프로세스 관리를 위한 프로세스 제어 블록을
      
    
    </summary>
    
      <category term="Base" scheme="http://dev.kyoungah.com/categories/Base/"/>
    
      <category term="Operating systems" scheme="http://dev.kyoungah.com/categories/Base/Operating-systems/"/>
    
    
      <category term="Operating systems" scheme="http://dev.kyoungah.com/tags/Operating-systems/"/>
    
  </entry>
  
</feed>
