<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>경아&#39;s 개발일기</title>
  
  <subtitle>프론트엔드 개발자 경아</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="http://dev.kyoungah.com/"/>
  <updated>2019-06-27T14:21:19.943Z</updated>
  <id>http://dev.kyoungah.com/</id>
  
  <author>
    <name>경아</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GDG FRONT-ENDGAME 컨퍼런스 후기</title>
    <link href="http://dev.kyoungah.com/2019/06/26/2019-06-26-front-end-endgame-review/"/>
    <id>http://dev.kyoungah.com/2019/06/26/2019-06-26-front-end-endgame-review/</id>
    <published>2019-06-26T14:33:12.000Z</published>
    <updated>2019-06-27T14:21:19.943Z</updated>
    
    <content type="html"><![CDATA[<p>시험이 저번주 일요일에 끝나서 이제야 후기를 적는다.</p><p>친구가 어디서 봤는지 이런 컨퍼런스가 있다고 같이 가자며 GDG FRONT-ENDGAME 컨퍼런스 festa 링크를 공유해줬다. 컨퍼런스를 안간지 좀 되서 부지런하게 살 겸 오랜만에 가볼까 하며 컨퍼런스 소개글을 읽고 있는데 발표자에 ‘Velopert’님이 있는걸 보고 아 이건 꼭 가야겠다고 마음을 먹었다. 하필 날짜가 방송대 기말 시험 전날 이었는데 밤 새서 공부하지 뭐, 라는 심정으로 티켓 판매 알람도 맞춰놓고 티켓 판매 당일날 1시 딱 되자마자 예매 시도 및 성공했다.</p><p>컨퍼런스는 시험 공부를 포기한 보람이 있을 만큼 좋았다. 세션들도 내용이 알차면서 재밌었고 꽤 자극이 되었다. 그리고 기말고사 결과도 공부를 안한 셈치고 생각보다 점수가 잘나왔으니 안갔으면 진짜 후회했을 것 같다.</p><h2 id="세션-후기"><a href="#세션-후기" class="headerlink" title="세션 후기"></a>세션 후기</h2><h3 id="여러분이-앵귤러를-안해봤다면-살아갈-이유가-하나-더-있는-겁니다"><a href="#여러분이-앵귤러를-안해봤다면-살아갈-이유가-하나-더-있는-겁니다" class="headerlink" title="여러분이 앵귤러를 안해봤다면 살아갈 이유가 하나 더 있는 겁니다."></a>여러분이 앵귤러를 안해봤다면 살아갈 이유가 하나 더 있는 겁니다.</h3><p>PUBG에서 일하시는 분의 세션이었는데 회사 옆건물에 PUBG가 있어서 그런지 괜히 반가웠다 ㅎ. 주로 앵귤러에 대해서 발표하셨는데 그 중에서 리액트와 앵귤러의 철학이 꽤 인상깊었다.</p><ul><li><p>React의 철학은 ‘철저한 방목형’.</p><ul><li>상태관리는 redux, mobx, 서버 통신은 fetch, axios, 그 외 Babel, webpack 등등.. React는 우리는 개발자로 바라보고 있다.</li><li>setState는 React의 모든 것의 시작.<ul><li>동기화 하는 시점을 개발자에게 맡긴다.</li></ul></li></ul></li><li><p>Angular의 철학은 ‘철저한 사육형’</p><ul><li>NgZone, Change Detection 등… 앱 상태 변화가 일어날 것 같으면 앵귤러가 알아서 동기화 해준다.</li></ul></li><li><p>React vs Angular (or Vue)</p><ul><li>상황에 맞춰 아무거나 골라 쓰면 된다.<ul><li>아니면 사다리 타기 해라.</li></ul></li></ul></li><li><p>Angular 단점.</p><ul><li>처음 시작하기엔 진입장벽이 높다.<ul><li>알아야 될 것이 많다.<ul><li>Ex) template 문법, TypeScript, RxJS</li></ul></li><li>제약사항이 많다.</li></ul></li></ul></li><li><p>Angular 장점.</p><ul><li>제약사항이 많다는 것은 잘못된 길로 빠지는것을 방지한다.<ul><li>Ex) React는 폴더구조, 로직 구분 등이 다 다른 반면 Angular는 폴더 구성, 로직 구분 등이 공식 도큐먼트에 잘 써져 있다.</li></ul></li><li>TypeScript<ul><li>여러명의 개발자가 js로 개발할 경우 변수 타입 때문에 큰 혼란이 온다. TypeScript로 타입을 미리 정해주면 이러한 혼란을 줄일 수 있다.</li></ul></li><li>RxJS<ul><li>Angular를 하려면 RxJS는 무조건 해야한다.</li><li>데이터의 흐름을 한 곳에서 조작할 수 있다.<ul><li>앞으로 웹 애플리케이션은 점점 더 복잡해질 것. 서버에서 하고 있던 일도 프론트엔드로 가지고 오는 추세.</li></ul></li><li>비동기 스트림의 lodash<ul><li>비동기 스트림으로 데이터 조작을 하고 싶을 때 Rxjs로 언제든 구현할 수 있다.</li></ul></li></ul></li><li>Dependency Injection</li></ul></li></ul><h2 id="UX빼면-시체-프론트엔드"><a href="#UX빼면-시체-프론트엔드" class="headerlink" title="UX빼면 시체, 프론트엔드."></a>UX빼면 시체, 프론트엔드.</h2><p>가끔씩 궁금한게 생겨 리서치를 할 때 종종 들어가던 블로그나 깃허브에서 많이 봤던 분이 발표하셨는데 맨날 깃허브 프로필 사진으로만 보다가 실제로 뵈니 신기했다.<br>UX에 대해 발표하셨는데 신기했고 조금 더 UX에 신경을 써야겠다는 느낌이 들었다. </p><ul><li><p>웹 기술은 사용자가 웹을 이용할 때 풍부한 정보를 빠르고 우아하게 제공하기 위해서 발전함.</p></li><li><p>성능 최적화</p><ul><li>초기 로딩 최적화<ul><li>Code minification -&gt; 웹팩, 로더 등…</li><li>Code splitting</li><li>Tree shaking</li><li>Css splite</li><li>Gzip code</li><li>Chck lighthouse</li><li>Critical path</li></ul></li><li>빠르다는 느낌 전달</li><li>부드러운 애니메이션<ul><li>Intersection Observer</li><li>requestAnimation</li></ul></li></ul></li><li><p>예상 가능한 동작</p><ul><li>스크롤 복원 (봤던 거 보여주기)<ul><li>with session storage<ul><li>페이지 이동 시 현재 scroll 위치를 session storage에 저장한 후 다시 이전 페이지로 되돌아 왔을 때 storage에 값을 꺼내서 그 위치로 스크롤을 이동시켜주면 된다.</li></ul></li><li>Restore state</li></ul></li><li>딤드 영역 닫힘</li><li>손에 쉽게 들어오는 인터렉션 영역</li><li>예상 가능한 인터렉션</li></ul></li><li><p>SEO/SMO</p><ul><li>검색 엔진 최적화</li><li>소셜 미디어 공유 최적화</li><li>어디까지 공유가 가능해야 하는가?<ul><li>url 쿼리 params에 태그 같은 상태를 저장할 수 있다.</li></ul></li></ul></li><li><p>측정과 개선</p><ul><li>트래킹</li><li>상황 A/B 테스트<ul><li>with Cookie</li><li>Random</li></ul></li><li>이탈률은 어떻게 줄일 수 있을까?<ul><li>Google Analytics</li></ul></li></ul></li><li><p>1px도 무시 하지말자. UX 디자이너와의 충분한 협업이 필요하다.</p></li><li><p>성능 최적화 같은건 프레임워크가 알아서 해주니까 UX에 신경을 좀 더 쓰는게 좋을 거 같다고 요즘 생각이 들기도 한다.</p></li></ul><h2 id="프론트엔드-개발에-FRP-Functional-Reactive-Programming-녹여보기"><a href="#프론트엔드-개발에-FRP-Functional-Reactive-Programming-녹여보기" class="headerlink" title="프론트엔드 개발에 FRP(Functional Reactive Programming) 녹여보기"></a>프론트엔드 개발에 FRP(Functional Reactive Programming) 녹여보기</h2><p>무려 중학생분이 발표하셨다. 생소한 용어가 많고 조금 이해가 안가서 필수 키워드만 기록해두고 집에와서 리서치 하는 식으로 메모를 정리했다. 나는 중학생때 메이플 하느라 바빴는데 이 분은 이렇게 어려운 내용으로 발표까지 하시니 자괴감도 조금 들었다 ㅎ… </p><ul><li><p>Imperative</p><ul><li>명령형 프로그래밍.</li><li>프로그램이 어떻게 동작하는지 정의한다.</li></ul></li><li><p>Declarative</p><ul><li>선언형 프로그래밍.</li><li>이게 무엇인지 선언한다.</li></ul></li><li><p>함수형 프로그래밍</p><ul><li>변화가 없다.</li><li>사이드 이팩트가 없다.<ul><li>Ex) 사이드 이팩트: 함수를 실행했더니 외부 변수, 상태값이 변경되는 것.</li></ul></li><li>이 둘이 없으므로 코드 읽기가 편하다. 모든 수학적 지식을 코드에 갖다 쓸 수 있다.</li></ul></li><li><p>Reactive Programming</p><ul><li>비동기적 데이터 흐름을 처리하는 프로그래밍.<ul><li>낮은 결합도 이득을 얻을 수 있다.</li></ul></li></ul></li><li><p>FRP = FP + RP</p><ul><li>엄청난 코드 재사용성.</li><li>코드들간의 결합도가 낮아져서 사이드 이팩트 일어날 확률 없음.</li></ul></li><li><p>순수 함수</p><ul><li>사이드 이팩트가 없다.</li><li>Referential transparency (참조 투명성)을 띈다.</li></ul></li></ul><h2 id="문과생의-커리어-프런트엔드로-refactoring하기"><a href="#문과생의-커리어-프런트엔드로-refactoring하기" class="headerlink" title="문과생의 커리어 프런트엔드로 refactoring하기"></a>문과생의 커리어 프런트엔드로 refactoring하기</h2><p>아는 동생이 비전공으로 웹디자이너를 하고 있는데 코딩에도 관심을 보여서 들었다가 얘기해주면 좋을 것 같다 싶어 메모하려고 노트북을 켰는데 어려운 얘기가 아니니 편하게 들어달라는 발표자분의 얘기에 노트북을 덮어서 딱히 메모해놓은 것은 없다. </p><p>어떻게 개발자가 되어 어떤 회사에서 어떤 사수를 거치고 현재까지 오게 되었는지에 대한 발표자분의 개발 인생 이야기였는데 발표자분이 발표를 너무 재밌게 해주셔서 발표 시간 내내 웃으면서 들었다. 나도 이렇게 재미난 말솜씨를 가진 사람이 되고 싶다. </p><h2 id="프론트엔드-개발-끝장내기-endgame-feat-Angular"><a href="#프론트엔드-개발-끝장내기-endgame-feat-Angular" class="headerlink" title="프론트엔드 개발 끝장내기(endgame) feat. Angular"></a>프론트엔드 개발 끝장내기(endgame) feat. Angular</h2><p>발표자 분이 React로 프론트 개발을 하시면서 Angular를 사랑하시는 특이한(?) 분이셨다. Angular의 기술적인 내용을 발표해주셨는데 본인이 좋아하는 프레임워크가 어떻게 돌아가는지 잘 알고 있는게 멋있었고 그냥 대충 갖다쓰기만 하던 내모습이 부끄럽기도 했다. 예전에 Angular에 발만 담궜다가 뺀 적이 있었는데 그 떄 당시 모듈 컴포넌트니 모듈 서비스니 등등 구조가 너무 복잡해서 어렵다는 생각에 다시 쉽사리 손을 못대고 있었다. 기회가 되면 Angular도 다시 공부해보고 싶은데 당장 쓸 일이 없어서 먼 나중의 일이 될것 같다 ㅎ…</p><ul><li><p>Angular 바인딩은 어떻게 동작하나?</p><ul><li>Change Detection: 데이터의 변경을 감지하고 이를 뷰에 반영하는 메커니즘.<ul><li>Angular는 이를 통해 데이터 변경을 감지하고 적절한 시점에 자동으로 뷰의 상태를 반영한다.</li><li>Change Detection이 트리거되면 Angular는 위에서부터 아래로 모든 컴포넌트 트리를 순회한다.</li><li>Output 바인딩 작업은 CD와 별개로 수행되어 CD동안 자식 컴포넌트가 부모 컴포넌트의 데이터를 변경하는 일이 없도록 강제한다.<ul><li>개발 모드에서는 자식 컴포넌트가 부모 컴포넌트 값을 바꾸는지 확인하기 위해 두번 돈다</li></ul></li><li>언제 Change Detection을 수행하는가?<ul><li>zone.js: JS VM이 둘러쌓인 여려 환경에서 비동기 코드를 포함한 여러 테스크를 추적할 수 있는 실행 컨텍스트</li><li>앵귤러는 이 zone.js로 전체 애플리케이션을 감싸서 비동기 코드를 추적한다.<ul><li>zone.js가 없어도 Angular는 작동하나 개발자가 수동으로 Change Detection을 트리거 해줘야 할것이다.</li><li>모든 Web API를 몽키패치 하여 ZONE을 제공한다. 이것으로 각종 비동기 이벤트가 언제 끝나는 지 추적할 수 있다.</li></ul></li></ul></li><li>React와 Vue 에도 Change Detection이 있다.<ul><li>리액트와 Vue는 개발자가 직접 알린다.<ul><li>리액트는 setState를 통해서 변경을 알린다.</li><li>Vue는 setter가 wrapping된 데이터를 변경해서 알린다. -&gt; proxy API.</li></ul></li><li>앵귤러는 프레임워크가 자동으로 알아챈다.<ul><li>적절힌 사점에 데이터의 이전값과 다음 값을 비교하여 업데이트 한다.</li></ul></li></ul></li></ul></li></ul></li><li><p>Rx.js</p><ul><li>Observable을 이용하여 비동기, 이벤트 기반의 프로그램을 작성하는 라이브러리.</li><li>RxJs의 연산자는 순수함수.</li><li>여러 연산자를 합성하여 Observable의 흐름을 제어함.</li><li>Angular는 내부 로직 전반에 RxJs를 활용한다.</li></ul></li></ul><h2 id="프로그래머로서의-성장을-도왔던-태도들"><a href="#프로그래머로서의-성장을-도왔던-태도들" class="headerlink" title="프로그래머로서의 성장을 도왔던 태도들"></a>프로그래머로서의 성장을 도왔던 태도들</h2><p>기술적인 이야기는 아니었지만 꽤 유익한 발표였다. 내가 평소에 생각하고 있던 것과 비슷해서 좀 자화자찬 하기도 했고 내가 잘못 행동하고 있구나 싶은 내용도 있어 반성도 했다. </p><ul><li><p>프로그래머는, 그리고 오직 프로그래머만이 특별하지는 않다.</p></li><li><p>혼자서 프로그래밍 만으로 만들 수 있는 임팩트의 크기는 생각보다 크지 않다.</p></li><li><p>다른 직군들에게 일반적으로 필요한 자질 대부분이 프로그래머에게도 똑같이 요구된다.</p><ul><li>팀워크.</li><li>친절한 배려.</li><li>글과 말을 이용해 생각을 정돈, 표현, 설득하는 능력</li></ul></li><li><p>새로운 기술을 익힐 때, 이론을 파는것도, 이론을 아예 보지 않는것도 최선은 아니다.</p><ul><li>이론적인 배경 공부와 그렇게 쌓은 지식을 활용하는 실습, 두 상태를 빠르게 오가기.</li><li>배운 이론을 이용해 무언가를 구현했을 때, 결과물이 동작하는 상태여야 한다.<ul><li>짧은 주기의 반복을 통한 빠른 피드백을 얻기 위해…</li><li>돌아올 수 있는 체크포인트를 만들기 위해…</li><li>동작한다?<ul><li>MVP: 가치를 전달할 수 있는 가장 단순한 형태의 제품<ul><li>MVP를 잘 설정하려면…<ul><li>MVC를 예로 들어<ol><li>하드코딩 된 데이터를 읽기만 가능한 단계</li><li>데이터의 추가, 삭제, 수정을 구현하는 단계</li><li>인증 로직을 추가하는 단계</li></ol></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>만들면서 배우자.</p><ul><li>어떤 프로그램을 짤지 생각하면서 문서를 읽고, 그 프로그램을 작성할 수 있겠다는 생각이 들 때 바로 코드를 짜기 시작하라.</li><li>어떤 프로그램을 만들어야 될지 생각이 들지 않으면 이거를 진짜 배워야 될지 다시 생각해보자.</li></ul></li><li><p>사람들은 의도적으로, 때로는 의도치 않게 틀린 말을 많이 한다.</p></li><li><p>배움의 과정에서 사람들의 틀린 말에 덜 휘둘리기 위해선 어떻게 해야 할까?</p><ul><li>급할수록 돌아가기.<ul><li>쉽게 풀어서 설명해주는 블로그 글, 유튜브 영상 등…<ul><li>저자의 재해석과 무엇을 말하고 무엇을 말하지 않을지에 대한 결정이 들어간다.<ul><li>재해석의 단계가 깊어질수록 가장 사실에 가까운 정보로부터 멀어진다.</li></ul></li><li>무언가 배울 때 가장 근원이 되는 정보를 직접 찾아보는 습관.<ul><li>소스코드, 언어, 라이브러리 공식 문서, 어떤 개념을 처음으로 주장한 이의 논문, 글 등…</li></ul></li><li>사람을 믿어야 할 상황 없애기.<ul><li>자동화할 수 있는 검증의 책무는 사람이 아닌 기계에게 맡긴다.<ul><li>자동화된 회귀 테스트가 검증하게 하기</li></ul></li><li>문서에 적힌 이 함수를 이런 파라미터가 받습니다 라는 정보를 믿는 대신 정말 그런지 타입 체커가 자동으로 검사할 수 있게…</li></ul></li></ul></li></ul></li></ul></li><li><p>더 견고한 프로그램을 위해서 스스로 검증하지 않은 정보를 함부로 믿지 말고 다른 프로그래머와 사용자를 올바르게 의심하며 최선을 바라되 최악을 대비하자.</p></li><li><p>관심사를 공유하는 열정적인 동료가 되는 것이 중요하다.</p><ul><li>내가 원하는 동료를 생각해보자.</li><li>남들에게 바로 그런 동료가 되기 위해서 내가 할 수 있는 일을 생각해보자.<ul><li>블로깅.</li><li>오픈소스 PR 작성 등.</li></ul></li></ul></li><li><p>새로 나오는 정보를 절대로 놓치지 않겠다고 개발에 관련된 모든 페이스북 그룹에 가입하고 뉴스레터를 받아보는 것은 불가능할 뿐만 아니라 비효율적인 전략이다.</p></li></ul><h2 id="마지막-세션"><a href="#마지막-세션" class="headerlink" title="마지막 세션"></a>마지막 세션</h2><p>기다리고 기다리던 Velopert님의 발표였다. 실무에 도움이 되는 알찬 내용들로 이루어진 발표였고 나 역시 React로 프론트 개발을 하고 있어서 그런지 공감가는 부분도 많았고 막히는 부분없이 재미있게 들을 수 있었다.</p><ul><li><p>컴포넌트 스타일링.</p><ul><li>자주 쓰이는 방법은 컴포넌트 폴더에 js와 관련 css 파일을 같이 생성 하는 것.</li><li>기존 프로젝트에 React를 도입할 땐 css.module 괜찮음.</li><li>styled-Component.<ul><li>충분히 안정적이고 편함.</li><li>기존에 하고 있던 프로젝트가 있으면 기존 컴포넌트 까지 styled-component로 리팩토링 하는 것은 비추천.</li></ul></li><li>Boostrap, 시멘틱 ui 같은 ui 프레임워크들은 필수 요소가 아님.<ul><li>내부 직원들이 쓰는 페이지나 인력이 적고 빨리 서비스를 구축해야할 때를 제외하고는 비추천.</li><li>매번 UI 프레임워크 문서를 보면서 작업해야함.</li><li>스타일 커스터마이징 까다로움.</li><li>사용되지 않는 기능들이 수두룩함.</li><li>직접 개발한 ui와 ui 프레임워크 디자인과 어울리지 않으면 상당히 못생김.</li><li>걷어내야 할 때 힘듬.</li><li>직접 작성하는 것 어렵지 않음.</li><li>꼭 사용해야 한다면 Tree Shaking 지원 여부 확인하자.</li></ul></li></ul></li><li><p>함수형 컴포넌트로 작성하자.</p><ul><li>16.8 이전에는 class 컴포넌트를 사용함.<ul><li>setState, lifeCycle Api 등…</li></ul></li><li>16.8 이후에는 hooks 등장으로 state 관리, lifecycle api 비슷한 기능들을 사용할 수 있다.<ul><li>반복되는 로직들은 Custom Hooks로 만들어서 쓸 수 있음 -&gt; HOC 사용 필요 없음.</li></ul></li><li>이제 클래스형 컴포넌트를 쓸 일이 없다.</li></ul></li><li><p>Context API랑 Hooks가 있는데 Redux/MobX를 써야하나?</p><ul><li>단순한 글로벌 상태관리를 원하거나 프로젝트의 규모가 작다면 Redux, Mobx를 사용할 필요가 없다.<ul><li>대신 미들웨어, 리덕스 개발자 도구, 유틸 함수들을 포기해야 한다.</li><li>그렇다고 이미 리덕스를 도입한 프로젝트에서 리덕스를 걷어낼 필요는 없다.</li></ul></li><li>MobX는 생각보다 재미있는 프로젝트니 한번 써보자.<ul><li>불변성 신경 안씀.</li><li>이것 저것 변하는게 많으니 쓸려면 1 ~ 2달 뒤에 써보자.</li></ul></li></ul></li><li><p>어떤 상태를 리덕스로 관리해야 할까?</p><ul><li>상태를 다른 컴포넌트와 공유 할 때.</li><li>다른 컴포넌트에서 해당 값 바꿀 때.</li><li>컴포넌트 엄청 깊숙한 곳에서 상태 필요.</li><li>서버사이드 렌더링시 데이터 재사용 필요.</li></ul></li><li><p>컨테이너 안에 꼭 여러개의 컴포넌트를 사용할 필요가 없다.</p><ul><li>Presentational / Contianer.<ul><li>Container.<ul><li>상태 관리 컴포넌트.</li></ul></li><li>Presentational 컴포넌트.<ul><li>UI만 출력해주는 컴포넌트.</li></ul></li><li>이 패턴을 꼭 따를 필요가 없다.<ul><li>여러 컴포넌트들을 하나로 묶으면 코드가 길어져서 유지보수가 길어진다.</li></ul></li></ul></li></ul></li><li><p>reudcer 작정시 switch 말고 handler로 이루어진 key-value 객체를 사용하자.</p><ul><li>호불호 갈릴 수 있음.</li><li>직접 만들어서 쓰거나, redux-actions, redux-act, typesafe-actions 라이브러리 사용.</li><li>기존에 불편하다고 느끼는게 있으면 해결방안이 있는지 찾아보고 더 편해질수 있는 방법을 항상 고민하자.</li></ul></li><li><p>상태는 너무 깊숙하지 않게.</p><ul><li>상태가 한눈에 들어오지 않음.</li><li>상태가 깊어진다면 Immer.js를 사용하자.</li></ul></li><li><p>imuttable.js?</p><ul><li>Typescript 지원 구림.</li><li>걷어내는데 힘듬.</li></ul></li><li><p>Ducks 패턴.</p><ul><li>하나의 파일에 관련 action, reducer 등 관리 하는 것.<ul><li>편함.</li><li>action이 많아질 것 같으면 분리하자.</li></ul></li></ul></li></ul><p>-배열 업데이트 시 Keys-by-id 패턴 사용 추천.</p><ul><li>Loadsh, rambda 라이브러리.</li></ul><ul><li><p>데이터 요청 상태 어떻게 관리할까?</p></li><li><p>서버사이드렌더링이 아니라면 redux, mobx가 아닌 hooks로 관리하자.</p></li><li><p>서버사이드 렌더링은 꼭 필요하다.</p></li><li><p>Next.js 사용하면 시간을 많이 아낄 수 있으나 제약이 있다.</p></li><li><p>React-Router 컴포넌트를 사용해도 되나 SSR을 직접 해야 한다.</p><ul><li>직접 구현하면 Hell Gate 생성.<ul><li>올바른 가이드가 있으면 해볼만도 함.</li></ul></li></ul></li><li><p>타입스크립트 도입과 테스트 도입은 일찍하자.</p><ul><li>지금 도입하기엔 프로젝트가 너무 크면 점진적으로 적용해보자<ul><li>새로 만드는 컴포넌트부터 적용, 나머지 기능을 어쩌다 리팩토링 하게 될 때 적용</li></ul></li></ul></li></ul><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>나보다 날고 기는 분들이 많다는 사실을 또 한번 느꼈다. 열심히 공부하고 일해야겠다. </p><p>마지막 QNA 시간에 Velopert님이 답변해주신 질문 사실 내가 쓴거다 ㅎ… 그냥 씹히겠지 싶어서 진담 반, 농담 반을 담아 익명으로 적었는데 Velopert님 이 답변해주셔서 기뻤다. 다른 분들도 답변해 주셨는데 엄청 도움이 되었다. 뭔가 계속 마음속에 프론트엔드 개발로는 오랫동안 개발자를 못해먹을거 같아서 보험으로 백앤드를 배워놓거나 대학원을 가서 딥러닝을 전공해야하나 라는 고민이 작년부터 계속 들었는데 덕분에 이 쓸데없는 고민을 좀 덜어낼 수 있었다. 질문에는 보험이라고 적었지만 다행히 백앤드는 예전부터 계속 관심 있어서 틈틈히 공부 및 토이 프로젝트를 진행할 예정이고 딥러닝쪽은 당분간은 쿨하게 포기하기로 했다. 내가 배우고 싶어서 배우는 것도 아니고 솔직히 아직까지는 크게 관심이 가지는 않는다. 다음 학기에 인공지능 수업이 있는데 그때 들어보고 재밌다 싶으면 관심을 갖기로 하고 당분간은 머릿속에서 지우자.</p><p>그리고 겁이 좀 나긴 하지만 언젠가 나도 멀지 않은 미래에 사람들 앞에 서서 내가 배우고 느꼈던 것을 발표해보고 싶다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;시험이 저번주 일요일에 끝나서 이제야 후기를 적는다.&lt;/p&gt;
&lt;p&gt;친구가 어디서 봤는지 이런 컨퍼런스가 있다고 같이 가자며 GDG FRONT-ENDGAME 컨퍼런스 festa 링크를 공유해줬다. 컨퍼런스를 안간지 좀 되서 부지런하게 살 겸 오랜만
      
    
    </summary>
    
      <category term="Front-end" scheme="http://dev.kyoungah.com/categories/Front-end/"/>
    
      <category term="Etc" scheme="http://dev.kyoungah.com/categories/Front-end/Etc/"/>
    
    
      <category term="etc" scheme="http://dev.kyoungah.com/tags/etc/"/>
    
  </entry>
  
  <entry>
    <title>사이버 공격</title>
    <link href="http://dev.kyoungah.com/2019/06/07/2019-06-07-computer-security-cyber-attack/"/>
    <id>http://dev.kyoungah.com/2019/06/07/2019-06-07-computer-security-cyber-attack/</id>
    <published>2019-06-07T14:24:01.000Z</published>
    <updated>2019-06-07T15:41:11.783Z</updated>
    
    <content type="html"><![CDATA[<h2 id="사이버-공격"><a href="#사이버-공격" class="headerlink" title="사이버 공격"></a>사이버 공격</h2><p>인터넷을 통해 다른 컴퓨터에 접속하여 상대방 국가나 기업, 개인에 손상을 입히려는 행동.</p><p>가장 기본적인 사이버 공격 방식은 네트워크상이나 로컬 호스트상에서 시스템의 설정이 잘못된 것을 이용해 관리자의 권한을 얻는 것이다.</p><h3 id="악성코드"><a href="#악성코드" class="headerlink" title="악성코드"></a>악성코드</h3><p>악의적인 용도로 사용될 수 있는 코드가 심어진 유해 프로그램을 뜻한다. 바이러스, 웜, 트로이 목마, 백도어, 스파이웨어, 랜섬웨어 등이 모두 악성코드 범주에 포함된다. </p><p>악성코드는 대부분 무분별한 인터넷 사용으로 인해 감염되는 경우가 많다. 예방을 위해서는 의심스러운 웹사이트 방문을 피하고 의문의 송신자에게 온 수상한 이메일을 확인하지 말고 메신저로 오는 인터넷 주소나 첨부 파일을 함부로 건드리지 않는 것이 좋다. 또한 보안등급을 설정하고 불법복제를 하지 않으며 보안 프로그램을 설치해 항상 최신 버전을 유지하고 실시간 감시 기능을 켜 두는 것이 바람직하다. </p><h4 id="바이러스"><a href="#바이러스" class="headerlink" title="바이러스"></a>바이러스</h4><p>다양한 경로를 거쳐 컴퓨터 시스템에 침투하여 시스템이나 사용자의 파일에 자신을 복제하고 그 컴퓨터 시스템 내에서 증식하거나 시스템을 파괴하는 악성코드. </p><h5 id="바이러스의-특성"><a href="#바이러스의-특성" class="headerlink" title="바이러스의 특성"></a>바이러스의 특성</h5><ul><li>자기 복제: 다른 시스템이나 소프트웨어를 감염시키기 위해 자신을 복제할 수 있는 코드를 갖고 있다.</li><li>저수준 언어 사용: 어셈블리어나 기계어를 사용하면 시스템을 보다 쉽게 조작할 수 있기 때문에 바이러스 프로그램은 대게 어셈블리 언어로 작성되어 있다.</li><li>다양한 변종: 일반적으로 새로운 바이러스가 나오면 그것을 모방한 잡종 변형 바이러스가 다양하게 나온다.</li><li>지능화 및 악성화: 피해를 거의 주지 않던 양성 바이러스에서 심각한 피해를 끼치는 악성 바이러스로 점차 발전하고 있다.</li></ul><h5 id="동작원리"><a href="#동작원리" class="headerlink" title="동작원리"></a>동작원리</h5><ol><li>바이러스에 감염된 프로그램을 사용자가 실행한다. <ul><li>감염된 프로그램이 실행되면 바이러스 활동이 시작된다.</li></ul></li><li>실행된 바이러스는 자신을 감염시킬 대상 파일을 찾는다.</li><li>찾은 대상 파일을 검사하여 이미 감염된 파일인지 확인한다.</li><li>감염된 파일이 아니면 감염시킬 파일의 앞 혹은 뒷부분에 자신의 코드를 삽입하여 감염시킨다.</li><li>감염과정을 감추기 위하여 바이러스로서의 코드 실행이 끝나면 원래 프로그램이 수행해야 할 작업을 수행한다.</li><li>메모리에 있는 컴퓨터 바이러스는 다른 파일에 대한 감염을 계속 수행한다.</li></ol><h4 id="웜"><a href="#웜" class="headerlink" title="웜"></a>웜</h4><p>컴퓨터의 취약점을 찾아 네트워크를 통해 스스로 감염되는 악성코드. 네트워크를 경유하여 자기 복제 능력을 통한 빠른 전파력을 가지고 있어 감염된 시스템을 거점으로 피해 시스템이 기하급수적으로 증가한다. </p><h4 id="트로이-목마"><a href="#트로이-목마" class="headerlink" title="트로이 목마"></a>트로이 목마</h4><p>정상적인 기능을 하는 프로그램으로 가장하여 프로그램 내에 숨어서 의도하지 않은 기능을 수행하는 악성코드. 유용한 프로그램인 것 처럼 위장하여 사용자들이 거부감 없이 설치하도록 유도하지만 그 안에는 치명적인 피해를 입힐 수 있는 무언가를 숨겨놓은 것이다.<br>사용자가 의심하지 않고 프로그램을 실행하면 실제 사용자가 기대했던 기능이 수행되지만 실제 목적은 사용자의 합법적인 권한을 사용하여 시스템의 방어체계를 침입하고 공격자는 접근이 허락되지 않은 정보를 획득하는 것이다.</p><p>트로이 목마가 임의의 컴퓨터에 설치되면 악의적인 목적(개인정보 유출, 감염대상 원격조정 등)을 가진 사용자에 의해 컴퓨터를 제어당하거나 정보가 유출될 수 있다. </p><h4 id="백도어"><a href="#백도어" class="headerlink" title="백도어"></a>백도어</h4><p>시스템 설계자나 관리자에 의해 고의로 남겨진 시스템의 보안구멍으로 응용 프로그램이나 운영체제에 삽입된 프로그램 코드. 시스템 접근에 대한 사용자 인증 등 정상적인 절차를 거치지 않고 응용 프로그램 또는 시스템에 접근할 수 있도록 한다. </p><p>원래 백도어는 디버깅 시 개발자에게 인증 및 셋업 시간 등을 단축하기 위한 목적으로 사용되나 비양심적인 프로그래머에 의해 악용되거나 개발이 완료된 후 삭제되지 않은 백도어가 다른 사용자에게 발견될 경우 대단히 위험할 수 있다. </p><h4 id="스파이웨어"><a href="#스파이웨어" class="headerlink" title="스파이웨어"></a>스파이웨어</h4><p>다른 사람의 컴퓨터에 설치되어 개인정보를 빼가는 악성코드. 사용자가 특정 웹페이지에 접속하거나 웹페이지와 관련된 소프트웨어를 임의로 혹은 사용자 동의로 설치할 때 함꼐 설치되는 경우가 많다. PC 취약점을 이용하여 사용자 몰래 설치되기도 한다. 이렇게 설치된 스파이웨어는 사용자의 컴퓨터에서 정보를 수집하고 인터넷을 통해 외부로 유출시킨다.</p><p>초기에는 정보 수집을 위해 제작되었지만 점차 정보 유출 등의 악의적인 목적으로 사용되고 있다. 최근에는 악성코드에 감염되었다는 허위 메시지를 보여주고 치료를 유도하는 허위 안티 스파이웨어도 크게 증가하였다. </p><h4 id="랜섬웨어"><a href="#랜섬웨어" class="headerlink" title="랜섬웨어"></a>랜섬웨어</h4><p>사용자의 중요한 정보를 인질로 삼아 금전을 요구하는 악성코드. 안전한 암호 알고리즘을 악용하여 사용자의 컴퓨터에 저장되어 있는 문서, 이미지 같은 파일들을 암호화 하여 사용자가 사용할 수 없도록 만든 후 암호를 풀기 위해서는 비트코인 등으로 송금을 하도록 유도한다. </p><p>랜섬웨어에서 사용하는 암호 알고리즘들은 키를 모르고서는 쉽게 풀 수 없는 방법들이므로 랜섬웨어에 감염되기 전에 평소 중요한 정보들은 별도로 백업해두는 것이 좋다. </p><p>이러한 랜섬웨어는 2010년대 중반부터 새롭게 유행하고 있다.</p><h3 id="네트워크-공격"><a href="#네트워크-공격" class="headerlink" title="네트워크 공격"></a>네트워크 공격</h3><h4 id="스캐닝"><a href="#스캐닝" class="headerlink" title="스캐닝"></a>스캐닝</h4><p>사이버 공격으로서의 스캐닝은 실제적인 공격을 위한 사전 정보수집 활동으로 볼 수 있다. 공격 대상 호스트들이나 네트워크에 대한 취약점을 발견해 내기 위한 도구로 사용되고 있으며 대표적으로 Nmap, Acunetix, mscan, sscan 등이 있다. </p><p>시스템 관리자는 공격자가 취약점을 점검하기 이전에 미리 자신의 시스템 및 네트워크의 보안 취약점을 점검하여 발견된 취약점에 대한 조치를 취해야 한다. </p><h4 id="스푸핑"><a href="#스푸핑" class="headerlink" title="스푸핑"></a>스푸핑</h4><p>공격자의 제어 아래 있는 호스트를 피해 호스트가 신뢰하는 호스트를 가장함으로써 피해 호스트로부터 생성되는 정보를 수집하거나 가로채는 방식의 공격.</p><ul><li>IP 스푸핑: 상대방에게 공격자 호스트가 보내는 패킷상의 IP주소를 위조하여 타 호스트로 가장하는 것.</li><li>DNS 스푸핑: DNS 엔트리상의 정보를 위조하거나 DNS 질의를 가로채 도메인 이름에 대한 잘못된 IP 주소를 전달하여 타 호스트로 가장하는 것.</li><li>Wep 스푸핑: 공격자가 자신의 웹사이트를 신뢰하는 타 사이트로 가장하여 사용자가 공격자의 웹페이지를 열람하는 동안 사용자에게 거짓 정보를 전달하거나 사용자의 개인정보를 수집하는 행위.</li><li>ARP 스푸핑: IP 주소에 대한 잘못된 MAC 주소를 전달하여 타 호스트로 가장하는 것.</li></ul><h4 id="스니핑"><a href="#스니핑" class="headerlink" title="스니핑"></a>스니핑</h4><p>네트워크 상의 데이터를 도청하는 행위.</p><ul><li>Passive 스니핑: 무차별 모드를 이용하여 패킷 내의 정보를 조작 없이 단순히 도청하는 수동적인 공격.<ul><li>무차별 모드: 패킷의 MAC 주소와 PI 주소와 관계없이 모든 패킷을 스니퍼에 넘겨주는 모드.</li></ul></li><li>Active 스니핑: ARP 스푸핑을 이용하여 공격 대상자들의 패킷 방향을 조작하여 내용을 훔쳐보거나 변조하는 방식.</li></ul><h4 id="서비스-거부-공격"><a href="#서비스-거부-공격" class="headerlink" title="서비스 거부 공격"></a>서비스 거부 공격</h4><p>특정 서비스나 자원의 가용성을 떨어뜨리는 결과를 초래하는 유형의 공격에 대한 통칭. 공격의 결과 형태에 따라 자원이나 서비스를 완전히 파괴하여 더 이상의 서비스가 불가능하도록 하는 파괴적 서비스 공격과 자원의 과다 점유, 대량 데이터의 송신, 취약성을 이용한 자원고갈 등을 통해 자원과 서비스의 원활한 사용을 방해하거나 일시적으로 서비스를 중단시키는 효과를 낳는 과부하 서비스 거부 공격으로 나눌 수 있다. </p><p>대표적인 방법으로 반열림 TCP 연결을 생성함으로써 시스템을 서비스 거부 상태로 만드는 SYN 플로딩 공격이 있다. </p><h4 id="분산-서비스-거부-공격"><a href="#분산-서비스-거부-공격" class="headerlink" title="분산 서비스 거부 공격"></a>분산 서비스 거부 공격</h4><p>분산된 여러 호스트를 일차적으로 공격하거나 여타의 방법을 이용하여 이들 다수의 호스트에 공격 데몬을 설치하고, 공격자는 원격에서 이들 데몬에 특정 공격 목표에 대한 서비스 거부 공격 명령을 내림으로써 다수의 공격 데문이 동시에 목표에 대한 서비스 거부 공격을 수행하는 방법을 이용한 것.</p><h3 id="스팸메일"><a href="#스팸메일" class="headerlink" title="스팸메일"></a>스팸메일</h3><p>불특정 다수를 대상으로 일방적∙대량으로 전달되는 전자우편. 일반적으로 광고, 홍보, 비방 등의 목적으로 전송되는 메일을 말한다. 적은 비용으로 다수의 대상에게 상품을 광고하거나 특정 종교 포교, 특정인이나 특정 상품 등을 비방할 목적으로 인터넷을 통해서 유포된다.</p><p>스펨메일 탐지에는 DNS를 이용한 방법, 통계기법을 이용한 방법 등이 사용된다. </p><ul><li>DNS를 이용한 방법: 송신자의 이메일 주소 도메인의 진위를 확인하기 때문에 스팸 차단 정확도가 뛰어나지만 DNS 변경과 이메일 송수신 절차 변경이 필요하다. </li><li>통계 기법: 이메일 메시지에 포함된 단어 중에서 스펨메일에 자주 포함되는 단어와 일반 메일에 자주 포함되는 단어를 분류하고 통계기법을 사용하여 가중치를 부여하는 방식. </li></ul><h3 id="피싱"><a href="#피싱" class="headerlink" title="피싱"></a>피싱</h3><p>유명한 금융기관이나 공신력있는 업체의 이름을 사칭한 메일을 보내 수신자들을 믿도록 하고, 수신자들로부터 개인정보나 금융정보를 얻어 내 범죄수단으로 악용하는 행위.</p><p>피싱에 대처하는 기법으로는 대부분의 피싱이 이메일로 전달되는 점에 착안하여 이메일 내부에 존재하는 하이퍼링크를 불허하는 방법이 기본적이었다. 그러나 사용자 PC의 도메인 정보를 조작하는 파밍 공격이나 VoIP를 이용항 비싱 공격, SNS를 이용하는 스미싱 공격과 같이 지능적인 피싱 공격으로 진화하고 있어 개인정보 입력 시 진위 여부를 확인할 수 있는 방법에 대한 연구개발이 시급하다. </p><h2 id="최근의-사이버-공격-방식"><a href="#최근의-사이버-공격-방식" class="headerlink" title="최근의 사이버 공격 방식"></a>최근의 사이버 공격 방식</h2><p>새로운 공격기법은 에이전트화, 분신화, 자동화, 은닉화를 추구하고 있다. 대표적으로 분산 서비스 공격(디도스 공격)이 있다. </p><h3 id="에이전트화"><a href="#에이전트화" class="headerlink" title="에이전트화"></a>에이전트화</h3><p>최근에는 원격으로 조정가능한 에이전트형의 백도어를 설치하고 이를 이용하여 다른 시스템을 공격하는 방법을 이용한다.</p><h3 id="분신화"><a href="#분신화" class="headerlink" title="분신화"></a>분신화</h3><p>최근의 공격기법에서는 침입탐지 시스템 등의 보안 시스템을 우회하기 위하여 많은 수의 시스템에서 단일의 시스템 또는 다수의 시스템을 공격하는 방법을 사용한다. </p><h3 id="자동화"><a href="#자동화" class="headerlink" title="자동화"></a>자동화</h3><p>인터넷 웜 및 윈도우용 공격도구, 그리고 최근 침해사고에서 발견되는 자동 공격 스크립트의 증가는 공격 도구가 자동화되고 있음을 의미한다.</p><h3 id="은낙화"><a href="#은낙화" class="headerlink" title="은낙화"></a>은낙화</h3><p>에이전트와 공격자 간의 통신은 암호화 및 터널링 기법을 사용하여 탐지하기 어렵도록 한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;사이버-공격&quot;&gt;&lt;a href=&quot;#사이버-공격&quot; class=&quot;headerlink&quot; title=&quot;사이버 공격&quot;&gt;&lt;/a&gt;사이버 공격&lt;/h2&gt;&lt;p&gt;인터넷을 통해 다른 컴퓨터에 접속하여 상대방 국가나 기업, 개인에 손상을 입히려는 행동.&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>create-react-app + TypeScript + Next.js</title>
    <link href="http://dev.kyoungah.com/2019/05/14/2019-05-14-nextjs-setting/"/>
    <id>http://dev.kyoungah.com/2019/05/14/2019-05-14-nextjs-setting/</id>
    <published>2019-05-14T14:04:23.000Z</published>
    <updated>2019-05-20T14:38:25.284Z</updated>
    
    <content type="html"><![CDATA[<p>TypeScript + create-react-app으로 생성된 프로젝트에 Next.js를 적용해보자.</p><h2 id="모듈-설치"><a href="#모듈-설치" class="headerlink" title="모듈 설치"></a>모듈 설치</h2><p>next와 next-typescript 설치한다. next-typeScript는 next에서 TypeScript를 쓸 수 있게 도와주는 플러그인이다.</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn add next @types/next </span><br><span class="line">yarn add @zeit/next-typescript</span><br></pre></td></tr></table></figure><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p>package.json에 next를 실행시키는 명령어를 적어준다.</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // ...</span><br><span class="line">  "scripts": &#123;</span><br><span class="line">    "dev": "next",</span><br><span class="line">    // ...</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="next-config-js"><a href="#next-config-js" class="headerlink" title="next.config.js"></a>next.config.js</h2><p>root 폴더에 next.config.js 파일을 생성한 후 next-typescript를 적용해준다. next에 플러그인을 적용하거나 webpack 커스터마이징을 할 때 이 파일에서 작업하면 된다. </p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> withTypescript = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@zeit/next-typescript'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="hljs-built_in">module</span>.exports = withTypescript();</span><br></pre></td></tr></table></figure><h2 id="babelrc-또는-package-json"><a href="#babelrc-또는-package-json" class="headerlink" title=".babelrc 또는 package.json"></a>.babelrc 또는 package.json</h2><p>.babelrc 파일을 생성해 아래와 같은 내용을 추가해준다. create-react-app으로 생성한 프로젝트는 babelrc 설정이 package.json안에 들어가 있기 때문에 따로 babelrc 파일을 생성할 필요가 없다.</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="hljs-attr">"presets"</span>: [</span><br><span class="line">    <span class="hljs-string">"next/babel"</span>,</span><br><span class="line">    <span class="hljs-string">"@zeit/next-typescript/babel"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h2><p>아래와 같이 typeScript 설정 파일을 생성해준다. </p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="hljs-attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="hljs-attr">"allowJs"</span>: <span class="hljs-literal">true</span>,</span><br><span class="line">    <span class="hljs-attr">"allowSyntheticDefaultImports"</span>: <span class="hljs-literal">true</span>,</span><br><span class="line">    <span class="hljs-attr">"jsx"</span>: <span class="hljs-string">"preserve"</span>,</span><br><span class="line">    <span class="hljs-attr">"lib"</span>: [<span class="hljs-string">"dom"</span>, <span class="hljs-string">"es2017"</span>],</span><br><span class="line">    <span class="hljs-attr">"module"</span>: <span class="hljs-string">"esnext"</span>,</span><br><span class="line">    <span class="hljs-attr">"moduleResolution"</span>: <span class="hljs-string">"node"</span>,</span><br><span class="line">    <span class="hljs-attr">"noEmit"</span>: <span class="hljs-literal">true</span>,</span><br><span class="line">    <span class="hljs-attr">"noUnusedLocals"</span>: <span class="hljs-literal">true</span>,</span><br><span class="line">    <span class="hljs-attr">"noUnusedParameters"</span>: <span class="hljs-literal">true</span>,</span><br><span class="line">    <span class="hljs-attr">"preserveConstEnums"</span>: <span class="hljs-literal">true</span>,</span><br><span class="line">    <span class="hljs-attr">"removeComments"</span>: <span class="hljs-literal">false</span>,</span><br><span class="line">    <span class="hljs-attr">"skipLibCheck"</span>: <span class="hljs-literal">true</span>,</span><br><span class="line">    <span class="hljs-attr">"sourceMap"</span>: <span class="hljs-literal">true</span>,</span><br><span class="line">    <span class="hljs-attr">"strict"</span>: <span class="hljs-literal">true</span>,</span><br><span class="line">    <span class="hljs-attr">"target"</span>: <span class="hljs-string">"esnext"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pages-index-js"><a href="#pages-index-js" class="headerlink" title="pages/index.js"></a>pages/index.js</h2><p>첫 페이지를 만들어준다.</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="hljs-keyword">const</span> Index:React.StatelessComponent = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Index Page<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Index;</span><br></pre></td></tr></table></figure><p>nextjs를 사용하려면 pages폴더가 무조건 있어야 한다. 이 pages안에 라우팅 url과 동일한 이름의 컴포넌트를 생성해야 한다. pages 컴포넌트가 next 라우팅과 동일하게 mapping 되기 때문에 이 규칙은 반드시 지켜야한다. </p><h2 id="실행"><a href="#실행" class="headerlink" title="실행"></a>실행</h2><p>아래의 명령어로 실행하면 방금 작성한 첫 페이지가 뜨는게 보일 것이다.</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://github.com/zeit/next-plugins/tree/master/packages/next-typescript" target="_blank" rel="noopener">zeit/next-plugins</a><br><a href="https://blueshw.github.io/2018/04/15/why-nextjs/" target="_blank" rel="noopener">[nextjs] nextjs는 어떻게 동작하는가?</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;TypeScript + create-react-app으로 생성된 프로젝트에 Next.js를 적용해보자.&lt;/p&gt;
&lt;h2 id=&quot;모듈-설치&quot;&gt;&lt;a href=&quot;#모듈-설치&quot; class=&quot;headerlink&quot; title=&quot;모듈 설치&quot;&gt;&lt;/a&gt;모듈 설치&lt;
      
    
    </summary>
    
      <category term="Front-end" scheme="http://dev.kyoungah.com/categories/Front-end/"/>
    
      <category term="Etc" scheme="http://dev.kyoungah.com/categories/Front-end/Etc/"/>
    
    
      <category term="Next.js" scheme="http://dev.kyoungah.com/tags/Next-js/"/>
    
  </entry>
  
  <entry>
    <title>Next.js</title>
    <link href="http://dev.kyoungah.com/2019/05/14/2019-05-14-nextjs-first/"/>
    <id>http://dev.kyoungah.com/2019/05/14/2019-05-14-nextjs-first/</id>
    <published>2019-05-14T12:27:26.000Z</published>
    <updated>2019-05-14T14:01:05.744Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSR"><a href="#CSR" class="headerlink" title="CSR"></a>CSR</h2><p>서버 측에서 HTML, JS, 리소스를 다운로드 한 후 브라우저에서 View를 렌더링하여 보여주는 방법.</p><ul><li>초기 로딩을 제외하면 서버에 view를 요청할 필요가 없으므로 화면 전환이 빠름.</li><li>초기 로딩속도 느림.</li><li>SEO 적용시 문제점이 있다.</li></ul><h2 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h2><p>서버 측에서 HTML &amp; View를 생성하여 응답하는 방법.</p><ul><li>초기 로딩 속도 빠름.</li><li>SEO 적용시에 어려움이 없다.</li><li>서버에 계속 view를 요청해야 하므로 서버 부담 큼.</li></ul><h3 id="검색엔진-최적화-SEO"><a href="#검색엔진-최적화-SEO" class="headerlink" title="검색엔진 최적화(SEO)"></a>검색엔진 최적화(SEO)</h3><p>웹 페이지 검색엔진이 자료를 수집하고 순위를 매기는 방식에 맞게 웹 페이지를 구성해서 검색 결과의 상위에 나올 수 있도록 하는 작업. 주로 meta tag를 이용해서 SEO 최적화 작업을 한다. </p><p>SSR 방식은 서버측에서 html에 콘텐츠를 채워 응답하기 떄문에 웹크롤러가 내용을 수집할 수 있으나 CSR 방식은 클라이언트에서 javaScript를 실행하여 view를 그리기 때문에 javaScript 실행 완료 전 까지 html의 콘텐츠는 비워져 있어서 웹 크롤러는 CSR 페이지를 빈 페이지로 인식하게 된다.</p><h2 id="Next-js"><a href="#Next-js" class="headerlink" title="Next.js"></a>Next.js</h2><p>React App의 SSR을 도와주는 프레임워크. </p><ul><li>서버 사이드 렌더링 기능 제공.</li><li>코드 스플릿 기능 제공.</li><li>간단한 클라이언트 사이드 라우팅 기능 제공.</li><li>HMR(Hot Module Replacement)을 지원하는 Webpack 기반의 개발 환경 제공.</li><li>Node.js HTTP 서버 구현 가능.</li><li>Babel, Webpack configuration 커스터마이징 기능 제공.</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://nextjs.org/learn/basics/getting-started" target="_blank" rel="noopener">Next.js - getting Started</a><br><a href="https://velog.io/@rjs1197/SSR%EA%B3%BC-CSR%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90" target="_blank" rel="noopener">SSR과 CSR의 차이를 알아보자</a><br><a href="https://goodgid.github.io/Server-Side-Rendering-and-Client-Side-Rendering/2" target="_blank" rel="noopener">서버 사이드 렌더링(SSR)과 클라이언트 사이드 렌더링(CSR)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CSR&quot;&gt;&lt;a href=&quot;#CSR&quot; class=&quot;headerlink&quot; title=&quot;CSR&quot;&gt;&lt;/a&gt;CSR&lt;/h2&gt;&lt;p&gt;서버 측에서 HTML, JS, 리소스를 다운로드 한 후 브라우저에서 View를 렌더링하여 보여주는 방법.&lt;/p&gt;
&lt;ul
      
    
    </summary>
    
      <category term="Front-end" scheme="http://dev.kyoungah.com/categories/Front-end/"/>
    
      <category term="Etc" scheme="http://dev.kyoungah.com/categories/Front-end/Etc/"/>
    
    
      <category term="Next.js" scheme="http://dev.kyoungah.com/tags/Next-js/"/>
    
  </entry>
  
  <entry>
    <title>tsconfig.json</title>
    <link href="http://dev.kyoungah.com/2019/05/13/2019-05-13-typescript-compiler-option/"/>
    <id>http://dev.kyoungah.com/2019/05/13/2019-05-13-typescript-compiler-option/</id>
    <published>2019-05-13T13:45:44.000Z</published>
    <updated>2019-06-03T17:48:53.900Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h2><p><strong>tsconfig.json</strong> 파일은 프로젝트를 컴파일 하는데 필요한 루트 파일과 컴파일러 옵션을 지정한다.</p><p><a href="http://json.schemastore.org/tsconfig" target="_blank" rel="noopener">JSON schema for the TypeScript compiler’s configuration file</a>에서 스펙을 확인할 수 있다.</p><p>ex)</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="hljs-attr">"module"</span>: <span class="hljs-string">"system"</span>,</span><br><span class="line">        <span class="hljs-attr">"noImplicitAny"</span>: <span class="hljs-literal">true</span>,</span><br><span class="line">        <span class="hljs-attr">"removeComments"</span>: <span class="hljs-literal">true</span>,</span><br><span class="line">        <span class="hljs-attr">"preserveConstEnums"</span>: <span class="hljs-literal">true</span>,</span><br><span class="line">        <span class="hljs-attr">"outFile"</span>: <span class="hljs-string">"../../built/local/tsc.js"</span>,</span><br><span class="line">        <span class="hljs-attr">"sourceMap"</span>: <span class="hljs-literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="hljs-attr">"include"</span>: [</span><br><span class="line">        <span class="hljs-string">"src/**/*"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="hljs-attr">"exclude"</span>: [</span><br><span class="line">        <span class="hljs-string">"node_modules"</span>,</span><br><span class="line">        <span class="hljs-string">"**/*.spec.ts"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="compileOnSave"><a href="#compileOnSave" class="headerlink" title="compileOnSave"></a>compileOnSave</h3><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // ...</span><br><span class="line">  "compileOnSave": true,</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ts 파일을 저장 시 자동 컴파일을 해준다. </li><li>true / false (default: false)</li></ul><h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // ...</span><br><span class="line">  "extends": "./configs/base",</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>extends 속성을 사용해 다른 파일의 설정을 상속할 수 있다. <ul><li>클라이언트 작업물과 서버 사이드 작업물의 설정이 비슷하다면 한 파일을 만들어놓고 상속받은 후 필요한 부분만 바꿔 쓸 수 있다.</li></ul></li></ul><h3 id="files-include-exclude"><a href="#files-include-exclude" class="headerlink" title="files, include, exclude"></a>files, include, exclude</h3><p>셋다 설정이 없으면 모든 ts 파일들을 컴파일 해준다.</p><h4 id="files"><a href="#files" class="headerlink" title="files"></a>files</h4><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // ...</span><br><span class="line">  "files": [</span><br><span class="line">        "core.ts",</span><br><span class="line">        "sys.ts",</span><br><span class="line">        "types.ts",</span><br><span class="line">        "emitter.ts",</span><br><span class="line">        "tsc.ts",</span><br><span class="line">        <span class="hljs-string">"diagnosticInformationMap.generated.ts"</span></span><br><span class="line">    ],</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>상대 혹은 절대 경로의 리스트 배열이다.</li><li>files에 지정되어 있는 파일은 exclude에 관계 없이 항상 컴파일 대상에 포함된다. -&gt; exclude보다 순위가 더 높다.</li></ul><h4 id="include"><a href="#include" class="headerlink" title="include"></a>include</h4><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // ...</span><br><span class="line">  "include": [</span><br><span class="line">        <span class="hljs-string">"src/**/*"</span></span><br><span class="line">    ],</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>glob 패턴 (.gitignore 이랑 비슷함.).</li><li>include에 포함된 패턴과 맞는 파일들을 컴파일 대상에 포함시킨다.</li><li>exclude 속성으로 필터링 할 수 있다.</li><li>js파일을 컴파일 대상에 포함시키는 allowJs 옵션이 있다.<ul><li>true/false</li></ul></li></ul><h4 id="exclude"><a href="#exclude" class="headerlink" title="exclude"></a>exclude</h4><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // ...</span><br><span class="line">  "exclude": [</span><br><span class="line">        "node_modules",</span><br><span class="line">        <span class="hljs-string">"**/*.spec.ts"</span></span><br><span class="line">    ],</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>glob 패턴 (.gitignore 이랑 비슷함.)</li><li>exclude에 포함된 패턴과 맞는 파일들은 컴파일 대상에서 제외된다. </li><li>node_modules, bower_components, jspm_packages, <outdir>은 default로 제외한다.</outdir></li></ul><h3 id="compileOptions"><a href="#compileOptions" class="headerlink" title="compileOptions"></a>compileOptions</h3><h4 id="types"><a href="#types" class="headerlink" title="types"></a>types</h4><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // ...</span><br><span class="line">  "compilerOptions": &#123;</span><br><span class="line">    // ...</span><br><span class="line">    "types" : ["node", "lodash", "express"],</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>타입을 가져올 패키지 목록.</li><li>기본적으로는 @types 모든 패키지가 컴파일에 포함된다. types를 지정할 경우 나열된 패키지만 컴파일 대상에 포함된다. </li></ul><h3 id="target"><a href="#target" class="headerlink" title="target"></a>target</h3><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // ...</span><br><span class="line">  "compilerOptions": &#123;</span><br><span class="line">    // ...</span><br><span class="line">    "target": "es3",</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>컴파일 결과물을 js의 어떤 버전으로 할 것인지 지정한다. (default: es3) </li></ul><h3 id="lib"><a href="#lib" class="headerlink" title="lib"></a>lib</h3><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#123;</span><br><span class="line">  <span class="hljs-attr">"CompilerOptions"</span>: &#123;</span><br><span class="line">    // ...</span><br><span class="line">    "lib": [</span><br><span class="line">      "dom",</span><br><span class="line">      "es5",</span><br><span class="line">      <span class="hljs-string">"es2015.promise"</span> </span><br><span class="line">    ],</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>컴파일에 포함될 라이브러리 파일 목록을 지정해준다. 지정해주지 않으면 아래의 기본 값이 저장된다.</li><li>ES5의 기본 값: dom, es5, scripthost</li><li>ES6의 기본 값: dom, dom.iterable, es6, scripthost</li><li>위의 기본 값 대신에 커스텀하게 라이브러리를 쓰려고 할 때, lib을 정의한다.</li><li><a href="https://stackoverflow.com/questions/41993811/understanding-target-and-module-in-tsconfig" target="_blank" rel="noopener">Understanding “target” and “module” in tsconfig</a></li></ul><h3 id="outDir"><a href="#outDir" class="headerlink" title="outDir"></a>outDir</h3><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // ...</span><br><span class="line">  "compilerOptions": &#123;</span><br><span class="line">    // ...</span><br><span class="line">    "outDir": "",</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>컴파일된 파일들의 위치를 지정해준다.</li></ul><h3 id="outFile"><a href="#outFile" class="headerlink" title="outFile"></a>outFile</h3><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // ...</span><br><span class="line">  "compilerOptions": &#123;</span><br><span class="line">    // ...</span><br><span class="line">    "outFile": "",</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>컴파일 결과물을 단일 파일로 떨궈준다.</li></ul><h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // ...</span><br><span class="line">  "compilerOptions": &#123;</span><br><span class="line">    // ...</span><br><span class="line">    "module": "es3",</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>컴파일된 모듈의 결과물을 어떤 모듈 시스템으로 할 지 결정한다.<ul><li>commonjs, amd, umd, system, es6, es2015, none 중 설정 가능.</li><li>amd, systme 은 outFile 설정과 사용된다.</li></ul></li><li>지정하지 않으면 target이 es6일 땐 es6으로, 그렇지 않으면 commonJS가 기본값으로 사용된다.</li><li>es6, es2015는 target값이 es5 이하일때 사용 가능.</li></ul><p><a href="https://typescript-kr.github.io/pages/tsconfig.json.html" target="_blank" rel="noopener">TypeScript-Handbook 한글 문서 - tsconfig</a><br><a href="https://typescript-kr.github.io/pages/Compiler%20Options.html" target="_blank" rel="noopener">TypeScript-Handbook 한글 문서 - 컴파일러 옵션</a><br><a href="https://vomvoru.github.io/blog/tsconfig-compiler-options-kr/" target="_blank" rel="noopener">tsconfig 컴파일 옵션 정리</a><br><a href="https://norux.me/59" target="_blank" rel="noopener">tsconfig.json의 lib</a><br><a href="https://www.inflearn.com/course/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%BD%94%EB%A6%AC%EC%95%84-1705-%EA%B8%B0%EC%B4%88-%EC%84%B8%EB%AF%B8%EB%82%98/lecture/6803" target="_blank" rel="noopener">타입스크립트 코리아 : 2017.05 기초 세미나 (4) - Compiler Options</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;tsconfig-json&quot;&gt;&lt;a href=&quot;#tsconfig-json&quot; class=&quot;headerlink&quot; title=&quot;tsconfig.json&quot;&gt;&lt;/a&gt;tsconfig.json&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;tsconfig.json&lt;/str
      
    
    </summary>
    
      <category term="Front-end" scheme="http://dev.kyoungah.com/categories/Front-end/"/>
    
      <category term="TypeScript" scheme="http://dev.kyoungah.com/categories/Front-end/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="http://dev.kyoungah.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>연쇄 행렬 곱셈 문제</title>
    <link href="http://dev.kyoungah.com/2019/05/12/2019-03-17-algorithms-minMatMult/"/>
    <id>http://dev.kyoungah.com/2019/05/12/2019-03-17-algorithms-minMatMult/</id>
    <published>2019-05-12T14:30:07.000Z</published>
    <updated>2019-06-03T17:47:20.885Z</updated>
    
    <content type="html"><![CDATA[<h2 id="연쇄-행렬-곱셈-문제"><a href="#연쇄-행렬-곱셈-문제" class="headerlink" title="연쇄 행렬 곱셈 문제"></a>연쇄 행렬 곱셈 문제</h2><p>n개의 행렬을 연쇄적으로 곱할 때 최적의 곱셈 순서를 구하는 문제. 즉 최소의 기본 곱셈 횟수를 가진 행렬의 곱셈 순서를 구하는 문제이다.</p><p>i x j 행렬과 j x k 행렬을 곱하는데에는 i x j x k번만큼의 곱셈이 필요하고 그 결과로는 i x k 번의 행렬을 얻는다. 행렬의 곱셈 연산은 결합법칙이 성립하기 때문에 n개의 행렬을 연쇄적으로 곱하는 경우에는 곱하는 순서에 따라 여러 가지 다른 방법으로 계산될 수 있다. 즉 어떤 순서로 곱하느냐에 따라 곱셈 횟수가 달라질 수 있다.</p><p>M1: 30 x 5<br>M2: 5 x 20<br>M3: 20 x 15<br>M4: 15 x 10 </p><p>이렇게 행렬이 있다고 가정하면 </p><p>M1 (M2 (M3M4)) = (20 x 15 x 10) + (5 x 20 x 10) + (30 x 5 x 10) = 5,500<br>(M1M2)(M3M4) = (30 x 5 x 20) + (20 x 15 x 10) + (30 x 20 x 10) - 12,000<br>M1( (M2M3) M4) = (5 x 20 x 15) + (5 x 15 x 10 ) + (30 x 5 x 10) = 3,750<br>((M1M2) M3 )M4 = (30 x 5 x 20) + (30 x 20 x 15) + (30 x 15 x 10) = 16,500<br>(M1 (M2M3))M4 = (5 x 20 x 15) + (30 x 5 x 15) + (30 x 15 x 10) = 6,900</p><p>위와 같은 결과가 나온다. 즉 M1( (M2M3) M4) 순으로 곱하면 우리가 원하는 최종적인 결과를 얻을 수 있다.</p><h2 id="연쇄-행렬-곱셉-문제에서의-최적성의-원리"><a href="#연쇄-행렬-곱셉-문제에서의-최적성의-원리" class="headerlink" title="연쇄 행렬 곱셉 문제에서의 최적성의 원리."></a>연쇄 행렬 곱셉 문제에서의 최적성의 원리.</h2><p>n개의 행렬을 곱하는 최적의 순서는 n개의 행렬의 어떤 부분집합을 곱하는 최적의 순서를 포함한다.</p><p>ex)<br>7개 행렬을 곱하는 최적의 순서를 (M1M2)( (((M3M4) M5) M6) M7) 이라고 할 때 M3, M4, M5를 곱하는 최적의 순서는 ((M3M4) M5) 이다.<br>이렇게 부분 문제들의 최적해로 n개 행렬을 곱하는 최적의 순서를 구할 수 있기 때문에 최적성의 원리가 성립하므로 동적 프로그래밍 방법으로 해결 가능하다.</p><h2 id="연쇄-행렬-곱셈-문제의-점화식"><a href="#연쇄-행렬-곱셈-문제의-점화식" class="headerlink" title="연쇄 행렬 곱셈 문제의 점화식"></a>연쇄 행렬 곱셈 문제의 점화식</h2><p>n개의 행렬 $M_i$($D_{i-1}$ x $D_i$)(1 &lt;= i &lt; n)를 아래와 같이 연쇄적으로 곱하는 문제를 생각해보자.</p><p>$M_1$ x $M_2$ x $M_3$ x … x $M_{n-1}$ x $M_n$ =  ($d_0$ x $d_1$) x ($d_1$ x $d_2$) x ($d_2$ x $d_3$) x … x ($d_{n-2}$ x $d_{n-1}$) x ($d_{n-1}$ x $d_n$)</p><p>최적해를 구축하기 위해서 테이블 C[][]를 다음과 같이 정의한다.</p><ul><li><strong>C(i, j)</strong> = $M_i$ x $M_{i+1}$ x … x $M_{j-1}$ x $M_j$ 를 수행하는데 필요한 곱셈의 최소 횟수(비용).</li></ul><p>C(i, i) -&gt; C(i, i + 1) -&gt; C(i, i + 2) -&gt; … -&gt; C(1, n) 순으로 계산하므로 따라서 구하려는 n개 행렬을 연쇄적으로 곱하는데 필요한 최소 곱셈의 횟수는 C(1, n)이 된다.</p><ul><li>C(i, i) = 0</li><li>C(i, i + 1) = $d_{i-1}$$d_i$$d_{i+1}$ =&gt; $d_{i-1}$ x $d_{i+1}$</li><li>C(i, i + 2) = min{$M_i$($M_{i+1}$$M_{i+2}$)) + 결합비용, ($M_i$$M_{i+1}$)$M_{i+2}$ + 결합비용} = min{C(i,i) + C(i + 1, i + 2) + $d_{i-1}$$d_i$$d_{i+2}$, C(i, i+1) + C(i+2, i+2) + $d_{i-1}$$d_{i+1}$$d_{i+2}$}</li><li>C(i, i+3) = min{$M_i$($M_{i+1}$$M_{i+2}$$M_{i+3}$) + 결합비용, ($M_i$$M_{i+1}$)($M_{i+2}$$M_{i+3}$) + 결합비용, ($M_i$$M_{i+1}$$M_{i+2}$)$M_{i+3}$ + 결합비용} = min{C(i, i) + C(i+1, i+3) + $d_{i-1}$$d_i$$d_{i+3}$, C(i, i+1) + C(i+2, i+3) + $d_{i-1}$$d_{i+1}$$d_{i+3}$, C(i, i+2) + C(i+3, i+3) + $d_{i-1}$$d_{i+2}$$d_{i+3}$}</li></ul><p>즉 점화식은 다음과 같다. </p><ul><li><strong>C(i, j)</strong> = min{($M_i$ … $M_k$)($M_{k+1}$ … $M_j$) + 결합비용} = min{C(i, k) + C(k + 1,j) + $d_{i-1}$$d_k$$d_j$} (i &lt;= k &lt;= j-1)</li><li>C(i, i) = 0</li></ul><h2 id="알고리즘"><a href="#알고리즘" class="headerlink" title="알고리즘"></a>알고리즘</h2><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_VALUE 9999999</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">min</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> ( a &lt; b ) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> a;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * length: 행렬의 갯수</span></span><br><span class="line"><span class="hljs-comment"> * d[]: 정수 배열</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minMatMult</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> length, <span class="hljs-keyword">int</span> d[])</span> </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// n개의 행렬을 곱하는데 필요한 곱셈 횟수의 최솟값을 저장하는 배열.</span></span><br><span class="line">  <span class="hljs-keyword">int</span> **matrix =  <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * length);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= length; i++) &#123;</span><br><span class="line">    matrix[i] =  <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * length);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// mtarix[i][i] 초기화.</span></span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= length; i++) &#123;</span><br><span class="line">    matrix[i][i] = <span class="hljs-number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> f = <span class="hljs-number">1</span>; f &lt;= length - <span class="hljs-number">1</span>; f++) &#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n = <span class="hljs-number">1</span>; n &lt;= length - f; n++) &#123;</span><br><span class="line">      <span class="hljs-keyword">int</span> j = f + n;</span><br><span class="line">      </span><br><span class="line">      matrix[n][j] = MAX_VALUE;</span><br><span class="line"></span><br><span class="line">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = n; k &lt;= j - <span class="hljs-number">1</span>; k++) &#123;</span><br><span class="line">        matrix[n][j] = min(matrix[n][j], matrix[n][k] + matrix[k + <span class="hljs-number">1</span>][j] + d[n - <span class="hljs-number">1</span>] * d[k] * d[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">int</span> value = matrix[<span class="hljs-number">1</span>][length];</span><br><span class="line"></span><br><span class="line">  <span class="hljs-built_in">free</span>(matrix);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="작동-방법"><a href="#작동-방법" class="headerlink" title="작동 방법"></a>작동 방법</h2><p>3 x 2, 2 x 4, 4 x 1인 세개의 행렬 M1, M2, M3이 있다고 할 때 여기서 d0  = 3, d1 = 2, d2 = 4, d3 = 1 이므로  d[] = { 3, 2, 4, 1 }, length = 3 이 된다.</p><ol><li>초기화</li></ol><table><thead><tr><th></th><th align="center">1</th><th align="center">2</th><th align="center">3</th></tr></thead><tbody><tr><td>1</td><td align="center">0</td><td align="center"></td><td align="center"></td></tr><tr><td>2</td><td align="center"></td><td align="center">0</td><td align="center"></td></tr><tr><td>3</td><td align="center"></td><td align="center"></td><td align="center">0</td></tr></tbody></table><p>C(i, i)  = 0 이므로 먼저 초기값을 세팅해준다. </p><ol start="2"><li>f = 1, n = 1, j = 2</li></ol><table><thead><tr><th></th><th align="center">1</th><th align="center">2</th><th align="center">3</th></tr></thead><tbody><tr><td>1</td><td align="center">0</td><td align="center">24</td><td align="center"></td></tr><tr><td>2</td><td align="center"></td><td align="center">0</td><td align="center"></td></tr><tr><td>3</td><td align="center"></td><td align="center"></td><td align="center">0</td></tr></tbody></table><p>C(1, 2) = min{C(1, 1) + C(2, 2) + d0 x d1 x d2} = 0 + 0 + 3 x 2 x 4 이므로 24이다.</p><ol start="3"><li>f = 1, n = 2, j = 3</li></ol><table><thead><tr><th></th><th align="center">1</th><th align="center">2</th><th align="center">3</th></tr></thead><tbody><tr><td>1</td><td align="center">0</td><td align="center">24</td><td align="center"></td></tr><tr><td>2</td><td align="center"></td><td align="center">0</td><td align="center">8</td></tr><tr><td>3</td><td align="center"></td><td align="center"></td><td align="center">0</td></tr></tbody></table><p>c(2, 3) = min{C(2, 2) + C(3, 3) + d1 x d2 x d3} = 0 + 0 + 2 x 4 x 1 이므로 8이다.</p><ol start="4"><li>f = 2, n = 1, j = 3</li></ol><table><thead><tr><th></th><th align="center">1</th><th align="center">2</th><th align="center">3</th></tr></thead><tbody><tr><td>1</td><td align="center">0</td><td align="center">24</td><td align="center">14</td></tr><tr><td>2</td><td align="center"></td><td align="center">0</td><td align="center">8</td></tr><tr><td>3</td><td align="center"></td><td align="center"></td><td align="center">0</td></tr></tbody></table><p>C(1, 3) = min{C(1, 1) + C(2, 3) + d0 x d1 x d3, C(1, 2) + C(3, 3) + d0 x d2 x d3} = min (0 + 8 + 3 x 2 x 1, 24 + 0 + 3 x 4 x 1)  = min(14, 36) 이므로 14 이다.</p><p>C(1, length)을 반환하므로 최소 곱셉횟수는 C(1, 3) = 14 가 된다.</p><h2 id="성능"><a href="#성능" class="headerlink" title="성능"></a>성능</h2><p>위의 알고리즘 소스를 보면 for문이 3중으로 중첩된 것을 볼 수 있다.</p><p>O($\sum_{s=1}^{n-1}$[(n - s) X s]) = O($n^3$) 이므로 알고리즘의 시간 복잡도는 O($n^3$)이다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920026935&condLscValue=001&condYr=&condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 알고리즘 5강</a><br><a href="https://huiyu.tistory.com/entry/DP-%EC%97%B0%EC%87%84%ED%96%89%EB%A0%AC-%EC%B5%9C%EC%86%8C%EA%B3%B1%EC%85%88-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98" target="_blank" rel="noopener">[DP] 연쇄행렬 최소곱셈 알고리즘</a><br><a href="https://twinparadox.tistory.com/183" target="_blank" rel="noopener">[Algorithm] 동적계획법 - 연속 행렬 곱셈 본문</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;연쇄-행렬-곱셈-문제&quot;&gt;&lt;a href=&quot;#연쇄-행렬-곱셈-문제&quot; class=&quot;headerlink&quot; title=&quot;연쇄 행렬 곱셈 문제&quot;&gt;&lt;/a&gt;연쇄 행렬 곱셈 문제&lt;/h2&gt;&lt;p&gt;n개의 행렬을 연쇄적으로 곱할 때 최적의 곱셈 순서를 구하는 
      
    
    </summary>
    
      <category term="Base" scheme="http://dev.kyoungah.com/categories/Base/"/>
    
      <category term="Algorithms" scheme="http://dev.kyoungah.com/categories/Base/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://dev.kyoungah.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>피보나치 수열</title>
    <link href="http://dev.kyoungah.com/2019/05/12/2019-03-17-algorithms-fibonachi/"/>
    <id>http://dev.kyoungah.com/2019/05/12/2019-03-17-algorithms-fibonachi/</id>
    <published>2019-05-12T13:35:49.000Z</published>
    <updated>2019-05-12T13:57:15.455Z</updated>
    
    <content type="html"><![CDATA[<h2 id="피보나치-수열"><a href="#피보나치-수열" class="headerlink" title="피보나치 수열"></a>피보나치 수열</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(0) = 0.</span><br><span class="line">f(1) = 1.</span><br><span class="line">f(n) = f(n - 1) + f(n -2), n &gt;= 2.</span><br></pre></td></tr></table></figure><p>피보나치 수열은 정의 자체가 최적성의 원리가 성립되는 점화식이므로 바로 동적 프로그래밍 방법을 적용할 수 있다.</p><p>2 이상인 n에 대해 f(n)은 그 소문제의 해인 f(n - 1)과 f(n - 2)의 합으로 구성되므로 f(0)과 f(1)을 먼저 테이블에 저장한 후 n을 2로부터 1씩 증가시키며 해를 구한 뒤 테이블에 저장한다. n에 어떤 값이 있더라도 f(n)을 구할 시점에는 f(n - 1)과 f(n - 2)가 항상 테이블에 저장되어 있으므로 테이블을 이용하여 즉시 f(n)을 구할 수 있다.</p><h2 id="알고리즘"><a href="#알고리즘" class="headerlink" title="알고리즘"></a>알고리즘</h2><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 50 이상의 수열에서는 int형 범위를 초과하기 때문에 double을 반환형으로 사용하였다.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">fibonachi</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">double</span> *fiboArr = (<span class="hljs-keyword">double</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">double</span>) * num);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// f(0)과 f(1)을 테이블에 저장한다.</span></span><br><span class="line">  fiboArr[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;</span><br><span class="line">  fiboArr[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// i를 2부터 1씩 증가시키며 f(i)의 해를 테이블에 저장된 f(i - 1)과 f(i - 2)의 합으로 계산하여 다시 테이블에 저장한다.</span></span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= num; i++) &#123;</span><br><span class="line">    fiboArr[i] = fiboArr[i - <span class="hljs-number">1</span>] + fiboArr[i - <span class="hljs-number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> fiboArr[num];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 하면 데이터를 저장하기 위해 필요한 테이블이 O(n) 에 비례해지는 단점이 있다.</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">fibonachi</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> fibonachi(num - <span class="hljs-number">1</span>) + fibonachi(num - <span class="hljs-number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>재귀방식으로 구현할 수도 있으나 실행시간이 늘어난다는 단점이 있다.</p><h2 id="성능-분석"><a href="#성능-분석" class="headerlink" title="성능 분석"></a>성능 분석</h2><p>동적 프로그래밍 방식으로 푸는 경우 알고리즘의 for 루프는 구하려는 피보나치 수열의 순번 n만큼 반복하므로 시간 복잡도는 O(n)이다.</p><p>순환 호출 방식으로 푸는 경우 성능은 O($n^2$) 이다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920026935&condLscValue=001&condYr=&condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 알고리즘 5강</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;피보나치-수열&quot;&gt;&lt;a href=&quot;#피보나치-수열&quot; class=&quot;headerlink&quot; title=&quot;피보나치 수열&quot;&gt;&lt;/a&gt;피보나치 수열&lt;/h2&gt;&lt;figure class=&quot;highlight plain hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
      <category term="Base" scheme="http://dev.kyoungah.com/categories/Base/"/>
    
      <category term="Algorithms" scheme="http://dev.kyoungah.com/categories/Base/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://dev.kyoungah.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>동적 프로그래밍 방법</title>
    <link href="http://dev.kyoungah.com/2019/05/12/2019-03-17-algorithms-dynamic-programming/"/>
    <id>http://dev.kyoungah.com/2019/05/12/2019-03-17-algorithms-dynamic-programming/</id>
    <published>2019-05-12T12:53:04.000Z</published>
    <updated>2019-05-12T13:57:06.686Z</updated>
    
    <content type="html"><![CDATA[<h2 id="동적-프로그래밍-방식"><a href="#동적-프로그래밍-방식" class="headerlink" title="동적 프로그래밍 방식"></a>동적 프로그래밍 방식</h2><p>문제의 크기가 작은 소문제에 대한 해를 저장해 놓고, 이를 이용하여 크기가 보다 큰 문제의 해를 점진적으로 만들어가는 상향식 접근 방법.</p><ul><li>각 작은 문제는 원래의 문제와 동일한 문제지만 입력의 크기만 작다.</li><li>입력의 크기가 아주 작은 단순한 문제가 되면 쉽게 해를 구할 수 있고 이를 테이블에 저장한다.</li><li>이후 해당 소문제의 해가 필요할 떄마다 테이블에 저장된 결과를 바로 이용한다.</li></ul><p>동적 프로그래밍 방법은 주로 최솟값 또는 최댓값 구하는 최적화 문제에 사용된다.</p><h3 id="최적성의-원리"><a href="#최적성의-원리" class="headerlink" title="최적성의 원리"></a>최적성의 원리</h3><p>동적 프로그래밍 방법은 최적성의 원리가 반드시 성립하는 최적화 문제의 대상이 된다. </p><ul><li><strong>최적성의 원리</strong>: 주어진 문제에 대한 최적해는 주어진 문제의 소문제에 대한 문제에 대한 최적해로 구성된다는 원리.</li></ul><h2 id="동적-프로그래밍-방법의-처리-과정"><a href="#동적-프로그래밍-방법의-처리-과정" class="headerlink" title="동적 프로그래밍 방법의 처리 과정"></a>동적 프로그래밍 방법의 처리 과정</h2><ol><li>주어진 문제에 대해서 최적해를 제공하는 점화식을 도출한다.</li><li>가장 작은 소문제부터 점화식의 해를 구한 뒤 이를 테이블에 저장한ㄷ나.</li><li>테이블에 저장되어 있는 소문제의 해를 이용하여 점차적으로 큰 상위 문제의 해를 구한다.</li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920026935&condLscValue=001&condYr=&condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 알고리즘 5강</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;동적-프로그래밍-방식&quot;&gt;&lt;a href=&quot;#동적-프로그래밍-방식&quot; class=&quot;headerlink&quot; title=&quot;동적 프로그래밍 방식&quot;&gt;&lt;/a&gt;동적 프로그래밍 방식&lt;/h2&gt;&lt;p&gt;문제의 크기가 작은 소문제에 대한 해를 저장해 놓고, 이를 이
      
    
    </summary>
    
      <category term="Base" scheme="http://dev.kyoungah.com/categories/Base/"/>
    
      <category term="Algorithms" scheme="http://dev.kyoungah.com/categories/Base/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://dev.kyoungah.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>인증</title>
    <link href="http://dev.kyoungah.com/2019/05/12/2019-05-12-computer-security-authentication/"/>
    <id>http://dev.kyoungah.com/2019/05/12/2019-05-12-computer-security-authentication/</id>
    <published>2019-05-12T11:04:26.000Z</published>
    <updated>2019-05-12T11:31:58.031Z</updated>
    
    <content type="html"><![CDATA[<h2 id="인증"><a href="#인증" class="headerlink" title="인증"></a>인증</h2><p>어떤 실체가 정말 그 실체가 맞는지 확인하는 과정. 이때 실체는 메시지, 사용자, 출처, 장치 등이 될 수 있다.</p><h2 id="메시지-인증"><a href="#메시지-인증" class="headerlink" title="메시지 인증"></a>메시지 인증</h2><p>수신된 메시지에 대한 인증을 의미한다. 즉, 메시지의 내용이 전송 도중 불법적으로 변경되지 않고 정확하고 완전하게 수신되었는지 확인하는 것을 말한다.</p><p>받는 사람은 메시지 이외의 부가적인 정보를 보낸 사람으로부터 얻어야 한다. 그러한 정보를 메시지 인증 코드(MAC)라고 한다. </p><ul><li>MAC는 메시지에 덧붙혀서 전송해야 하므로 메시지 크기와는 독립적이면서 작은 크기가 좋다.</li><li>MAC는 크기가 작으면서도 메시지의 위변조 여부 확인이 가능해야 한다.</li><li>제 3자가 메시지의 내용을 위변조 할 수 없도록 비밀키를 이용한다.</li></ul><h3 id="메시지-인증-방법"><a href="#메시지-인증-방법" class="headerlink" title="메시지 인증 방법"></a>메시지 인증 방법</h3><p>송신자는 메시지를 송신할 때 송수신 양자 간에 사전에 약속된 비밀키를 이용하여 메시지 무결성 검사 부호인 메시지 인증 코드(MAC)를 산출하고 이를 메시지와 함께 전송한다.</p><p>키를 알고 있는 수신자는 비밀키를 이용하여 메시지 인증 코드를 재산출하여 수신한 미세지 인증 코드와 비교함으로써 변조 사실을 검사할 수 있다.</p><p>비교 결과 동일한 값이면 메시지의 내용을 신뢰할 수 있고, 값이 서로 다르다면 메시지가 변조되었거나 메시지 인증 코드가 변조 되었음을 의미한다.</p><h3 id="메시지-인증-알고리즘"><a href="#메시지-인증-알고리즘" class="headerlink" title="메시지 인증 알고리즘"></a>메시지 인증 알고리즘</h3><p>해시 함수에 기반을 둔 HMAC, 블록 암호에 기반을 둔 CMAC 등이 있다.</p><h2 id="사용자-인증"><a href="#사용자-인증" class="headerlink" title="사용자 인증"></a>사용자 인증</h2><p>시스템에 접근하려는 사용자에 대한 인증을 의미한다. 이때 시스템은 서버, PC,스마트폰, 홈페이지, 건물이나 사무실의 전자식 잠금장치 등이 될 수 있다.</p><h3 id="비밀번호-방식"><a href="#비밀번호-방식" class="headerlink" title="비밀번호 방식"></a>비밀번호 방식</h3><p>사용자가 입력하는 비밀번호를 이용하여 시스템이 이미 가지고 있던 정보와 일치하는지를 확인함으로써 사용자를 인증하는 방식이다. 가장 일반적인 방식의 사용자 인증이다. </p><p>이를 이해 시스템은 미리 사용자의 ID와 비밀번호의 쌍을 알고 있어야 한다. 예를 들어 데이터베이스를 이용하는 홈페이지 시스템이라면 사용자 ID와 비밀번호의 쌍을 특정 테이블에 저장해 두고 키는 사용자 ID로 설정해서 가지고 있다. </p><p>비밀번호 방식의 사용자 인증을 이용하는 경우, 시스템에 저장된 비밀번호가 유출되면 악의적인 사용자가 정상적인 사용자로 가장하여 인증을 통과할 수 있는 위험이 있다. 이를 막기 위한 방법으로 비밀번호를 그대로 시스템에 저장하지 않고 해시코드로 저장하는 방법을 이용한다.</p><h3 id="생체인식-방식"><a href="#생체인식-방식" class="headerlink" title="생체인식 방식"></a>생체인식 방식</h3><p>개개인의 고유한 정보로 알려진 특정 생체의 정보를 이용하여 사용자를 인증하는 방식이다. 대표적인 생체정보로는 지문, 홍채, 음성, 손등의 혈관 등이 있다.</p><p>비밀번호 방식과 마찬가지로 특정 사용자를 인증하기 위해서는 해당 사용자의 생체정보를 미리 시스템에 저장해두어야 하며 인증이 필요한 시점에 시스템에 접근하려는 사용자의 생체정보를 읽어들여서 저장해 둔 정보와 비교해야 한다.</p><p>요즘에는 지문이나 홍채 등을 인식하는 스마트폰이 있어, 스마트폰의 잠금 해제뿐만 아니라 스마트폰을 이용한 결제나 스마트폰을 이용한 홈페이지 접근 시 생체인식 방식으로 사용자 인증을 하는 사례가 늘고 있다.</p><h3 id="토큰-방식"><a href="#토큰-방식" class="headerlink" title="토큰 방식"></a>토큰 방식</h3><p>사용자가 소요하고 있는 특정한 정보를 이용하여 해당 사용자를 인증하는 방식이다. 대표적인 토큰으로는 USB 토큰, 스마트카드, 실물 키 등이 있다.</p><h3 id="2단계-인증"><a href="#2단계-인증" class="headerlink" title="2단계 인증"></a>2단계 인증</h3><p>한가지 정보만 이용하는 경우 유출이나 분실 시 제 3자가 사용자 인증을 통과할 수 있는 취약점이 있다. 이를 보완하는 방법으로 2단계 인증을 이용한다.</p><p>첫 번째 단계에서는 사용자가 알고 있는 비밀번호를 이용하여 사용자 인증을 하고, 두 번째 단계에서는 사용자가 소유하고 있는 토큰을 이용하여 사용자 인증을 한다. 서로 다른 성격의 정보를 혼합하여 이용함으로써 보다 엄밀하게 사용자 인증을 할 수 있게 된다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920020759&condLscValue=001&condYr=&condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 컴퓨터 보안 3강</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;인증&quot;&gt;&lt;a href=&quot;#인증&quot; class=&quot;headerlink&quot; title=&quot;인증&quot;&gt;&lt;/a&gt;인증&lt;/h2&gt;&lt;p&gt;어떤 실체가 정말 그 실체가 맞는지 확인하는 과정. 이때 실체는 메시지, 사용자, 출처, 장치 등이 될 수 있다.&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="Base" scheme="http://dev.kyoungah.com/categories/Base/"/>
    
      <category term="Computer security" scheme="http://dev.kyoungah.com/categories/Base/Computer-security/"/>
    
    
      <category term="Computer security" scheme="http://dev.kyoungah.com/tags/Computer-security/"/>
    
  </entry>
  
  <entry>
    <title>쓰레드</title>
    <link href="http://dev.kyoungah.com/2019/05/10/2019-03-09-operating-system-thread/"/>
    <id>http://dev.kyoungah.com/2019/05/10/2019-03-09-operating-system-thread/</id>
    <published>2019-05-10T11:35:45.000Z</published>
    <updated>2019-05-10T11:38:19.012Z</updated>
    
    <content type="html"><![CDATA[<p>기본적인 처리단위는 <strong>프로세스</strong>라고 할 수 있다. 하나의 프로그램을 수행하기 위하여 하나의 주소공간과 그 주소공간 내에서 하나의 제어흐름으로 구성되는 프로세스를 사용하게 된다.</p><p>프로세스의 실행단위가 되는 것은 하나의 프로세스 내에서 프로그램이 수행될 때 각각의 실행 단위 시간 안에 하나의 실행점 만이 존재함을 의미하며, 단일 프로세스 내에서 동시처리, 즉 병렬처리는 불가능하다는 것을 나타낸다.</p><h2 id="쓰레드"><a href="#쓰레드" class="headerlink" title="쓰레드"></a>쓰레드</h2><p><a href="/images/base/operating-system-thread.png">프로세스와 쓰레드</a></p><ul><li>하나의 프로세스 내에서 다중처리를 위해 제안된 개념으로 실행 단위를 프로세스에서 한 단계 낮추어 규정한 것이다. </li><li>대부분의 기존 프로그램은 하나의 프로세스가 하나의 쓰레드를 갖는 형태이나, 처리효율을 극대화하는 방법으로 프로세스 내에서의 병렬적 수행을 위해 다중 쓰레딩을 이용한다.</li><li>하나의 프로그램 내에서 제어의 단일 순차적 흐름으로 정의된다.</li><li>하나의 프로세스 내에는 하나 이상의 쓰레드가 존재한다.</li><li>하나의 쓰레드 내에서는 하나의 실행점만 존재한다. </li><li>실행에 필요한 최소한의 정보만을 가지고 프로그램 수행 시 자신이 속해있는 프로세스의 실행환경을 공유한다.<ul><li>프로그램 카운터, 스택, 쓰레드 관리 정보 등…</li></ul></li><li>프로세스와 마찬가지로 쓰레드가 생성된 후 준비상태, 실행상태, 대기상태를 거친 후 종료상태에 이르게 된다.</li></ul><h2 id="다중-쓰레드의-장점"><a href="#다중-쓰레드의-장점" class="headerlink" title="다중 쓰레드의 장점"></a>다중 쓰레드의 장점</h2><ul><li>멀티 CPU 혹은 멀티 코어 시스템에서는 병렬처리 가능</li><li>처리 속도 별로 쓰레드가 나눠진 경우 효율적인 처리 가능<br>ex) 하나의 프로세스 안에 계산용 쓰레드, 입력용 쓰레드, 백업용 쓰레드가 있을 시 서로간에 영향을 미치지 않고 독립적으로 작업을 처리할 수 있다. </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;기본적인 처리단위는 &lt;strong&gt;프로세스&lt;/strong&gt;라고 할 수 있다. 하나의 프로그램을 수행하기 위하여 하나의 주소공간과 그 주소공간 내에서 하나의 제어흐름으로 구성되는 프로세스를 사용하게 된다.&lt;/p&gt;
&lt;p&gt;프로세스의 실행단위가 되는 것
      
    
    </summary>
    
      <category term="Base" scheme="http://dev.kyoungah.com/categories/Base/"/>
    
      <category term="Operating systems" scheme="http://dev.kyoungah.com/categories/Base/Operating-systems/"/>
    
    
      <category term="Operating systems" scheme="http://dev.kyoungah.com/tags/Operating-systems/"/>
    
  </entry>
  
  <entry>
    <title>선택 문제</title>
    <link href="http://dev.kyoungah.com/2019/05/10/2019-03-17-algorithms-selection/"/>
    <id>http://dev.kyoungah.com/2019/05/10/2019-03-17-algorithms-selection/</id>
    <published>2019-05-10T10:55:08.000Z</published>
    <updated>2019-05-12T13:56:53.686Z</updated>
    
    <content type="html"><![CDATA[<h2 id="선택-문제"><a href="#선택-문제" class="headerlink" title="선택 문제"></a>선택 문제</h2><p>n개의 원소가 임의의 순서로 저장된 배열에서 i번째로 작은 원소를 찾는 문제.</p><ul><li>i = 1 이면 최솟값.</li><li>i = n/2 이면 중간값.</li><li>i = n 이면 최댓값.</li></ul><p>직관적인 방법으로는 오름차순으로 정렬한 후 i 번째 원소를 찾으면 되는데 이떄 성능은 o($n log n$)이다.<br>또 다른 직관적인 방법으로는 최솟값 찾는 과정을 i번 반복한다. i-1번째까지는 최솟값을 찾은 후 삭제한다. 이 경우에는 최솟값을 찾는데 걸리는 시간 O(n)을 i번 반복하기 때문에 성능은 O(in)이다.</p><h2 id="최솟값-찾기"><a href="#최솟값-찾기" class="headerlink" title="최솟값 찾기"></a>최솟값 찾기</h2><p>각 데이터를 하나씩 모드 비교한다. </p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMinimum</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> min = arr[<span class="hljs-number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (arr[i] &lt; min) &#123;</span><br><span class="line">      min = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>n개의 데이터에서 대해서 최소한 length - 1번의 비교가 필요하므로 성능은 O(n)이다.</p><h2 id="최솟값과-최대값-모두-찾기"><a href="#최솟값과-최대값-모두-찾기" class="headerlink" title="최솟값과 최대값 모두 찾기."></a>최솟값과 최대값 모두 찾기.</h2><p>최솟값과 최댓값을 모두 찾으려면 최솟값을 찾은 후에 최댓값을 찾거나 최댓값을 찾은 후 최솟값을 찾으면 된다.</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findMinMax</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> min = arr[<span class="hljs-number">0</span>];</span><br><span class="line">  <span class="hljs-keyword">int</span> max = arr[<span class="hljs-number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// arr[0]과 arr[1]을 사용하여 최솟값/최댓값 초기화.</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (min &gt; max) &#123;</span><br><span class="line">    max = arr[<span class="hljs-number">0</span>];</span><br><span class="line">    min = arr[<span class="hljs-number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; length; i += <span class="hljs-number">2</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> small = <span class="hljs-number">0</span>, large = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 두 데이터 중에서 작은 값과 큰 값을 결정.</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (i &lt; length &amp;&amp; i + <span class="hljs-number">1</span> &lt; length &amp;&amp; arr[i] &lt; arr[i + <span class="hljs-number">1</span>]) &#123;</span><br><span class="line">      small = arr[i];</span><br><span class="line">      large = arr[i + <span class="hljs-number">1</span>];</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      small = arr[i + <span class="hljs-number">1</span>];</span><br><span class="line">      large = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 작은 값과 최솟 값을 비교.</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (small &lt; min) &#123;</span><br><span class="line">      min = small;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 큰 값과 최댓 값을 비교.</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (large &gt; max) &#123;</span><br><span class="line">      max = large;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"최댓값: %d, 최솟값: %d\n"</span>, max, min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 알고리즘을 이용하면 $(3/2 * n) - 2$번의 비교를 통해서 최솟값과 최댓값을 동시에 찾을 수 있다.</p><h3 id="i번째로-작은-원소-찾기-최악-O-n-2-평균-O-n"><a href="#i번째로-작은-원소-찾기-최악-O-n-2-평균-O-n" class="headerlink" title="i번째로 작은 원소 찾기: 최악 $O(n^2)$, 평균 O(n)"></a>i번째로 작은 원소 찾기: 최악 $O(n^2)$, 평균 O(n)</h3><p>퀵 정렬의 분할 함수 Partition()을 이용하면 모든 원소를 정렬하지 않고도 i번째로 작은 원소를 구할 수 있다.</p><ul><li>i = j 일때 피벗이 찾고자 하는 i 번째 원소.</li><li>i &lt; j 일때 왼쪽 부분배열에 대해 순환 적용.</li><li>i &gt; j 일때 오른쪽 부분배열에 대해 순환 적용.</li></ul><h4 id="분할"><a href="#분할" class="headerlink" title="분할"></a>분할</h4><p>피벗을 기준으로 주어진 배열을 두 부분배열로 분할한다. i가 피벗의 인덱스와 같으면 피벗의 값을 반환하고 종료한다.</p><h4 id="정복"><a href="#정복" class="headerlink" title="정복"></a>정복</h4><p>인덱스 i가 포함된 부분배열에 대해서 선택 알고리즘을 순환적으로 적용한다.</p><h4 id="결합"><a href="#결합" class="headerlink" title="결합"></a>결합</h4><p>필요 없다.</p><h4 id="알고리즘"><a href="#알고리즘" class="headerlink" title="알고리즘"></a>알고리즘</h4><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> temp = arr[a];</span><br><span class="line">    arr[a] = arr[b];</span><br><span class="line">    arr[b] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 퀵정렬에 사용된 분할 함수를 그대로 사용하면 된다.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> leftIndex, <span class="hljs-keyword">int</span> rightIndex)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">// 맨 왼쪽을 피벗으로 잡기 때문에 l_hold는 피벗의 위치 + 1, r_hold는 배열의 마지막 index</span></span><br><span class="line">  <span class="hljs-keyword">int</span> pivot = arr[leftIndex], l_hold = leftIndex + <span class="hljs-number">1</span>, r_hold = rightIndex;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">while</span> (l_hold &lt;= r_hold) &#123;</span><br><span class="line">    <span class="hljs-comment">// l_hold는 피벗보다 큰 값을 찾는다.</span></span><br><span class="line">    <span class="hljs-keyword">while</span> (l_hold &lt;= rightIndex &amp;&amp; arr[l_hold] &lt; pivot) &#123;</span><br><span class="line">      l_hold++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// r_hold는 피벗보다 작은 값을 찾는다.</span></span><br><span class="line">    <span class="hljs-keyword">while</span> (r_hold &gt; leftIndex &amp;&amp; arr[r_hold] &gt;= pivot) &#123;</span><br><span class="line">      r_hold--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">if</span> (l_hold &lt; r_hold) &#123;</span><br><span class="line">      <span class="hljs-comment">// arr[l_hold]와 arr[r_hold]의 값을 교환한다.</span></span><br><span class="line">      swap(arr, l_hold, r_hold);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 피벗과 arr[r_hold]값을 교환한다. </span></span><br><span class="line">  swap(arr, leftIndex, r_hold);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> r_hold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> leftIndex, <span class="hljs-keyword">int</span> rightIndex, <span class="hljs-keyword">int</span> findNum)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> pivot = partition(arr, leftIndex, rightIndex); <span class="hljs-comment">// 두 부분배열로 분할</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (findNum == pivot) &#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> arr[pivot];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (findNum &lt; leftIndex) &#123;</span><br><span class="line">      <span class="hljs-comment">// 왼쪽 부분배열에 대해 순환호출</span></span><br><span class="line">      <span class="hljs-keyword">return</span> findNumber(arr, leftIndex, pivot - <span class="hljs-number">1</span>, findNum);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      <span class="hljs-comment">// 오른쪽 부분배열에 대해서 순환호출</span></span><br><span class="line">      <span class="hljs-keyword">return</span> findNumber(arr, pivot + <span class="hljs-number">1</span>, rightIndex, findNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="성능분석"><a href="#성능분석" class="headerlink" title="성능분석"></a>성능분석</h4><p>최악의 경우 = 퀵 정렬의 최악의 경우 </p><ul><li>분할 함수가 항상 하나의 부분배열만 생성하는 경우.</li><li>오름차순으로 정렬된 상태에서 i = n을 찾는 경우.<ul><li>분할 함수 호출할 떄 마다 피벗의 인덱스는 1씩 증가. -&gt; Partition()을 O(n)번 호출. O($n^2$).</li><li>해결책은 항상 일정한 비율의 두 부분배열로 분할 시키면 된다.</li></ul></li></ul><p>평균적인 경우에는 O(n).</p><h3 id="i번째로-작은-원소-찾기-최악-O-n-평균-O-n"><a href="#i번째로-작은-원소-찾기-최악-O-n-평균-O-n" class="headerlink" title="i번째로 작은 원소 찾기: 최악 O(n), 평균 O(n)"></a>i번째로 작은 원소 찾기: 최악 O(n), 평균 O(n)</h3><p>특정한 성질을 만족하도록 피벗을 선택하되 항상 일정한 비율의 두 부분배열로 분할 시킨다. 그러면 항상 하나의 부분배열만으로 분할되는 문제를 피하여 최악의 수행 시간 O($n^2$)를 개선할 수 있다.</p><h4 id="피벗-선택-방법"><a href="#피벗-선택-방법" class="headerlink" title="피벗 선택 방법"></a>피벗 선택 방법</h4><ol><li>크기가 n인 배열의 원소를 5개씩 묶어 $n/5$개의 그룹을 형성한다. 이떄 n이 5의 배수가 되지 않아 그룹을 형성하지 못한 채 남은 원소들은 그대로 남겨둔다.</li><li>각 그룹에 대해서 중간 값을 찾는다.</li><li>$n/5$개의 중간값들을 대상으로 다시 중간값을 찾는다. </li><li>이렇게 계산된 ‘중간값들의 중간값’을 피벗으로 사용하여 주어진 배열을 분할한다.</li></ol><h4 id="알고리즘-1"><a href="#알고리즘-1" class="headerlink" title="알고리즘"></a>알고리즘</h4><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 삽입 정렬 함수</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> leftIndex, <span class="hljs-keyword">int</span> rightIndex)</span></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> i, j, key;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">for</span>(i = leftIndex + <span class="hljs-number">1</span>; i &lt;= rightIndex; i++)&#123;</span><br><span class="line">    key = arr[i]; <span class="hljs-comment">// 현재 삽입될 숫자인 i번째 정수를 key 변수로 복사</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 현재 정렬된 배열은 i-1까지이므로 i-1번째부터 역순으로 조사한다.</span></span><br><span class="line">    <span class="hljs-comment">// j 값은 음수가 아니어야 되고</span></span><br><span class="line">    <span class="hljs-comment">// key 값보다 정렬된 배열에 있는 값이 크면 j번째를 j+1번째로 이동</span></span><br><span class="line">    <span class="hljs-keyword">for</span>(j=i<span class="hljs-number">-1</span>; j&gt;=<span class="hljs-number">0</span> &amp;&amp; arr[j]&gt;key; j--)&#123;</span><br><span class="line">      arr[j+<span class="hljs-number">1</span>] = arr[j]; <span class="hljs-comment">// 레코드의 오른쪽으로 이동</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr[j+<span class="hljs-number">1</span>] = key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 분할 함수</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> leftIndex, <span class="hljs-keyword">int</span> rightIndex, <span class="hljs-keyword">int</span> pivot)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> swapIndex = leftIndex;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = leftIndex; i &lt;= rightIndex; i++) &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">      <span class="hljs-keyword">int</span> temp = arr[i];</span><br><span class="line">    </span><br><span class="line">      arr[i] = arr[swapIndex];</span><br><span class="line">      arr[swapIndex] = temp;</span><br><span class="line"></span><br><span class="line">      swapIndex += <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> swapIndex - <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">selection</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> leftIndex, <span class="hljs-keyword">int</span> rightIndex, <span class="hljs-keyword">int</span> findIndex)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> arrLength = rightIndex - leftIndex + <span class="hljs-number">1</span>;</span><br><span class="line">  <span class="hljs-keyword">int</span> medianNum = arrLength / <span class="hljs-number">5</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> &gt; findIndex &amp;&amp; findIndex &gt; arrLength) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 배열의 길이가 5보다 같거나 작으면 findIndex - 1번째 원소를 찾아 봔한한다.</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (arrLength &lt;= <span class="hljs-number">5</span>) &#123;</span><br><span class="line">    insertionSort(arr, leftIndex, rightIndex);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> arr[findIndex - <span class="hljs-number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">int</span> *maidanArr = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * medianNum);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 배열 arr에서 5개씩 원소를 묶어 n/5 개의 그룹을 만든 후 각 그룹에서 중간값을 구해 배열 maidanArr을 만든다.</span></span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; medianNum; i++) &#123;</span><br><span class="line">    maidanArr[i] = selection(arr, leftIndex + (<span class="hljs-number">5</span> * i), (leftIndex + (<span class="hljs-number">5</span> * (i+<span class="hljs-number">1</span>)<span class="hljs-number">-1</span>)), leftIndex + (<span class="hljs-number">5</span> * i) + <span class="hljs-number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 중간값들의 중간값을 계산하기 위해 선택 함수를 순환호출한다. </span></span><br><span class="line">  <span class="hljs-keyword">int</span> pivot = selection(maidanArr, <span class="hljs-number">0</span>, medianNum - <span class="hljs-number">1</span>, (medianNum / <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="hljs-comment">// pivot을 사용하여 배열 arr을 분할한다.</span></span><br><span class="line">  <span class="hljs-keyword">int</span> pivotIndex = partition(arr, leftIndex, rightIndex, pivot);</span><br><span class="line">  <span class="hljs-keyword">int</span> rank = pivotIndex - leftIndex + <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (findIndex &lt;= rank) &#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> selection(arr, leftIndex, pivotIndex, findIndex);</span><br><span class="line">  &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> selection(arr, pivotIndex + <span class="hljs-number">1</span>, rightIndex, findIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920026935&condLscValue=001&condYr=&condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 알고리즘 4강</a><br><a href="https://ronniej.sfuh.tk/kth-largest-element-array/" target="_blank" rel="noopener">프로그래밍 면접 문제 10 : Kth Largest Element in Array</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;선택-문제&quot;&gt;&lt;a href=&quot;#선택-문제&quot; class=&quot;headerlink&quot; title=&quot;선택 문제&quot;&gt;&lt;/a&gt;선택 문제&lt;/h2&gt;&lt;p&gt;n개의 원소가 임의의 순서로 저장된 배열에서 i번째로 작은 원소를 찾는 문제.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;i
      
    
    </summary>
    
      <category term="Base" scheme="http://dev.kyoungah.com/categories/Base/"/>
    
      <category term="Algorithms" scheme="http://dev.kyoungah.com/categories/Base/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://dev.kyoungah.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Mac 개발환경 설정</title>
    <link href="http://dev.kyoungah.com/2019/04/25/2019-04-25-etc-development-env-setting/"/>
    <id>http://dev.kyoungah.com/2019/04/25/2019-04-25-etc-development-env-setting/</id>
    <published>2019-04-25T14:46:25.000Z</published>
    <updated>2019-05-14T13:59:29.040Z</updated>
    
    <content type="html"><![CDATA[<p>맥북을 포맷하면서 개발환경을 새로 세팅하다가 기록해놓으면 좋을 것 같아서 기록함.</p><h2 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h2><ol><li>Homebrew 설치<ul><li><a href="https://brew.sh/index_ko" target="_blank" rel="noopener">Homebrew</a></li><li>Mac 패키지 관리자는 Homebrew 사용 중.</li></ul></li></ol><ol start="2"><li>git 설치  <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure></li></ol><h2 id="Front-end"><a href="#Front-end" class="headerlink" title="Front-end"></a>Front-end</h2><p>개인 프로젝트 진행 시 Node.js + yarn 환경을 사용함.<br>개발툴은 vsocde 사용함.</p><ol><li><p>Node.js 설치 </p><ul><li><a href="https://nodejs.org/ko/" target="_blank" rel="noopener">Node.js</a></li><li>LTS 버전 사용 중.</li></ul></li><li><p>yarn 설치 </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install yarn</span><br></pre></td></tr></table></figure><ul><li><a href="https://yarnpkg.com/en/" target="_blank" rel="noopener">yarn</a></li></ul></li><li><p>vscode 설치 </p><ul><li>공통 Extensions<ul><li>Atom One Dark Theme </li><li>Git History</li><li>Material IconTheme</li><li>Prettier </li></ul></li><li>JavaScript / React.js 관련 Extensions<ul><li>eslint</li><li>ES7 React/Redux/GraphQL/React-Native snippets</li></ul></li></ul></li></ol><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>자료구조나 알고리즘 공부 시 c로 코드를 작성 중.</p><ol><li><p>gcc 설치</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install gcc</span><br></pre></td></tr></table></figure></li><li><p>c로 작성 중인 프로젝트 폴더에 tasks.json 파일 작성.</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="hljs-attr">"version"</span>: <span class="hljs-string">"2.0.0"</span>,</span><br><span class="line">  <span class="hljs-attr">"tasks"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="hljs-attr">"type"</span>: <span class="hljs-string">"shell"</span>,</span><br><span class="line">      <span class="hljs-attr">"label"</span>: <span class="hljs-string">"gcc build active file"</span>,</span><br><span class="line">      <span class="hljs-attr">"command"</span>: <span class="hljs-string">"/usr/bin/gcc"</span>,</span><br><span class="line">      <span class="hljs-attr">"args"</span>: [</span><br><span class="line">        <span class="hljs-string">"-g"</span>,</span><br><span class="line">        <span class="hljs-string">"$&#123;file&#125;"</span>,</span><br><span class="line">        <span class="hljs-string">"-o"</span>,</span><br><span class="line">        <span class="hljs-string">"$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;"</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="hljs-attr">"options"</span>: &#123;</span><br><span class="line">        <span class="hljs-attr">"cwd"</span>: <span class="hljs-string">"/usr/bin"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="hljs-attr">"problemMatcher"</span>: [</span><br><span class="line">        <span class="hljs-string">"$gcc"</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="hljs-attr">"group"</span>: &#123;</span><br><span class="line">        <span class="hljs-attr">"kind"</span>: <span class="hljs-string">"build"</span>,</span><br><span class="line">        <span class="hljs-attr">"isDefault"</span>: <span class="hljs-literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>c 관련 vscode Extenstions 설치 필요함.</p><ul><li>C/C++</li><li>Code Runner</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;맥북을 포맷하면서 개발환경을 새로 세팅하다가 기록해놓으면 좋을 것 같아서 기록함.&lt;/p&gt;
&lt;h2 id=&quot;Mac&quot;&gt;&lt;a href=&quot;#Mac&quot; class=&quot;headerlink&quot; title=&quot;Mac&quot;&gt;&lt;/a&gt;Mac&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Homebre
      
    
    </summary>
    
      <category term="Etc" scheme="http://dev.kyoungah.com/categories/Etc/"/>
    
    
      <category term="etc" scheme="http://dev.kyoungah.com/tags/etc/"/>
    
  </entry>
  
  <entry>
    <title>props</title>
    <link href="http://dev.kyoungah.com/2019/04/25/2018-09-28-reactjs-props/"/>
    <id>http://dev.kyoungah.com/2019/04/25/2018-09-28-reactjs-props/</id>
    <published>2019-04-25T05:59:19.480Z</published>
    <updated>2019-04-25T05:59:19.480Z</updated>
    
    <content type="html"><![CDATA[<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>props는 Component 속성을 설정할 때 사용하는 요소이다. Component는 props를 받고 props의 값에 따라 다르게 렌더링 하거나 작동할 수 있다.<br>PropTypes 속성의 종류는 <a href="https://reactjs.org/docs/typechecking-with-proptypes.html" target="_blank" rel="noopener">React 공식 문서</a>에서 확인할 수 있다.</p><h4 id="부모-컴포넌트"><a href="#부모-컴포넌트" class="headerlink" title="부모 컴포넌트"></a>부모 컴포넌트</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> Child <span class="hljs-keyword">from</span> <span class="hljs-string">'./Child'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> (</span><br><span class="line">      &lt;Child singer=<span class="hljs-string">"Nell"</span> song=<span class="hljs-string">"Home"</span>/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Parent;</span><br></pre></td></tr></table></figure><p>props값은 해당 컴포넌트를 불러와 사용하는 부모 컴포넌트에서만 설정할 수 있다. </p><h4 id="자식-컴포넌트"><a href="#자식-컴포넌트" class="headerlink" title="자식 컴포넌트"></a>자식 컴포넌트</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 자식 컴포넌트</span></span><br><span class="line"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> &#123; singer, song &#125; = <span class="hljs-keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        지금 듣고 있는 노래는 &#123;singer&#125;의 &#123;song&#125;입니다.</span><br><span class="line">      &lt;<span class="hljs-regexp">/div&gt;</span></span><br><span class="line"><span class="hljs-regexp">    );</span></span><br><span class="line"><span class="hljs-regexp">  &#125;</span></span><br><span class="line"><span class="hljs-regexp">&#125;</span></span><br><span class="line"><span class="hljs-regexp"></span></span><br><span class="line"><span class="hljs-regexp">export default Child;</span></span><br></pre></td></tr></table></figure><p>props에 접근할 때는 this 키워드를 사용하여 접근한다. </p><p><img src="/images/frontend/reactjs-props-1.png" alt="실행결과"></p><p>부모 Component에서 자식 Component로 전달되며 받아온 props는 수정할 수 없다. </p><p><img src="/images/frontend/reactjs-props-2.png" alt="Object.isFrozen 메소드로 동결되어 있는것을 확인할 수 있다. props값을 바꾸려고 하면 에러가 난다."></p><h3 id="propTypes"><a href="#propTypes" class="headerlink" title="propTypes"></a>propTypes</h3><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">"prop-types"</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// ... 생략</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.propTypes = &#123;</span><br><span class="line">  singer: PropTypes.string,</span><br><span class="line">  song: PropTypes.string.isRequired <span class="hljs-comment">// 필수적으로 존재해야 한다. </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Child;</span><br></pre></td></tr></table></figure><p>컴포넌트의 필수 props를 지정하거나 props 타입을 지정할 때는 propTypes를 사용한다. propTypes를 지정하려면 <strong>prop-types</strong> 모듈이 필요하다.<br>필수 props를 지정하고 싶을 땐 propTypes를 설정할 때 isRequired를 사용하면 된다. </p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> &lt;Child singer=&#123;123&#125; song="Home" /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/frontend/reactjs-props-3.png" alt="잘못된 타입으로 props를 넘겨줘 보았다."><br>props의 타입을 propTypes에서 설정한 타입과 다른 타입으로 넘겨주면 렌더링은 되나 개발자 도구에 오류 메시지가 출력된다. </p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> &lt;Child singer="Nell" /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/frontend/reactjs-props-4.png" alt="필수 props를 제외해 보았다."><br>필수 props가 빠졌을 때도 렌더링은 되나 개발자 도구에 오류 메시지가 출력된다. </p><h3 id="defaultProps"><a href="#defaultProps" class="headerlink" title="defaultProps"></a>defaultProps</h3><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">"prop-types"</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// ... 생략</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.propTypes = &#123;</span><br><span class="line">  singer: PropTypes.string,</span><br><span class="line">  song: PropTypes.string.isRequired</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Child.defaultProps = &#123;</span><br><span class="line">  singer: <span class="hljs-string">"Hoobastank"</span>,</span><br><span class="line">  song: <span class="hljs-string">"Without A Fight"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Child;</span><br></pre></td></tr></table></figure><p>defaultProps를 사용해서 prop의 기본 값을 설정할 수 있다. defaultProps는 prop-types 모듈이 필요 없다. </p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> &lt;Child /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/frontend/reactjs-props-5.png" alt="defaultProps 적용"><br>props를 지정해주지 않으면 defaultProps에 있는 기본 값이 적용된다. </p><h3 id="transform-class-properties"><a href="#transform-class-properties" class="headerlink" title="transform-class-properties"></a>transform-class-properties</h3><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">"prop-types"</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">static</span> propTypes = &#123;</span><br><span class="line">    singer: PropTypes.string,</span><br><span class="line">    song: PropTypes.string.isRequired</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">static</span> defaultProps = &#123;</span><br><span class="line">    singer: <span class="hljs-string">"Hoobastank"</span>,</span><br><span class="line">    song: <span class="hljs-string">"Without A Fight"</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> &#123; singer, song &#125; = <span class="hljs-keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        지금 듣고 있는 노래는 &#123;singer&#125;의 &#123;song&#125;입니다.</span><br><span class="line">      &lt;<span class="hljs-regexp">/div&gt;</span></span><br><span class="line"><span class="hljs-regexp">    );</span></span><br><span class="line"><span class="hljs-regexp">  &#125;</span></span><br><span class="line"><span class="hljs-regexp">&#125;</span></span><br><span class="line"><span class="hljs-regexp"></span></span><br><span class="line"><span class="hljs-regexp">export default Child;</span></span><br></pre></td></tr></table></figure><p>propTypes, defaulProps를 클래스 내부에서 정의할 수도 있다. 이 문법을 사용하려면 transform-class-properties babel 플러그인이 필요한데 create-react-app으로 생성한 프로젝트는 기본적으로 적용되어 있기 때문에 따로 설정할 필요가 없다. </p><h3 id="typescript"><a href="#typescript" class="headerlink" title="typescript"></a>typescript</h3><p>typeScript를 사용하여 props에 타입을 줘보자. </p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;</span><br><span class="line"></span><br><span class="line">interface ChildProps &#123;</span><br><span class="line">  singer: string;</span><br><span class="line">  song: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface ChildState &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span>&lt;<span class="hljs-title">ChildProps</span>, <span class="hljs-title">ChildState</span>&gt; </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">static</span> defaultProps = &#123;</span><br><span class="line">    singer: <span class="hljs-string">"Hoobastank"</span>,</span><br><span class="line">    song: <span class="hljs-string">"Without A Fight"</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> &#123; singer, song &#125; = <span class="hljs-keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        지금 듣고 있는 노래는 &#123;singer&#125;의 &#123;song&#125;입니다.</span><br><span class="line">      &lt;<span class="hljs-regexp">/div&gt;</span></span><br><span class="line"><span class="hljs-regexp">    );</span></span><br><span class="line"><span class="hljs-regexp">  &#125;</span></span><br><span class="line"><span class="hljs-regexp">&#125;</span></span><br><span class="line"><span class="hljs-regexp"></span></span><br><span class="line"><span class="hljs-regexp">export default Child;</span></span><br></pre></td></tr></table></figure><p><img src="/images/frontend/reactjs-props-6.png" alt="잘못된 타입을 지정했더니 렌더링 조차 되지 않고 오류를 출력한다."></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791160505238&orderClick=LAG&Kc=" target="_blank" rel="noopener">리액트를 다루는 기술</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;props&quot;&gt;&lt;a href=&quot;#props&quot; class=&quot;headerlink&quot; title=&quot;props&quot;&gt;&lt;/a&gt;props&lt;/h2&gt;&lt;p&gt;props는 Component 속성을 설정할 때 사용하는 요소이다. Component는 props를 받고
      
    
    </summary>
    
      <category term="Front-end" scheme="http://dev.kyoungah.com/categories/Front-end/"/>
    
      <category term="React.js" scheme="http://dev.kyoungah.com/categories/Front-end/React-js/"/>
    
    
      <category term="React.js" scheme="http://dev.kyoungah.com/tags/React-js/"/>
    
  </entry>
  
  <entry>
    <title>암호의 개념</title>
    <link href="http://dev.kyoungah.com/2019/04/21/2019-04-21-compouter-security-secret-code/"/>
    <id>http://dev.kyoungah.com/2019/04/21/2019-04-21-compouter-security-secret-code/</id>
    <published>2019-04-21T09:26:49.000Z</published>
    <updated>2019-04-25T05:59:19.491Z</updated>
    
    <content type="html"><![CDATA[<h2 id="암호의-정의"><a href="#암호의-정의" class="headerlink" title="암호의 정의"></a>암호의 정의</h2><ul><li><strong>암호</strong>: 두 사람이 안전하지 않은 채녈을 통하여 정보를 주고받더라도 제3자는 이 정보의 내용을 알 수 없도록 하는 것.<ul><li>안전하지 않은 채널: 이 채널을 통해 지나다니는 메시지를 누구든지 볼 수 있다는 의미.</li></ul></li><li><strong>암호문</strong>: 제3자가 보더라도 그 내용을 알 수 없도록 변환된 메시지.</li><li><strong>평문</strong>: 변환되기 전인 원래의 메시지.</li><li><strong>암호화</strong>: 평문을 암호문으로 변환하는 것.</li><li><strong>복호화</strong>: 암호문을 다시 평문으로 변환하는 것.</li></ul><p>결국 암호는 송신자와 수신자가 서로 약속한 방식을 이용하여 송신자는 평문을 암호화하여 암호문을 만들어 보내고 수신자는 암호문을 복호화하여 평문을 만듦으로써 서로 정보를 주고 받는 것. 여기서 약속한 방식이란 특정한 암호 알고리즘 및 특정한 키를 의미한다. 키는 암호화와 복호화를 위한 가장 중요한 열쇠로 제 3자에게 알려져서는 안된다. </p><p>암호는 정보보호 핵심 목표 중 기밀성을 보장하기 위한 필수적인 기술이다.</p><h2 id="암호의-역사"><a href="#암호의-역사" class="headerlink" title="암호의 역사"></a>암호의 역사</h2><p>처음에는 암호를 주로 군사와 정치적인 목적으로 사용했다.<br>최근에는 일상생활과도 깊게 관계를 맺고 있으며, 인터넷뱅킹에 사용되는 인증서, 보안 키패드, 소프트웨어의 시리얼 키뿐만 아니라 전자투표 등에서 점차 널리 쓰이고 있다.</p><p>컴퓨터와 통신이 결합함에 따라 불법 사용자의 봉쇄 또는 데이터의 위조 및 변조를 막는 수단으로도 이용되고 있다.</p><h3 id="고대-암호"><a href="#고대-암호" class="headerlink" title="고대 암호"></a>고대 암호</h3><p>최초의 암호는 기원전 480년에 스파르타에서 추방되어 페르시아에 살던 데마라토스가 페르시아의 침략계획 소식을 나무판에 조각하여 적은 후 밀랍을 발라 스파르타에 보낸 것.</p><ul><li><strong>스테가노그래피</strong>: 실제로 전달하고자 하는 정보 자체를 숨기는 것.</li><li>어떤 스테가노그래피 방식이 사용되었는지 알면 제 3자가 비교적 쉽게 숨겨진 정보를 찾을 수 있기 때문에 엄밀히 말하면 최초의 암호라고 하기는 힘듦.</li></ul><h4 id="전치법"><a href="#전치법" class="headerlink" title="전치법"></a>전치법</h4><ul><li>평문에 있는 문자들의 순서를 바꿈으로써 암호화 하는 기법.</li><li>암호화를 하는 쪽과 복호화를 하는 쪽이 미리 정해놓은 문자 배열규칙에 따라 암호화와 복호화를 수행하는 방식.</li><li>암호문에 사용되는 문자들은 평문에서 사용된 문자들이 그대로 이용되며 단지 위치만 바뀐다.</li></ul><p>ex)<br><img src="/images/base/compouter-security-secret-code-1.png" alt="스파르타의 봉 암호 (출처: 위키백과)"><br>컴퓨터보안재미있는과목입니다<del>! -&gt; 컴안는니퓨재과다터미목</del>보있입!</p><h4 id="치환법"><a href="#치환법" class="headerlink" title="치환법"></a>치환법</h4><p><img src="/images/base/compouter-security-secret-code-2.png" alt="치환법 (출처: 위키백과)"></p><ul><li>평문의 문자들을 다른 문자로 치환함으로써 암호화 하는 기법.</li><li>암호화를 하는 쪽과 복호화를 하는 쪽이 미리 정해 놓은 문자 치환규칙에 따라 암호화와 복호화를 수행하는 방식.</li><li>암호문에 사용되는 문자들은 평문에서 사용된 문자들과 달라지지만 대응되는 각 문자의 위치는 바뀌지 않는다.</li></ul><h4 id="시저암호"><a href="#시저암호" class="headerlink" title="시저암호"></a>시저암호</h4><p><img src="/images/base/compouter-security-secret-code-3.png" alt="시저암호 (출처: 위키백과)"></p><ul><li>알파벳 26글자를 알파벳 순서로 세 자씩 오른쪽으로 이동시킨 뒤, 해당되는 글자로 치환하여 암호화를 함.</li></ul><h4 id="시프트-암호"><a href="#시프트-암호" class="headerlink" title="시프트 암호"></a>시프트 암호</h4><ul><li>각 문자를 알파벳 순서로 k번째 뒤 문자로 치환하는 방법.</li><li>k는 0부터 25가지의 정수 중 하나가 됨. 암호화와 복호화를 하는 두 사람이 미리 k값을 약속해야 하며 이 k 값이 바로 키가 됨.</li></ul><h3 id="근대-암호"><a href="#근대-암호" class="headerlink" title="근대 암호"></a>근대 암호</h3><ul><li>16세기: 프랑스 외교관 비즈네르가 시프트 암호를 개선하여 새로운 비즈네르 암호라는 치환법을 고안함. 비즈네르 암호는 여러 개의 정수값을 키로 이용함.</li><li>20세기: 플레이페어 암호, 힐 암호 등 다양한 암호 방식이 등장함. 20세기 들어서는 통신기술의 발전과 기계식 계산기에 대한 연구를 바탕으로 두 차례의 세계 대전을 통해 암호 설계와 해독에 대한 필요성이 높아지면서 암호에 대한 연구가 더욱 활발하게 진행됨.</li><li>1949년: 섀년이 일회성 암호체계가 안전함을 증명했고 암호체계 설계의 두 가지 기본원칙인 혼돈과 확산 이론을 제시함.<ul><li>혼돈은 평문과 암호문사이의 상관관계를 숨김.</li><li>확산은 평문의 통계적 성격을 암호문 전반에 확산시켜 숨기는 역할을 함.</li></ul></li></ul><h3 id="현대-암호"><a href="#현대-암호" class="headerlink" title="현대 암호"></a>현대 암호</h3><p>10970년대에 표준 암호 알고리즘과 공개 키 알고리즘의 등장으로 큰 변화가 일어남. </p><h3 id="표준-암호-알고리즘의-등장"><a href="#표준-암호-알고리즘의-등장" class="headerlink" title="표준 암호 알고리즘의 등장."></a>표준 암호 알고리즘의 등장.</h3><p>컴퓨터가 점차 발전하면서 데이터 보호에 대한 필요성도 증가하여 미국 NBS는 1977년 표준 암호 알고리즘으로 DES를 공표함.<br>DES는 대표적인 대칭키 알고리즘으로 2001년 새로운 표준 알고리즘인 AES가 공표될 떄까지 널리 이용됨.</p><h3 id="공개-키-알고리즘의-등장"><a href="#공개-키-알고리즘의-등장" class="headerlink" title="공개 키 알고리즘의 등장"></a>공개 키 알고리즘의 등장</h3><p>1076년 디피와 헬먼이 공개키 암호의 개념을 제시함.<br>공개키 암호는 암호화와 복호화에 다른 키를 사용함. 이 개념을 이용하여 1978년 리베스트, 샤미르, 애들먼은 소인수분해 문제에 기반을 둔 RSA 공개키 알고리즘을 개발함.</p><h2 id="대칭키"><a href="#대칭키" class="headerlink" title="대칭키"></a>대칭키</h2><ul><li>암호화와 복호화에 같은 키 하나를 사용하는 암호 방식.<ul><li>대칭키 암호는 평문을 암호화할 때 키 K를 이용하여 암호문을 만들었으면 나중에 복호화 할 때도 동일한 키 K를 이용해야만 원래의 평문을 만들 수 있다.</li><li><strong>비밀키</strong>: 대칭키 암호에서 사용하는 키.</li></ul></li><li>암호와와 복호와 속도가 빠르다.</li><li>비밀키를 제 3자에게 노출하지 않으면서 송신자와 수신자가 나누어 가지기 어렵다.</li><li><strong>블록 암호</strong>: 암호문을 만들기 위해 평문을 고정된 크기의 블록으로 나누어서 각 블록마다 암호화 과정을 수행하여 블록단위로 암호문을 얻는 대칭키 암호 방식.</li><li><strong>스트림 암호</strong>: 평문과 같은 길이의 키 스트림을 생성하여 평문과 키를 비트 단위로 XOR하여 암호문을 얻는 대칭키 암호 방식.</li><li>DES, AES, IDEA, SEED, CRYPTON, RC5, FEAL, MISTY, Skipjack, RC4 등의 대칭키 암호 알고리즘 들이 있다.</li></ul><h2 id="공개키"><a href="#공개키" class="headerlink" title="공개키"></a>공개키</h2><ul><li>암호화와 복호화에 두 개의 서로 다른 키를 사용하는 암호 방식.</li><li>공개키 암호는 평문을 암호화 할 때 K1을 이용하여 암호문을 만들면 나중에 복호화 할 때는 다른 키 K2를 이용해야만 원래의 평문을 만들 수 있다.</li><li><strong>공개키</strong>: 공개되어 있어서 누구나 공개키를 이용하여 암호화 할 수 있다.</li><li><strong>개인키</strong>: 아무에게도 공개하지 않고 자신만 알고 있어야 하며 오직 자신만 개인키를 이용하여 복호화 할 수 있다. </li><li>키관리가 쉽고 키 분배 문제도 해결하였다.</li><li>대칭키 암호에 비해 속도가 느리다.<ul><li>데이터를 암호화 할 때는 대칭키 암호방식을 많이 쓰며 이때 필요한 대칭키 암호의 비밀키를 교환할 때는 공개키 암호 방식을 쓴다.</li></ul></li><li>RSA 암호 알고리즘, EIGamal 암호 알고리즘, Rabin 암호 알고리즘, NTRU 암호 알고리즘 등의 공개키 암호 알고리즘 들이 있다.</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920020759&condLscValue=001&condYr=&condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 컴퓨터 보안 2강</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;암호의-정의&quot;&gt;&lt;a href=&quot;#암호의-정의&quot; class=&quot;headerlink&quot; title=&quot;암호의 정의&quot;&gt;&lt;/a&gt;암호의 정의&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;암호&lt;/strong&gt;: 두 사람이 안전하지 않은 채녈을 통하여 정보를 주
      
    
    </summary>
    
      <category term="Base" scheme="http://dev.kyoungah.com/categories/Base/"/>
    
      <category term="Computer security" scheme="http://dev.kyoungah.com/categories/Base/Computer-security/"/>
    
    
      <category term="Computer security" scheme="http://dev.kyoungah.com/tags/Computer-security/"/>
    
  </entry>
  
  <entry>
    <title>컴퓨터 보안 개념</title>
    <link href="http://dev.kyoungah.com/2019/04/07/2019-04-07-computer-security-first/"/>
    <id>http://dev.kyoungah.com/2019/04/07/2019-04-07-computer-security-first/</id>
    <published>2019-04-07T10:15:27.000Z</published>
    <updated>2019-04-25T05:59:19.490Z</updated>
    
    <content type="html"><![CDATA[<h2 id="컴퓨터-보안"><a href="#컴퓨터-보안" class="headerlink" title="컴퓨터 보안"></a>컴퓨터 보안</h2><p>다양한 형태의 정보 중 컴퓨팅 환경이 관여된 모든 상황에 대한 정보보호. </p><ul><li>정보보호: 저장되어 있거나 전달 중인 정보를 허락되지 않은 접근, 수정, 훼손, 유출 등의 위협으로부터 보호하기 위한 정책 및 기법. </li></ul><h2 id="컴퓨터-보안의-목표"><a href="#컴퓨터-보안의-목표" class="headerlink" title="컴퓨터 보안의 목표"></a>컴퓨터 보안의 목표</h2><p>기밀성, 무결성, 가용성이 컴퓨터 보안의 가장 중요한 목표 이다. </p><h3 id="기밀성"><a href="#기밀성" class="headerlink" title="기밀성"></a>기밀성</h3><p>허락되지 않은 자가 정보의 내용을 알 수 없도록 하는 것.<br>기밀성을 지키기 위해서는 허락되지 않은 자가 정보에 접근을 아예 못하도록 할 수도 있고, 정보에 접근하더라도 무의미한 내용만 보이도록 할 수 있다.</p><p>ex)<br>고객의 개인정보를 제 3자에게 알려지는 것을 방지하기 위해 보호하는 것.</p><h3 id="무결성"><a href="#무결성" class="headerlink" title="무결성"></a>무결성</h3><p>허락되지 않은 자가 정보를 함부로 수정할 수 없도록 하는 것.<br>만약 허락되지 않은 자에 의한 수정이 발생했다면 이를 확인할 수 있는것 역시 무결성을 지키는 방법이다.</p><p>ex)<br>데이터베이스에 고객의 정보가 저장되어 있다면 그 내용이 임의로 수정되지 않도록 보호하는 것.<br>고객 본인이 본인의 회원정보를 확인할 때 이 과정에서도 내용이 위변조 되지 않도록 보호하는 것.</p><h3 id="가용성"><a href="#가용성" class="headerlink" title="가용성"></a>가용성</h3><p>허락된 자가 정보에 접근하고자 할 때 이것이 방해받지 않도록 하는 것.<br>즉, 정보에 대한 접근권한이 있는 자는 필요할 때 언제든지 정보를 사용할 수 있어야 한다.<br>결국 가용성은 정해진 시간 내에 정보를 볼 수 있음을 보장한다. </p><p>ex)<br>고객이 회원정보를 수정하기 위해 회원정보를 확인하고자 할 때 즉시 조회가 가능하게 하는 것.</p><h3 id="그-외-목표들"><a href="#그-외-목표들" class="headerlink" title="그 외 목표들"></a>그 외 목표들</h3><p>부인방지, 인증, 접근제어 등이 있다.</p><h4 id="부인방지"><a href="#부인방지" class="headerlink" title="부인방지"></a>부인방지</h4><p>정보에 관여한 자가 이를 부인하지 못하도록 하는 것.</p><p>ex)<br>정보를 보낸 사람이 나중에 정보를 보냈다는 것을 부인하지 못하도록 하는 발신 부인방지.<br>정보를 받은 사람이 나중에 받지 않았다는 것을 부인하지 못하도록 하는 수신 부인방지.</p><h4 id="인증"><a href="#인증" class="headerlink" title="인증"></a>인증</h4><p>정보 또는 정보를 이용하는 사용자가 정말 주장하는 정보 또는 사용자가 맞는지 확인할 수 있고 신뢰할 수 있는 것.</p><h4 id="접근제어"><a href="#접근제어" class="headerlink" title="접근제어"></a>접근제어</h4><p>정보에 대해 허락한 접근만 허용하고 그 외의 접근은 허용하지 않는 것.<br>접근권한이 있는 자는 정보에 대한 접근을 허용하고 접근권한이 없는 자는 정보에 접근하지 못하게 하는 것이다. 이때 접근권한은 정보나 사용자에 따라 다양하게 부여될 수 있다.</p><h2 id="정보화-환경과-역기능"><a href="#정보화-환경과-역기능" class="headerlink" title="정보화 환경과 역기능"></a>정보화 환경과 역기능</h2><p>과거 정보통신기술이 미약하던 시대에는 정보의 전달이 대부분 인편에 의존하였기 때문에 정보의 전파가 굉장히 느렸다. 그러다가 통신회선이 깔리면서 전보나 전화를 통해 정보의 전파속도가 빨라졌고, 이제는 인터넷을 통해 지구 반대편에서 일어나는 일도 실시간으로 알 수 있을 만큼 정보는 빠르게 움직이고 있다. </p><p>이처럼 정보화 사회가 선진화 됨에 따라 악성 댓글, 스팸 메일, 개인정보 유출, 금전적인 목적을 대상으로 하는 피싱이나 파밍, 스미싱 등에 따른 개인적인 피해가 증가하고 있으며 불건전 정보 유통, 사생활 침해 등과 같은 부작용이 심각한 사회문제로 대두되고 있다. 이러한 문제점은 보이스 피싱, 문자 메시지나 인스턴트 메시지를 이용한 스미싱, 랜섬웨어 같은 새로운 수법이 등장하면서 대처를 더욱 어렵게 하고 있다.</p><p>주요 기반 시설이 점차 정보통신 네트워크에 의해 관리 및 통제 됨에 따라 정보통신 인프라의 위협이 주요 기반 시설의 위협으로까지 확장되고 있으며, 결국 이는 국가 안보적인 측면에서 위험이 될 수 있다.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920020759&condLscValue=001&condYr=&condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 컴퓨터 보안 1강</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;컴퓨터-보안&quot;&gt;&lt;a href=&quot;#컴퓨터-보안&quot; class=&quot;headerlink&quot; title=&quot;컴퓨터 보안&quot;&gt;&lt;/a&gt;컴퓨터 보안&lt;/h2&gt;&lt;p&gt;다양한 형태의 정보 중 컴퓨팅 환경이 관여된 모든 상황에 대한 정보보호. &lt;/p&gt;
&lt;ul&gt;
&lt;li
      
    
    </summary>
    
      <category term="Base" scheme="http://dev.kyoungah.com/categories/Base/"/>
    
      <category term="Computer security" scheme="http://dev.kyoungah.com/categories/Base/Computer-security/"/>
    
    
      <category term="Computer security" scheme="http://dev.kyoungah.com/tags/Computer-security/"/>
    
  </entry>
  
  <entry>
    <title>데이터 통신 시스템</title>
    <link href="http://dev.kyoungah.com/2019/03/24/2019-03-24-information-network-data-communication-system/"/>
    <id>http://dev.kyoungah.com/2019/03/24/2019-03-24-information-network-data-communication-system/</id>
    <published>2019-03-24T10:35:01.000Z</published>
    <updated>2019-04-25T05:59:19.490Z</updated>
    
    <content type="html"><![CDATA[<h2 id="데이터-통신-시스템"><a href="#데이터-통신-시스템" class="headerlink" title="데이터 통신 시스템"></a>데이터 통신 시스템</h2><p>원거리에 떨어져 있는 데이터 발생지와 목적지 사이에 정보를 신속하고 정확하게 전송하고 처리하기 위해 데이터 전송과 데이터 처리를 상호 유기적 으로 결합한 시스템.</p><h2 id="데이터-통신-시스템의-기능"><a href="#데이터-통신-시스템의-기능" class="headerlink" title="데이터 통신 시스템의 기능"></a>데이터 통신 시스템의 기능</h2><ul><li>전송 시스템 활용</li><li>접속</li><li>동기화</li><li>교환관리 </li><li>오류검출 및 정정</li><li>흐름제어</li><li>주소지정</li><li>라우팅</li><li>복구</li><li>메시지 형식화 </li><li>보호</li><li>시스템 관리</li></ul><h2 id="데이터-통신-시스템의-구성-요소"><a href="#데이터-통신-시스템의-구성-요소" class="headerlink" title="데이터 통신 시스템의 구성 요소"></a>데이터 통신 시스템의 구성 요소</h2><p><img src="/images/base/information-network-data-communication-system-1.png" alt="데이터 통신 시스템의 구성 요소"></p><h3 id="단말장치"><a href="#단말장치" class="headerlink" title="단말장치"></a>단말장치</h3><ul><li>데이터 통신 시스템에서 최종적으로 데이터를 송신하거나 수신하는 기능을 수행하는 장치.</li><li>단말기 또는 터미널이라고도 불린다.</li><li>키보드와 모니터, 프린터 등과 같이 컴퓨터와 연결되는 모든 주변장치를 의미한다.</li><li>입출력 기능, 기억 기능 및 전송제어 기능으로 구분된다.</li></ul><h4 id="입출력-기능"><a href="#입출력-기능" class="headerlink" title="입출력 기능"></a>입출력 기능</h4><p>외부로부터 정보를 받아들이고, 역으로 데이터 통신 시스템에서 처리한 결과를 외부에 출력한다.</p><h4 id="기억-기능"><a href="#기억-기능" class="headerlink" title="기억 기능"></a>기억 기능</h4><p>단말장치에 디스크나 소용량 기억장치를 부가하여 송,수신 데이터를 일시적으로 기억하거나 정보의 자체적이고 지역적인 처리를 수행한다.</p><h4 id="전송제어-기능"><a href="#전송제어-기능" class="headerlink" title="전송제어 기능"></a>전송제어 기능</h4><p>컴퓨터와 단말장치 간에 정확한 데이터의 송수신이 가능하도록 전송제어를 수행한다. </p><h3 id="데이터-전송회선"><a href="#데이터-전송회선" class="headerlink" title="데이터 전송회선"></a>데이터 전송회선</h3><ul><li>단말장치로부터 통신제어장치까지의 데이터 전송 경로.</li><li>신호변환장치와 통신회선으로 구분된다.</li></ul><h4 id="신호변환장치"><a href="#신호변환장치" class="headerlink" title="신호변환장치"></a>신호변환장치</h4><ul><li>송신측이 전송한 데이터는 신호변환장치를 통과하면서 전기적 신호로 변환된 후 통신회선을 통해 수신측 신호변환장치에 전달된다.</li><li>수신측 신호변환장치는 전기적 신호를 원래의 데이터로 변환하여 통신제어장치에 전달한다. </li><li>대표적인 신호변환장치는 변복조기와 디지털 서비스 유니트가 있다. </li></ul><h3 id="통신제어장치"><a href="#통신제어장치" class="headerlink" title="통신제어장치"></a>통신제어장치</h3><ul><li>컴퓨터와 신호변환장치 사이에 위치하며, 단말장치와의 통신에 있어 각종 제어 기능을 분담한다.</li><li>통신제어장치는 데이터 전송회선과의 전기적 접속을 이루며 문자의 조립, 분해 기능과 버퍼링, 오류검출, 오류제어용 확장 비트 부가, 전송 제어, 회선의 감지, 접속제어 기능을 갖는다.</li></ul><h3 id="컴퓨터"><a href="#컴퓨터" class="headerlink" title="컴퓨터"></a>컴퓨터</h3><p>컴퓨터의 중앙처리장치에는 통신제어 프로그램이 내장되어 있어 통신제어장치로부터 입력된 데이터를 처리하고, 데이터 통신 시스템 전체를 제어한다. </p><h2 id="통신-소프트웨어"><a href="#통신-소프트웨어" class="headerlink" title="통신 소프트웨어"></a>통신 소프트웨어</h2><p><img src="/images/base/information-network-data-communication-system-2.png" alt="통신 소프트웨어"></p><ul><li>데이터 전송회선과 통신제어장치를 이용하여 컴퓨터와 단말장치 사이에서 정보를 송수신하기 위한 프로그램.</li><li>주요 기능: 데이터 송수신, 통신 하드웨어의 제어, 이용자 접속의 제어</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920014864&condLscValue=001&condYr=&condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 정보통신망 1강</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;데이터-통신-시스템&quot;&gt;&lt;a href=&quot;#데이터-통신-시스템&quot; class=&quot;headerlink&quot; title=&quot;데이터 통신 시스템&quot;&gt;&lt;/a&gt;데이터 통신 시스템&lt;/h2&gt;&lt;p&gt;원거리에 떨어져 있는 데이터 발생지와 목적지 사이에 정보를 신속하고 
      
    
    </summary>
    
      <category term="Base" scheme="http://dev.kyoungah.com/categories/Base/"/>
    
      <category term="Information network" scheme="http://dev.kyoungah.com/categories/Base/Information-network/"/>
    
    
      <category term="Information network" scheme="http://dev.kyoungah.com/tags/Information-network/"/>
    
  </entry>
  
  <entry>
    <title>컴퓨터 통신망</title>
    <link href="http://dev.kyoungah.com/2019/03/24/2019-03-24-information-network-first/"/>
    <id>http://dev.kyoungah.com/2019/03/24/2019-03-24-information-network-first/</id>
    <published>2019-03-24T09:18:29.000Z</published>
    <updated>2019-04-25T05:59:19.490Z</updated>
    
    <content type="html"><![CDATA[<h2 id="컴퓨터-통신망의-출현"><a href="#컴퓨터-통신망의-출현" class="headerlink" title="컴퓨터 통신망의 출현"></a>컴퓨터 통신망의 출현</h2><p>지역적으로 떨어진 컴퓨터와 컴퓨터를 서로 통신망으로 연결시켜 컴퓨터 자원을 공유하려는 이유에서 컴퓨터 통신망이 출현하게 되었다.</p><h3 id="데이터-통신-기술"><a href="#데이터-통신-기술" class="headerlink" title="데이터 통신 기술"></a>데이터 통신 기술</h3><p>데이터 처리에 있어서 데이터 통신은 매우 중요한 역할을 한다. 통신망으로 서로 연결되어 있지 않은 컴퓨터, stand-alone 컴퓨터에서도 데이터 통신은 없어서는 안될 중요한 기능이다. </p><p>A컴퓨터와 B컴퓨터가 송•수신을 할 때 통신 시스템을 거쳐서 원하는 데이터의 송 • 수신이 가능하다. </p><h3 id="데이터-처리-기술"><a href="#데이터-처리-기술" class="headerlink" title="데이터 처리 기술"></a>데이터 처리 기술</h3><p>컴퓨터를 이용하는 데이터 처리 기술이 데이터 통신 분야에도 큰 영향을 미치고 있다.<br>현재의 디지털 신호 전송 방식은 컴퓨터를 활용함으로써 음성뿐만 아니라 문자 데이터, 화상 데이터 등도 모두 디지털화 하여 고품질의 데이터 전송이 가능하게 만들었다.</p><p>즉, 통신 기술이 아날로그 방식에서 디지털 방식으로 전이됨으로써 얻게 되는 많은 장점은 컴퓨터 시스템의 데이터 처리 기술 덕분이다. </p><h3 id="분산-시스템"><a href="#분산-시스템" class="headerlink" title="분산 시스템"></a>분산 시스템</h3><p>컴퓨터 자원을 공유하고 그들의 확장과 축소를 용이하도록 하며 오류에 대한 신뢰도를 높일 수 있도록 컴퓨터 자원을 분산시켜 작업을 처리하는 시스템.</p><ul><li>여러군데다가 자원을 분산시켜 놓음으로써 한쪽에서 고장이 나도 다른쪽에서 데이터를 가져올 수 있기 때문에 오류에 대한 신뢰도가 높아짐. </li></ul><h4 id="강연결-분산-시스템"><a href="#강연결-분산-시스템" class="headerlink" title="강연결 분산 시스템"></a>강연결 분산 시스템</h4><p>분산된 거리가 짧고 처리기 사이의 상호 작용이 많은 분산 시스템.</p><p>ex) 자료흐름기계, 멀티프로세서</p><h4 id="약연결-분산-시스템"><a href="#약연결-분산-시스템" class="headerlink" title="약연결 분산 시스템"></a>약연결 분산 시스템</h4><p>분산된 거리가 비교적 길고 처리기 사이의 상호 작용이 비교적 적은 분산 시스템.</p><p>ex) 근거리 통신망(LAN), 원거리 통신망(WAN), 도시권 통신망(MAN).</p><h2 id="컴퓨터-통신망의-정의-및-구성-요소"><a href="#컴퓨터-통신망의-정의-및-구성-요소" class="headerlink" title="컴퓨터 통신망의 정의 및 구성 요소"></a>컴퓨터 통신망의 정의 및 구성 요소</h2><ul><li><strong>통신</strong> 넓은 의미로는 ‘거리상 서로 떨어진 사람 또는 장치들 사이에 여러 종류의 매개체를 이용하여 정보를 전달하는 활동’을 뜻하며 좁은 의미로는 ‘원격통신’을 뜻한다.<ul><li><strong>원격통신</strong>: 전자적 신호나 전자기적 파장을 이용하여 정보를 전송하는 것.</li></ul></li><li><strong>데이터 통신</strong>: 컴퓨터 시스템에 의한 데이터를 처리하는 기술과 데이터를 전송하는 기술이 결합된 것.</li><li><strong>데이터 통신망</strong>: 데이터 통신 기술과 망 기술이 융합된 개념.</li><li><strong>컴퓨터 통신망(컴퓨터 망)</strong>: 자원과 정보를 공유할 수 있게 해 주기 위해 통신 채널들로 상호 연결된 컴퓨터들과 기타 하드웨어 및 소프트웨어 구성 요소들의 집합체. 서버, 클라이언트, 전송 매체, 네트워킹 장치, 프로토콜, 애플리케이션 등의 구성 요소로 이루어진다.<ul><li><strong>서버</strong>: 컴퓨터 서비스에서 특정 서비스를 제공해 주는 컴퓨터.</li><li><strong>클라이언트</strong>: 서비스를 받고자 하는 컴퓨터 또는 단말.</li><li><strong>전송 매체</strong>: 컴퓨터 통신망에서 서버 및 클라이언트를 상호연결 시키고 데이터 전송이 가능하도로고 하기 위해 사용되는 장비.</li><li><strong>네트워킹 장치</strong>: 서버와 클라이언트를 컴퓨터 통신망에 연결시키기 위해 필요한 연결 장치.</li><li><strong>프로토콜</strong>: 서버와 클라이언트가 통신하기 위해 미리 정해 놓은 규칙.</li><li><strong>애플리케이션</strong>: 컴퓨터 통신망을 통해 서버가 클라이언트에게 제공하는 서비스 또는 그것을 위한 프로그램.</li></ul></li></ul><h2 id="컴퓨터-통신망의-서비스"><a href="#컴퓨터-통신망의-서비스" class="headerlink" title="컴퓨터 통신망의 서비스"></a>컴퓨터 통신망의 서비스</h2><ul><li>e-mail</li><li>파일 전송</li><li>원격 처리 </li><li>원격 회의</li><li>분산 데이터베이스 시스템</li><li>Web Service </li><li>Social Network Service</li></ul><p>그외 등등…</p><h2 id="컴퓨터-통신망의-역사"><a href="#컴퓨터-통신망의-역사" class="headerlink" title="컴퓨터 통신망의 역사"></a>컴퓨터 통신망의 역사</h2><ul><li><strong>SAGE(Semi-Automatic Ground Environment) 시스템</strong>: 1958년 미국에서 군사 목적으로 개발된 컴퓨터와 통신을 결합시킨 최초의 컴퓨터 통신 시스템.</li><li><strong>SABRE(Semi-Automatic Business Research Environment) 시스템</strong>: 1961년에 발표된 여객기의 좌석 예약과 회사 업무를 종합적으로 처리하기 위한 상업적인 컴퓨터 통신 시스템.</li><li><strong>CTSS(Compatible Time Sharing System)</strong>: 다수 사용자의 공동 이용을 위해 미국의MIT 대학에서 개발한 시분할 시스템(time sharing system).</li><li><strong>ARPANET</strong>: 1969년 이후 가동되어 1990년까지 운영되었으며 인터넷의 전신이 된 컴퓨터 네트워크 시스템.</li><li><strong>ALOHA(Additive Links Online Hawaii Area) 시스템</strong>: 1968년 하와이 대학에서 실험적으로 시작한 무선 패킷 교환방식의 통신 시스템.</li><li><strong>SNA(System Network Architecture)</strong> : 1974년에 IBM에서 발표한 컴퓨터 간의 접속을 용이하게 하고, 이용 형태의 다양화·복잡화를 대체하기 위한 체계화된 네트워크 구조.</li></ul><h2 id="컴퓨터-통신망의-활용-목적"><a href="#컴퓨터-통신망의-활용-목적" class="headerlink" title="컴퓨터 통신망의 활용 목적"></a>컴퓨터 통신망의 활용 목적</h2><h3 id="자원의-공유"><a href="#자원의-공유" class="headerlink" title="자원의 공유"></a>자원의 공유</h3><p>컴퓨터 통신망이 구축되면 사용자 또는 컴퓨터의 지리적 위치에 관계 없이 컴퓨터 통신망에 연결된 사람이면 누구든지 컴퓨터 자원을 자유롭게 이용할 수 있다.</p><h3 id="신뢰도의-향상-및-안정성-보장"><a href="#신뢰도의-향상-및-안정성-보장" class="headerlink" title="신뢰도의 향상 및 안정성 보장"></a>신뢰도의 향상 및 안정성 보장</h3><p>컴퓨터 통신망이 구축되면 한대의 컴퓨터가 고장나더라도 복구될 때까지 다른 컴퓨터를 사용할 수 있으므로 신뢰도및 안정성이 향상된다. </p><h3 id="처리-기능의-분산"><a href="#처리-기능의-분산" class="headerlink" title="처리 기능의 분산"></a>처리 기능의 분산</h3><p>컴퓨터 통신망이 구축되면 처리 기능을 지역적으로 분산시킴으로써 전체 시스템의 처리 능력을 향상시킬 수 있다. </p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920014864&condLscValue=001&condYr=&condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 정보통신망 1강</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;컴퓨터-통신망의-출현&quot;&gt;&lt;a href=&quot;#컴퓨터-통신망의-출현&quot; class=&quot;headerlink&quot; title=&quot;컴퓨터 통신망의 출현&quot;&gt;&lt;/a&gt;컴퓨터 통신망의 출현&lt;/h2&gt;&lt;p&gt;지역적으로 떨어진 컴퓨터와 컴퓨터를 서로 통신망으로 연결시켜 
      
    
    </summary>
    
      <category term="Base" scheme="http://dev.kyoungah.com/categories/Base/"/>
    
      <category term="Information network" scheme="http://dev.kyoungah.com/categories/Base/Information-network/"/>
    
    
      <category term="Information network" scheme="http://dev.kyoungah.com/tags/Information-network/"/>
    
  </entry>
  
  <entry>
    <title>소프트웨어 위기 현상 및 소프트웨어 공학</title>
    <link href="http://dev.kyoungah.com/2019/03/23/2019-03-23-software-engineering-crisis-engineering/"/>
    <id>http://dev.kyoungah.com/2019/03/23/2019-03-23-software-engineering-crisis-engineering/</id>
    <published>2019-03-23T09:13:28.000Z</published>
    <updated>2019-04-25T05:59:19.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="소프트웨어-위기-현상"><a href="#소프트웨어-위기-현상" class="headerlink" title="소프트웨어 위기 현상"></a>소프트웨어 위기 현상</h2><p>급격한 컴퓨터 하드웨어 기술의 발전으로 인해 사용자의 요구사항이 다양해지면서 해결해야 할 문제는 복잡해졌으나 상대적으로 소프트웨어 기술의 진보가 더딤을 일컫는 말.</p><ul><li>개발 일정이 계획보다 지연된다.</li><li>초과 비용이 발생한다.</li><li>제품의 신뢰도가 결여된다.</li><li>빈번하게 명세와 불일치하는 부분이 나타난다.</li><li>품질 저하와 유지보수의 어려움이 생긴다.</li></ul><h3 id="소프트웨어-위기-현상의-원인"><a href="#소프트웨어-위기-현상의-원인" class="headerlink" title="소프트웨어 위기 현상의 원인"></a>소프트웨어 위기 현상의 원인</h3><ul><li>소프트웨어 공학의 훈련을 받은 전문 인력의 부족.</li><li>소프트웨어에 관한 경영층의 인식 부족.</li><li>일관성 있는 방법론 및 지원 도구의 문제.</li><li>소프트웨어 개발 생산성 저하.</li><li>소프트웨어 자체의 복잡성 증가.</li></ul><h2 id="소프트웨어-공학"><a href="#소프트웨어-공학" class="headerlink" title="소프트웨어 공학"></a>소프트웨어 공학</h2><p>소프트웨어 위기 현상의 해결책으로 표현하기 위해 만들어진 용어.<br>고품질 소프트웨어의 경제적이고 빠른 생산과 유지보수를 위한 전문 작업과 연구 분야가 되었다. </p><ul><li>신롸성 있고 요구기능을 효율적으로 수행하는 소프트웨어를 경제적으로 생산하기 위해 건전한 공학적 원리와 방법을 만들고 사용하는 것.<ul><li>초기 NATO 컨퍼런스에서 바우어 교수가 제시한 정의</li></ul></li><li>소프트웨어의 개발, 운영, 유지보수에 체계적이고 숙달되고 정량화된 접근 방법을 적용하는 것. 즉 소프트웨어에 공학 기술을 적용하는 것 또는 이러한 접근 방법에 관한 연구 분야.<ul><li>IEEE 소프트웨어 공학 표준 용어집에 정의되어 있다. </li></ul></li><li>인간에게 유용한 소프트웨어 제품을 만드는 과정에 과학적 지식을 적용함으로써 실제적 문제의 비용 효율적 해결책을 다루는 일</li></ul><h2 id="소프트웨어-공학-환경"><a href="#소프트웨어-공학-환경" class="headerlink" title="소프트웨어 공학 환경"></a>소프트웨어 공학 환경</h2><p>소프트웨어 개발이 단순히 코드의 생성이 아님을 인식하고 문서화와 프로젝트 관리의 중요성이 인식되었다.<br>개발 과정 초기의 요구사항 명세화 작업에 많은 노력을 기울임으로써 오류를 줄이고 비용을 절약할 수 있다.<br>변경이나 재사용을 염두에 둔 작업 등이 품질, 비용 및 생산성을 향상시킬 수 있다. </p><p>이렇게 다양한 해결 방법들을 통합적으로 다루기 위해 등장한 것이 소프트웨어 공학환경이다.</p><p><img src="/images/base/software-engineering-crisis-engineering-1.png" alt="소프트웨어 공학 환경"></p><p>소프트웨어 공학 환경의 최하위층에 소프트웨어 공학 원리가 위치하고 그 위에 방법과 기술이 위치하며 그 위에 방법론이, 그리고 최상위층에 도구가 위치한다. 각 계층은 그 아래 게층에 기초를 두고 있으며, 아래 계층보다 변화 가능성이 높다. </p><h3 id="스포트웨어-공학-원리"><a href="#스포트웨어-공학-원리" class="headerlink" title="스포트웨어 공학 원리"></a>스포트웨어 공학 원리</h3><p>소프트웨어 프로세스와 제품의 바람직한 측변들을 기술하는 일반적이고 추상적인 설명이다.<br>추상화, 분할 정복, 계층적 조직의 원리 등이 이것에 해당한다. </p><h3 id="방법과-기술"><a href="#방법과-기술" class="headerlink" title="방법과 기술"></a>방법과 기술</h3><ul><li>방법: 행위를 통제하는 체계적이고 일반적인 가이드라인 또는 구조화된 접근 방법.<ul><li>소프트웨어 제품을 정의, 기술, 추상화, 수정, 정제 및 문서화하는 데 필요한 모든 행위들을 포함한다. </li></ul></li><li>기술: 방법에 비해 보다 기계적으로 적용되나 제한된 적용성을 가진다. </li></ul><h3 id="방법론과-도구"><a href="#방법론과-도구" class="headerlink" title="방법론과 도구"></a>방법론과 도구</h3><ul><li>방법론: 프로세스(what)과 방법(how)를 함께 기술하는 것.<ul><li>방법론의 목적은 문제 해결을 위해 사용되어야 할 방법들과 기술들을 지정함으로써 특정 방식의 해법을 권장하는 것이다. </li></ul></li><li>도구: 기술과 방법, 그리고 방법론들의 적용을 지원하기 위해 개발된다.<ul><li>도구를 사용하는 것을 자동화라고 하며 소프트웨어 제품 개발에 필요한 방법들을 구현하기 위해 컴퓨터를 활용하는 것을 말한다. </li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920004346&condLscValue=001&condYr=&condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 소프트웨어 공학 1강</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;소프트웨어-위기-현상&quot;&gt;&lt;a href=&quot;#소프트웨어-위기-현상&quot; class=&quot;headerlink&quot; title=&quot;소프트웨어 위기 현상&quot;&gt;&lt;/a&gt;소프트웨어 위기 현상&lt;/h2&gt;&lt;p&gt;급격한 컴퓨터 하드웨어 기술의 발전으로 인해 사용자의 요구사항
      
    
    </summary>
    
      <category term="Base" scheme="http://dev.kyoungah.com/categories/Base/"/>
    
      <category term="Software engineering" scheme="http://dev.kyoungah.com/categories/Base/Software-engineering/"/>
    
    
      <category term="Software engineering" scheme="http://dev.kyoungah.com/tags/Software-engineering/"/>
    
  </entry>
  
  <entry>
    <title>소프트웨어</title>
    <link href="http://dev.kyoungah.com/2019/03/23/2019-03-23-software-engineering-first/"/>
    <id>http://dev.kyoungah.com/2019/03/23/2019-03-23-software-engineering-first/</id>
    <published>2019-03-23T08:31:24.000Z</published>
    <updated>2019-04-25T05:59:19.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="소프트웨어"><a href="#소프트웨어" class="headerlink" title="소프트웨어"></a>소프트웨어</h2><p>컴퓨터 프로그램과 관련 데이터의 묶음.<br>포괄적 의미에서 소프트웨어란 소스 코드는 물론 모든 관련 문서까지 포함하는데 실행 파일, 설계 문서, 설치 파일, 시스템 메뉴얼과 설치 메뉴얼 및 사용자가 소프트웨어를 사용하는 데 도움을 주도록 작성된 사용자 메뉴얼 등을 포함한다. </p><p>국제전기전자공학회(IEEE)의 정의에 따르면 <code>소프트웨어는 컴퓨터 프로그램, 프로시저의 규칙, 관련된 문서와 데이터의 묶음</code>이다. </p><h2 id="소프트웨어의-중요성"><a href="#소프트웨어의-중요성" class="headerlink" title="소프트웨어의 중요성"></a>소프트웨어의 중요성</h2><ul><li>사업체의 의사결정을 지원하는 엔진이다.</li><li>현대적 과학 탐구와 공학적 문제 해결을 지원하는 기본 도구이다. </li><li>교통, 의료, 원거리 통신, 군사. 산업체 등에 사용되는 모든 종류의 컴퓨터 시스템에 내장되어 있다.</li></ul><p>이렇게 소프트웨어가 사회와 문화에 주는 영향력은 점점 커지고 있다.</p><h2 id="소프트웨어의-분류"><a href="#소프트웨어의-분류" class="headerlink" title="소프트웨어의 분류"></a>소프트웨어의 분류</h2><h3 id="기능적-측면"><a href="#기능적-측면" class="headerlink" title="기능적 측면"></a>기능적 측면</h3><h4 id="시스템-소프트웨어"><a href="#시스템-소프트웨어" class="headerlink" title="시스템 소프트웨어"></a>시스템 소프트웨어</h4><p>컴퓨터를 운영하기 위한 목적의 소프트웨어로 응용 소프트웨어를 실행시키기 위한 플랫폼을 제공한다.</p><p>ex) 운영체제, 장치 드라이버, 컴파일러, DBMS, 유틸리티 프로그램 등…</p><h4 id="응용-소프트웨어"><a href="#응용-소프트웨어" class="headerlink" title="응용 소프트웨어"></a>응용 소프트웨어</h4><p>사용자의 실제 업무를 수행하는 프로그램들로 특정 용도에 사용되도록 만들어진 것.</p><p>ex) 워드프로세서, 스프레드시트, 웹 브라우저, 그래픽처리 프로그램, 게임 프로그램 및 데이터베이스 관리 시스템 등…</p><h3 id="고객-측면"><a href="#고객-측면" class="headerlink" title="고객 측면"></a>고객 측면</h3><h4 id="일반-소프트웨어"><a href="#일반-소프트웨어" class="headerlink" title="일반 소프트웨어"></a>일반 소프트웨어</h4><p>요구사항이 매우 일반적이고 안정적이며, 소프트웨어 엔지니어가 사용 용도를 잘 알고 있는 경우에 불특정 다수를 대상으로 설게된 소프트웨어.<br>공개 시장에서 판매되며 다수의 경쟁 제품이 있을 수 있다.</p><p>ex) 데이터베이스 관련 제품, 워드프로세서, 사무용 소프트웨어 패키지, ERP/CRM 패키지, 운영체제 등…</p><h4 id="맞춤형-소프트웨어"><a href="#맞춤형-소프트웨어" class="headerlink" title="맞춤형 소프트웨어"></a>맞춤형 소프트웨어</h4><p>응용 도메인, 사용 환경 및 요구사항이 특별한 고객을 위해 개발되는 맞춤 소프트웨어.<br>특정 산업에서 나타나는 고유의 업무 프로세스를 위해 작성된다. </p><p>ex) 프로세스 제어 시스템, 교통 관제 시스템, 병원 관리 시스템 등…</p><h2 id="소프트웨어의-성질"><a href="#소프트웨어의-성질" class="headerlink" title="소프트웨어의 성질"></a>소프트웨어의 성질</h2><ul><li>소프트웨어는 무형의 인공물이머 물질적인 성질을 가지지 않는다.<ul><li>물질적인 성질을 가지는 하드웨어와는 그 특성이 다르다.</li></ul></li><li>대부분의 소프트웨어는 기존 컴포넌트들의 조립을 통해 만들어지지 않고 요구사항에 맞추어 새롭게 만들어진다.<ul><li>소프트웨어에 대한 요구사항이 매우 복잡하기 때문에 기존 컴폰넌트를 조립하여 새로운 요구사항을 만족시키기는 매우 어렵다.</li><li>최근에는 ‘CBD(Component Based Development) 분석 방법론’이라고 컴포넌트 기반의 개발 방법이 있긴 하다. </li></ul></li><li>설계 과정의 품질 보등 활동이 소프트웨어의 결정적인 요소가 된다. </li><li>소프트웨어 개발 비용의 대부분이 노동력에 투입된다.</li><li>소프트웨어는 상대적으로 변경이 용이하다. <ul><li>이것을 ‘소프트웨어의 유연성 또는 순응성’이라고 한다.</li></ul></li><li>소프트웨어는 마모디지 않는다. <ul><li>그러나 환경의 변화나 새로운 요구사항의 등장 또는 기대 수준의 향상으로 인해 폐기될 수 있다.</li></ul></li><li>소프트웨어 유지보수는 하드웨어와 달리 많은 경우에 설계의 변경이 요구 된다.</li></ul><h2 id="소프트웨어의-응용-분야"><a href="#소프트웨어의-응용-분야" class="headerlink" title="소프트웨어의 응용 분야"></a>소프트웨어의 응용 분야</h2><h3 id="시스템-소프트웨어-1"><a href="#시스템-소프트웨어-1" class="headerlink" title="시스템 소프트웨어"></a>시스템 소프트웨어</h3><p>다른 소프트웨어를 지원할 목적으로 시스템상에서 실행되는 프로그램.<br>시스템 소프트웨어가 존재하지 않는다면 컴퓨터 시스템은 작동될 수 없다.</p><h3 id="실시간-소프트웨어"><a href="#실시간-소프트웨어" class="headerlink" title="실시간 소프트웨어"></a>실시간 소프트웨어</h3><p>이벤트 발생과 처리가 실시간으로 이루어지는 시스템.</p><p>ex) 은행 업무 시스템, 좌석 예약 시스템 등…</p><h3 id="내장형-소프트웨어"><a href="#내장형-소프트웨어" class="headerlink" title="내장형 소프트웨어"></a>내장형 소프트웨어</h3><p>대형 시스템의 일부로 하드웨어에 내장되어 특정 조건하에서 고유의 기능을 수행하도록 작성된 소프트웨어.<br>자동차, 세탁기, 전자레인지, 주유기, 인공위성 및 많은 자동 제어 시스템에 내장된 소프트웨어.</p><h3 id="비즈니스-소프트웨어"><a href="#비즈니스-소프트웨어" class="headerlink" title="비즈니스 소프트웨어"></a>비즈니스 소프트웨어</h3><p>사업 목적의 업무를 처리하기 위해 설계된 소프트웨어.</p><p>ex) 회계 업무 패키지, 경영 정보 시스템, 급여 관리 패키지 및 재고 관리 목적의 소프트웨어 등…</p><h3 id="개인용-소프트웨어"><a href="#개인용-소프트웨어" class="headerlink" title="개인용 소프트웨어"></a>개인용 소프트웨어</h3><p>개인 사용자를 위한 소프트웨어.</p><p>ex) 워드 프로세서, 스프레드시트, 그래픽 프로그램, 멀티미디어, 오락 프로그램, 네트워크 유틸리티 등…</p><h3 id="인공지능-소프트웨어"><a href="#인공지능-소프트웨어" class="headerlink" title="인공지능 소프트웨어"></a>인공지능 소프트웨어</h3><p>단순한 수치게산이나 정형적인 프로시저를 사용하지 못하는 복잡한 문제를 해결하기 위한 소프트웨어.</p><p>ex) 로보틱스, 전문가 시스템, 화상/음성 인식, 인공 신경망, 정리 증명 등…</p><h3 id="웹-기반-소프트웨어"><a href="#웹-기반-소프트웨어" class="headerlink" title="웹 기반 소프트웨어"></a>웹 기반 소프트웨어</h3><p>웹 브라우저에서 표현되거나 실행되는 소프트웨어.</p><h3 id="공학용-과학용-소프트웨어"><a href="#공학용-과학용-소프트웨어" class="headerlink" title="공학용/과학용 소프트웨어"></a>공학용/과학용 소프트웨어</h3><p>공학이나 과학 분야의 특정 원리나 공식을 사용하여 해당 분야의 특정 기능을 수행하도록 설계된 소프트웨어.</p><h2 id="좋은-소프트웨어의-기준"><a href="#좋은-소프트웨어의-기준" class="headerlink" title="좋은 소프트웨어의 기준"></a>좋은 소프트웨어의 기준</h2><p>소프트웨어의 특성을 좌우하는 여러 품질 기준이 존재한다.<br>사용성이나 신뢰도와 같이 사용자가 인지할 수 있는 것을 ‘외부 품질’ 이라고 한다.<br>‘내부 품질’의 향상은 개발자가 외부 품질을 개선하는데 도움을 줄 수 있다. 잘 작성된 요구사항이나 설계 문서는 보통의 사용자가 볼 수는 없으나 대부분의 외부 품질 요소들을 개선할 때 반드시 필요한 것이다.</p><h3 id="소프트웨어의-신뢰도"><a href="#소프트웨어의-신뢰도" class="headerlink" title="소프트웨어의 신뢰도"></a>소프트웨어의 신뢰도</h3><p>사용자가 소프트웨어를 신뢰하는 정도를 의미한다.<br>오랜 시간 작동되며, 알려진 치명적 오류가 없으며, 오류발생 후에 무난히 복구되며, 강건하다는 의미를 포함한다.</p><p>일반적으로 행위 분석을 통한 통계값으로 신뢰도를 측정한다. 다른 방법으로는 고장 확률 또는 고장 빈도를 시간 함수로 정의하는 것이다.</p><p>소프트웨어는 시간에 지남에 따라 오류 발견 및 수정으로 고장 빈도는 꾸준히 감소되면서 안정 상태가 되고 폐기될 때까지 유지된다. 그러나 경우에 따라 소프트웨어 고장 함수가 욕조 곡선과 유사한 형태를 가지는 경우가 있다.</p><blockquote><p>욕조 곡선: 시스템 안전 공학 용어로써 고장률 유형을 설명하는데 이용된다.</p></blockquote><ul><li>소프트웨어 버그를 수정하거나 새로운 기능을 추가하면서 생기는 사이드 이펙트.</li><li>엔지니어가 예상하지 못했던 하드웨어나 운영체제를 변경하는 경우.</li><li>사용자가 소프트웨어에 익숙해지면서 적정 용량이나 성능을 초과하는 입력을 주어 소프트웨어가 스트레스를 받게 되고, 그때 충분히 테스트되지 못한 기능들이 사용되어 오류가 발생하기 때문.</li></ul><h3 id="소프트웨어의-정확성"><a href="#소프트웨어의-정확성" class="headerlink" title="소프트웨어의 정확성"></a>소프트웨어의 정확성</h3><p>명세서와 일치하게 작동하는 능력.<br>사용자의 요구를 만족시키는 능력.</p><p>소프트웨어의 행위가 요구사항에 비추어 아주 작은 차이가 있는 경우에 이것은 결함으로 간주되고 소프트웨어는 정확하지 못하다는 뜻이 된다. 그러나 이런 경우가 무조건 소프트웨어의 실제 고장으로 연결되지는 않고 따라서 신뢰도가 있다고 판단될 수 있다.</p><h3 id="소프트웨어의-성능"><a href="#소프트웨어의-성능" class="headerlink" title="소프트웨어의 성능"></a>소프트웨어의 성능</h3><p>지정된 시간 안에 컴퓨터 시스템에서 처리할 수 있는 작업량.<br>주어진 시간 동안에 보다 많은 작업을 수행할 수 있는 경우에 성능이 높다고 한다. </p><h3 id="소프트웨어의-사용성"><a href="#소프트웨어의-사용성" class="headerlink" title="소프트웨어의 사용성"></a>소프트웨어의 사용성</h3><p>시스템을 본래의 설계 목적에 따라 효율성 있게 사용할 수 있는 정도를 의미한다. </p><h3 id="소프트웨어의-상호운영성"><a href="#소프트웨어의-상호운영성" class="headerlink" title="소프트웨어의 상호운영성"></a>소프트웨어의 상호운영성</h3><p>소프트웨어 시스템이 다른 시스템과 공존하며 협력할 수 있는 능력을 의미한다.</p><h3 id="소프트웨어의-유지보수성"><a href="#소프트웨어의-유지보수성" class="headerlink" title="소프트웨어의 유지보수성"></a>소프트웨어의 유지보수성</h3><p>소프트웨어는 유연하기 때문에 변경되기 쉽다.<br>상대적으로 변경시키기 쉬운 소프트웨어가 유지보수성이 높다고 한다. </p><p>유지보수 작업은 새로운 기능 추가, 기존 기능의 개선, 환경의 변화에 따른 기존 기능의 수정, 그리고 존재하는 오류를 수정하는 경우로 나누어 생각할 수 있다.</p><h3 id="소프트웨어의-이식성"><a href="#소프트웨어의-이식성" class="headerlink" title="소프트웨어의 이식성"></a>소프트웨어의 이식성</h3><p>다른 환경에서 쉽게 동작이 가능하다면 소프트웨어의 이식성이 좋다고 한다.</p><p>소프트웨어에서 환경이란 소프트웨어가 탑재되는 하드웨어, 운영체제 또는 상호작용하는 다른 시스템을 말한다. </p><h3 id="소프트웨어의-검사성"><a href="#소프트웨어의-검사성" class="headerlink" title="소프트웨어의 검사성"></a>소프트웨어의 검사성</h3><p>다른 기술 품질 요소들을 포함하여 소프트웨어의 속성들을 쉽게 검사할 수 있는 경우에 검사성이 좋다고 한다.</p><p>검사성을 측정하는 손쉬운 방법 중 하나는 성능이나 정확성과 같은 품질 요소를 검사하기 위한 코드를 삽입하는 것이다.</p><h3 id="소프트웨어의-추적성"><a href="#소프트웨어의-추적성" class="headerlink" title="소프트웨어의 추적성"></a>소프트웨어의 추적성</h3><p>요구사항 변경을 처리하기 위해서는 특정 요구사항을 제안한 관련자와 제안 이유, 이것에 영향받는 다른 요구사항들, 그리고 어느 설계 문서와 어느 소스 코드에 반영되었는지 파악 할 수 있어야 한다. </p><ul><li>요구사항으로부터 요구사항을 제안한 관련자를 파악.</li><li>관련성이 있는 요구사항들을 파악.</li><li>요구사항으로부터 관련 설계 문서를 파악.</li><li>설계 문서로부터 관련 코드 조각을 파악.</li><li>요구사항으로부터 테스트 계획서를 파악.</li><li>테스트 계획서로부터 테스트 케이스를 파악.</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920004346&condLscValue=001&condYr=&condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 소프트웨어 공학 1강</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;소프트웨어&quot;&gt;&lt;a href=&quot;#소프트웨어&quot; class=&quot;headerlink&quot; title=&quot;소프트웨어&quot;&gt;&lt;/a&gt;소프트웨어&lt;/h2&gt;&lt;p&gt;컴퓨터 프로그램과 관련 데이터의 묶음.&lt;br&gt;포괄적 의미에서 소프트웨어란 소스 코드는 물론 모든 관련 문
      
    
    </summary>
    
      <category term="Base" scheme="http://dev.kyoungah.com/categories/Base/"/>
    
      <category term="Software engineering" scheme="http://dev.kyoungah.com/categories/Base/Software-engineering/"/>
    
    
      <category term="Software engineering" scheme="http://dev.kyoungah.com/tags/Software-engineering/"/>
    
  </entry>
  
  <entry>
    <title>합병정렬</title>
    <link href="http://dev.kyoungah.com/2019/03/18/2019-03-17-algorithms-merge-sort/"/>
    <id>http://dev.kyoungah.com/2019/03/18/2019-03-17-algorithms-merge-sort/</id>
    <published>2019-03-17T16:13:13.000Z</published>
    <updated>2019-04-25T05:59:19.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="합병정렬"><a href="#합병정렬" class="headerlink" title="합병정렬"></a>합병정렬</h2><p>배열을 동일한 크기의 두 개의 부분배열로 분할하고 각각의 부분 배열을 순환적으로 정렬한 후, 정렬된 두 부분배열을 합병하여 하나의 정렬된 배열을 만든다.</p><h3 id="분할"><a href="#분할" class="headerlink" title="분할"></a>분할</h3><p>입력의 크기가 n인 배열을 n/2개의 원소를 가진 두 부분배열로 분할한다.</p><h3 id="정복"><a href="#정복" class="headerlink" title="정복"></a>정복</h3><p>각각의 부분배열에 대해서 합병 정렬을 순환적으로 적용하여 각 부분배열을 정렬한다. </p><h3 id="결합"><a href="#결합" class="headerlink" title="결합"></a>결합</h3><p>정렬된 두 부분배열을 합병하여 하나의 정렬된 배열을 만든다.</p><p><img src="/images/base/algorithms-merge-sort-1.png" alt="합병정렬"></p><h2 id="알고리즘"><a href="#알고리즘" class="headerlink" title="알고리즘"></a>알고리즘</h2><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> sorted[], <span class="hljs-keyword">int</span> leftIndex, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> rightIndex)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> l_hold = leftIndex, r_hold = mid + <span class="hljs-number">1</span>;</span><br><span class="line">  <span class="hljs-keyword">int</span> resultIndex = leftIndex; <span class="hljs-comment">// 결과 배열의 index</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">while</span>(l_hold &lt;= mid &amp;&amp; r_hold &lt;= rightIndex) &#123;</span><br><span class="line">    <span class="hljs-comment">// 부분배열 두개를 비교하여 작은 값을 선택한다.</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (arr[l_hold] &lt; arr[r_hold]) &#123;</span><br><span class="line">      sorted[resultIndex] = arr[l_hold];</span><br><span class="line"></span><br><span class="line">      l_hold++;</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      sorted[resultIndex] = arr[r_hold];</span><br><span class="line"></span><br><span class="line">      r_hold++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resultIndex++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 왼쪽 부분배열에 남아있는 모든 원소를 새로은 배열로 이동시킨다.</span></span><br><span class="line">  <span class="hljs-keyword">while</span> (l_hold &lt;= mid) &#123;</span><br><span class="line">    sorted[resultIndex] = arr[l_hold];</span><br><span class="line"></span><br><span class="line">    resultIndex ++;</span><br><span class="line">    l_hold ++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 오른쪽 부분배열에 남아있는 모든 원소를 새로은 배열로 이동시킨다.</span></span><br><span class="line">  <span class="hljs-keyword">while</span> (r_hold &lt;= rightIndex) &#123;</span><br><span class="line">    sorted[resultIndex] = arr[r_hold];</span><br><span class="line"></span><br><span class="line">    resultIndex ++;</span><br><span class="line">    r_hold ++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 원본 배열에 정렬된 배열을 이동 시킨다.</span></span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = leftIndex; i &lt;= rightIndex; i++) &#123;</span><br><span class="line">    arr[i] = sorted[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> sorted[], <span class="hljs-keyword">int</span> leftIndex, <span class="hljs-keyword">int</span> rightIndex)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (leftIndex &lt; rightIndex) &#123;</span><br><span class="line">    <span class="hljs-comment">// 각각 n/2크기를 가진 두 부분배열로 나누기 위해 가운데 값 정함.</span></span><br><span class="line">    <span class="hljs-keyword">int</span> mid = (leftIndex + rightIndex) / <span class="hljs-number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 왼쪽 부분배열의 순환호출</span></span><br><span class="line">    mergeSort(arr, sorted, leftIndex, mid);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 오른쪽 부분배열의 순환호출</span></span><br><span class="line">    mergeSort(arr, sorted, mid + <span class="hljs-number">1</span>, rightIndex);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 정렬된 두 부분배열의 합병</span></span><br><span class="line">    merge(arr, sorted, leftIndex, mid, rightIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="성능-분석"><a href="#성능-분석" class="headerlink" title="성능 분석"></a>성능 분석</h2><h3 id="합병-함수-수행-시간"><a href="#합병-함수-수행-시간" class="headerlink" title="합병 함수 수행 시간"></a>합병 함수 수행 시간</h3><p>합병 함수 수행 시간 = 부분배열[n/2] + 부분배열[n/2] = 배열[n]</p><p>두 부분 배열을 합병하면 최악의 경우 결과 배열엔 n + m개의 원소가 저장되는에 이때 최악의 경우  n + m - 1회의 비교가 필요하다. </p><ul><li>최소 비교횟수: $\frac{n}{2}$</li><li>최대 비교횟수: ($\frac{n}{2}$ + $\frac{n}{2}$ - 1) = n - 1;<br>=&gt; 입력 데이터 개수만큼의 저장 장소가 추가로 필요하다.</li></ul><p>결국 합병을 하는데 걸리는 시간은 입력 크기 n에 비례하므로 Θ(n)이 된다. </p><h3 id="합병-정렬-수행-시간"><a href="#합병-정렬-수행-시간" class="headerlink" title="합병 정렬 수행 시간"></a>합병 정렬 수행 시간</h3><p>합병 정렬 수행시간 = 크기 n/2인 두번의 합병 정렬 순환 호출 + 한번의 합병</p><p>T(1) = 1;<br>T(n) = T($\frac{n}{2}$) + T($\frac{n}{2}$) + Θ(n);</p><p>=&gt; T(n) = 2T($\frac{n}{2}$) + Θ(n)<br>=&gt; T(n) = O($n log n$)</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920026935&condLscValue=001&condYr=&condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 알고리즘 4강</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;합병정렬&quot;&gt;&lt;a href=&quot;#합병정렬&quot; class=&quot;headerlink&quot; title=&quot;합병정렬&quot;&gt;&lt;/a&gt;합병정렬&lt;/h2&gt;&lt;p&gt;배열을 동일한 크기의 두 개의 부분배열로 분할하고 각각의 부분 배열을 순환적으로 정렬한 후, 정렬된 두 부분배열
      
    
    </summary>
    
      <category term="Base" scheme="http://dev.kyoungah.com/categories/Base/"/>
    
      <category term="Algorithms" scheme="http://dev.kyoungah.com/categories/Base/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://dev.kyoungah.com/tags/Algorithms/"/>
    
  </entry>
  
</feed>
