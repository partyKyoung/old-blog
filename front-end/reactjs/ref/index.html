<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style id="GlobalStyle-649010835">
  html, body, 
  h1, h2, h3, h4, h5, h6,
  div, p, span,
  blockquote, applet, object, iframe,
  pre, a, 
  abbr, acronym, address,
  big, cite, code,
  del, dfn, em,
  font, img, 
  ins, kbd, q, s,
  samp, small,
  strike, strong,
  sub, sup, tt, var,
  dl, dt, dd,
  ol, ul, li,
  fieldset, form, label, legend,
  table, caption, tbody, tfoot, thead, tr, th, td {
    margin: 0;
    padding: 0;
  }
  body,
  input,
  textarea,
  select,
  button,
  table {
    line-height: 1.25em;
  }

  html {
    font-size: 16px;
  }

  html,
  body {
    height: 100%;
    padding: 0;
    margin: 0;
    color: #212121;
    box-sizing: border-box;
  }
 
  body {
    background-color: #adc2cb
  }

  img,
  fieldset {
    border: 0;
  }
  
  ul,
  ol {
    list-style: none;
  }

  em,
  address {
    font-style: normal;
  }

  a,
  a:hover,
  a:active,
  a:focus {
    color: #44b3f8;
    text-decoration: none;
    box-sizing: border-box;
  }

  
  #___gatsby {
    position: relative;
    min-height: 100%;
  }
</style><meta name="generator" content="Gatsby 2.13.8"/><title data-react-helmet="true"></title><link rel="shortcut icon" href="/icons/icon-48x48.png?v=008654519ce705ac7bc44303a9014606"/><link rel="manifest" href="/manifest.webmanifest"/><meta name="theme-color" content="#663399"/><link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png?v=008654519ce705ac7bc44303a9014606"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png?v=008654519ce705ac7bc44303a9014606"/><style data-styled="" data-styled-version="4.3.2"></style><link as="script" rel="preload" href="/component---src-templates-blog-template-tsx-062bd6b3a19c060efb50.js"/><link as="script" rel="preload" href="/app-8d7a0ef6b5a013ff390d.js"/><link as="script" rel="preload" href="/webpack-runtime-31bd00a1ff71f1cfd2f9.js"/><link as="fetch" rel="preload" href="/page-data/front-end/reactjs/ref/page-data.json" crossorigin="use-credentials"/></head><body><noscript id="gatsby-noscript">This app works best with JavaScript enabled.</noscript><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group" id="gatsby-focus-wrapper"><div class="blog-post-container"><div class="blog-post"><h1>ref</h1><h2>February 17, 2019</h2><div class="blog-post-content"><p>일반 HTML에서 DOM 요소에 이름을 달고 접근할 때 id를 사용한다.</p>
<pre><code class="language-html">&#x3C;!DOCTYPE html>
&#x3C;html lang="en">
  &#x3C;head>
    &#x3C;meta charset="utf-8" />
    &#x3C;title>DOM ID&#x3C;/title>
    &#x3C;link rel="stylesheet" type="text/css" href="./angry-heavy-rain.css" />
  &#x3C;/head>
  &#x3C;body>
    &#x3C;div id="me">DOM ID&#x3C;/div>
    &#x3C;button type="button" onclick="clickDOM()">클릭&#x3C;/button>
  &#x3C;/body>
  &#x3C;script>
    function clickDOM() {
      const me = document.getElementById("me")

      me.style.backgroundColor = "red"
    }
  &#x3C;/script>
&#x3C;/html>
</code></pre>
<iframe height="265" style="width: 100%;" scrolling="no" title="DOM Id" src="//codepen.io/partykyoung/embed/YBRmYx/?height=265&theme-id=0&default-tab=html,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/partykyoung/pen/YBRmYx/'>DOM Id</a> by partyKyoung
  (<a href='https://codepen.io/partykyoung'>@partykyoung</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>
<h2>ref</h2>
<p>HTML에서 id를 사용하여 DOM에 이름을 다는 것 처럼 리액트에서는 ref를 사용하여 DOM에 이름을 달 수 있다.</p>
<p>리액트에서도 id를 사용할 수 있지만 특수한 경우가 아니면 사용을 권장하지 않는다. DOM의 id는 유일해야 하는데 컴포넌트를 여러번 사용하면 중복 id를 가진 DOM이 여러개 생기게 되는 경우가 있기 때문이다. 이런 상황에서는 컴포넌트를 만들 때 마다 중복 id가 발생하는 것을 방지해야 한다.</p>
<p>ref는 전역적으로 작동하지 않고 컴포넌트 내부에서만 작동하기 때문에 이런 문제가 생기지 않는다.</p>
<h3>ref를 사용해야 할 때</h3>
<p>ref는 state나 props로 해결할 수 없고 DOM을 꼭 직접적으로 건드려야 할 때 사용한다.</p>
<ul>
<li>특정 input에 포커스 주기</li>
<li>스크롤 박스 조작하기</li>
<li>Canvas 요소에 그림 그리기 등</li>
</ul>
<h3>ref 사용법</h3>
<p>ref를 달아야 하는 DOM에 props를 설정하듯이 ref를 설정햐면 된다. ref 값으로는 콜백 함수를 전달한다. 콜백 함수는 ref를 파라미터로 가지며 콜백 함수 내부에서 컴포넌트의 맴버 변수에 ref를 담는 코드를 작성한다.
ref 이름은 자유롭게 지정할 수 있다.</p>
<pre><code class="language-javascript">import React, { Component } from "react"

export default class Ref extends Component {
  constructor() {
    super()

    this.input = null
  }

  handleFocus = () => {
    this.input.focus()
  }

  render() {
    return (
      &#x3C;div>
        &#x3C;input
          type="text"
          ref={input => {
            // this.input은 input 요소의 DOM을 가리킨다.
            this.input = input
          }}
        />
        &#x3C;button type="button" onClick={this.handleFocus}>
          클릭
        &#x3C;/button>
      &#x3C;/div>
    )
  }
}
</code></pre>
<iframe height="265" style="width: 100%;" scrolling="no" title="react ref" src="//codepen.io/partykyoung/embed/OdaKZw/?height=265&theme-id=0&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/partykyoung/pen/OdaKZw/'>react ref</a> by partyKyoung
  (<a href='https://codepen.io/partykyoung'>@partykyoung</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>
<h3>컴포넌트에 Ref 달기</h3>
<p>리액트에서는 컴포넌트에도 ref를 달 수 있다. 이 방법은 주로 컴포넌트 내부에 있는 DOM을 컴포넌트 외부에서 사용할 때 쓴다. 컴포넌트에 ref를 다는 방법은 DOM에 ref를 다는 방법과 똑같다.</p>
<h4>ChildRef.js</h4>
<pre><code class="language-javascript">import React, { Component } from "react"

export default class ChildRef extends Component {
  constructor() {
    super()

    this.box = null
  }

  handleScroll = () => {
    const { scrollHeight, clientHeight } = this.box

    this.box.scrollTop = scrollHeight - clientHeight
  }

  render() {
    const style = {
      border: "1px solid #000000",
      height: "300px",
      width: "300px",
      overflow: "scroll",
    }

    const innerStyle = {
      height: "600px",
      width: "100%",
      background: "linear-gradient(white, black)",
    }

    return (
      &#x3C;div
        style={style}
        ref={ref => {
          this.box = ref
        }}
      >
        &#x3C;div style={innerStyle} />
      &#x3C;/div>
    )
  }
}
</code></pre>
<h4>ParentRef.js</h4>
<pre><code class="language-javascript">import React, { Component } from "react"

import ChildRef from "./ChildRef"

export default class ParentRef extends Component {
  constructor() {
    super()

    this.scroll = null
  }

  handleClick = () => {
    /* 
      컴포넌트가 처음 랜더링 될 때는 this.scroll 값이 undefined 이므로 메서드를 호출 할 때 오류가 발생한다. 

      화살표 함수 문법을 사용하여 아예 새로운 함수를 만들고 그 내부에서 메서드를 실행하면 이미 한번 랜더링한 시점이므로 메서드 값을 읽어와서 실행하기 때문에 오류가 발생하지 않는다. 
    */

    this.scroll.handleScroll()
  }

  render() {
    return (
      &#x3C;div>
        &#x3C;ChildRef
          ref={ref => {
            this.scroll = ref
          }}
        />
        &#x3C;button type="button" onClick={this.handleClick}>
          맨 밑으로
        &#x3C;/button>
      &#x3C;/div>
    )
  }
}
</code></pre>
<iframe height="265" style="width: 100%;" scrolling="no" title="react component ref" src="//codepen.io/partykyoung/embed/yZGBjV/?height=265&theme-id=0&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/partykyoung/pen/yZGBjV/'>react component ref</a> by partyKyoung
  (<a href='https://codepen.io/partykyoung'>@partykyoung</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>
<h3>마무리</h3>
<p>컴포넌트 내부에서 DOM에 직접 접근해야 할 때는 ref를 사용한다. 먼저 ref를 사용하지 않고도 원하는 기능을 구현할 수 있는지 꼭 고려한 후 사용해야 한다.</p>
<p>서로 다른 컴포넌트끼리 데이터를 교류할 때 ref를 사용하는 것을 잘못된 방법이다. 할 수는 있지만 리액트 사상에 어긋난 설계이다. 앱 규모가 커지면 구조가 꼬여버려 유지보수가 불가능하기 때문이다. 컴포넌트끼리 데이터를 교류할 때는 언제나 부모 &#x3C;-> 자식 흐름으로 교류해야 한다.</p>
<h2>Reference</h2>
<p><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&#x26;mallGb=KOR&#x26;barcode=9791160505238&#x26;orderClick=LAG&#x26;Kc=">리액트를 다루는 기술</a>
<a href="https://reactjs.org/docs/refs-and-the-dom.html">Refs and the DOM</a></p></div></div></div></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/front-end/reactjs/ref";window.webpackCompilationHash="8785a6d9f464df12dbe0";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-8d7a0ef6b5a013ff390d.js"],"component---src-templates-blog-template-tsx":["/component---src-templates-blog-template-tsx-062bd6b3a19c060efb50.js"],"component---src-pages-about-tsx":["/component---src-pages-about-tsx-7c54ffd889e37f0717fa.js"],"component---src-pages-index-tsx":["/component---src-pages-index-tsx-a3e9b1ebb750c8ef67dc.js"]};/*]]>*/</script><script src="/webpack-runtime-31bd00a1ff71f1cfd2f9.js" async=""></script><script src="/app-8d7a0ef6b5a013ff390d.js" async=""></script><script src="/component---src-templates-blog-template-tsx-062bd6b3a19c060efb50.js" async=""></script></body></html>