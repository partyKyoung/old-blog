{"componentChunkName":"component---src-templates-blog-template-tsx","path":"/base/algorithms/fibonachi","webpackCompilationHash":"99047778a664d1d4dbd5","result":{"data":{"markdownRemark":{"html":"<h2>피보나치 수열</h2>\n<pre><code>f(0) = 0.\nf(1) = 1.\nf(n) = f(n - 1) + f(n -2), n >= 2.\n</code></pre>\n<p>피보나치 수열은 정의 자체가 최적성의 원리가 성립되는 점화식이므로 바로 동적 프로그래밍 방법을 적용할 수 있다.</p>\n<p>2 이상인 n에 대해 f(n)은 그 소문제의 해인 f(n - 1)과 f(n - 2)의 합으로 구성되므로 f(0)과 f(1)을 먼저 테이블에 저장한 후 n을 2로부터 1씩 증가시키며 해를 구한 뒤 테이블에 저장한다. n에 어떤 값이 있더라도 f(n)을 구할 시점에는 f(n - 1)과 f(n - 2)가 항상 테이블에 저장되어 있으므로 테이블을 이용하여 즉시 f(n)을 구할 수 있다.</p>\n<h2>알고리즘</h2>\n<pre><code class=\"language-c\">// 50 이상의 수열에서는 int형 범위를 초과하기 때문에 double을 반환형으로 사용하였다.\ndouble fibonachi (int num) {\n  double *fiboArr = (double *) malloc(sizeof(double) * num);\n\n  // f(0)과 f(1)을 테이블에 저장한다.\n  fiboArr[0] = 0;\n  fiboArr[1] = 1;\n\n  // i를 2부터 1씩 증가시키며 f(i)의 해를 테이블에 저장된 f(i - 1)과 f(i - 2)의 합으로 계산하여 다시 테이블에 저장한다.\n  for (int i = 2; i &#x3C;= num; i++) {\n    fiboArr[i] = fiboArr[i - 1] + fiboArr[i - 2];\n  }\n\n  return fiboArr[num];\n}\n</code></pre>\n<p>이렇게 하면 데이터를 저장하기 위해 필요한 테이블이 O(n) 에 비례해지는 단점이 있다.</p>\n<pre><code class=\"language-c\">double fibonachi (int num) {\n  if (num == 0) {\n    return 0;\n  }\n\n  if (num == 1) {\n    return 1;\n  }\n\n  return fibonachi(num - 1) + fibonachi(num - 2);\n}\n</code></pre>\n<p>재귀방식으로 구현할 수도 있으나 실행시간이 늘어난다는 단점이 있다.</p>\n<h2>성능 분석</h2>\n<p>동적 프로그래밍 방식으로 푸는 경우 알고리즘의 for 루프는 구하려는 피보나치 수열의 순번 n만큼 반복하므로 시간 복잡도는 O(n)이다.</p>\n<p>순환 호출 방식으로 푸는 경우 성능은 O($n^2$) 이다.</p>\n<h2>Reference</h2>\n<p><a href=\"http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920026935&#x26;condLscValue=001&#x26;condYr=&#x26;condSmst=\">방송대 컴퓨터과학과 알고리즘 5강</a></p>","frontmatter":{"date":"May 12, 2019","path":"/base/algorithms/fibonachi","title":"피보나치 수열"}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}