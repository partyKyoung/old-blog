{"componentChunkName":"component---src-templates-blog-template-tsx","path":"/base/algorithms/merge-sort","webpackCompilationHash":"f2d86240cf0952cf51aa","result":{"data":{"markdownRemark":{"html":"<h2>합병정렬</h2>\n<p>배열을 동일한 크기의 두 개의 부분배열로 분할하고 각각의 부분 배열을 순환적으로 정렬한 후, 정렬된 두 부분배열을 합병하여 하나의 정렬된 배열을 만든다.</p>\n<h3>분할</h3>\n<p>입력의 크기가 n인 배열을 n/2개의 원소를 가진 두 부분배열로 분할한다.</p>\n<h3>정복</h3>\n<p>각각의 부분배열에 대해서 합병 정렬을 순환적으로 적용하여 각 부분배열을 정렬한다.</p>\n<h3>결합</h3>\n<p>정렬된 두 부분배열을 합병하여 하나의 정렬된 배열을 만든다.</p>\n<p><img src=\"/images/base/algorithms-merge-sort-1.png\" alt=\"합병정렬\"></p>\n<h2>알고리즘</h2>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> sorted<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> leftIndex<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> mid<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> rightIndex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">int</span> l_hold <span class=\"token operator\">=</span> leftIndex<span class=\"token punctuation\">,</span> r_hold <span class=\"token operator\">=</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">int</span> resultIndex <span class=\"token operator\">=</span> leftIndex<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 결과 배열의 index</span>\n\n  <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>l_hold <span class=\"token operator\">&lt;=</span> mid <span class=\"token operator\">&amp;&amp;</span> r_hold <span class=\"token operator\">&lt;=</span> rightIndex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 부분배열 두개를 비교하여 작은 값을 선택한다.</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>l_hold<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> arr<span class=\"token punctuation\">[</span>r_hold<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      sorted<span class=\"token punctuation\">[</span>resultIndex<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>l_hold<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n      l_hold<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      sorted<span class=\"token punctuation\">[</span>resultIndex<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>r_hold<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n      r_hold<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    resultIndex<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// 왼쪽 부분배열에 남아있는 모든 원소를 새로은 배열로 이동시킨다.</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>l_hold <span class=\"token operator\">&lt;=</span> mid<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    sorted<span class=\"token punctuation\">[</span>resultIndex<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>l_hold<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    resultIndex <span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    l_hold <span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// 오른쪽 부분배열에 남아있는 모든 원소를 새로은 배열로 이동시킨다.</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>r_hold <span class=\"token operator\">&lt;=</span> rightIndex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    sorted<span class=\"token punctuation\">[</span>resultIndex<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>r_hold<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    resultIndex <span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    r_hold <span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n\n  <span class=\"token comment\">// 원본 배열에 정렬된 배열을 이동 시킨다.</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> leftIndex<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> rightIndex<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> sorted<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> mergeSort <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> sorted<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> leftIndex<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> rightIndex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>leftIndex <span class=\"token operator\">&lt;</span> rightIndex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 각각 n/2크기를 가진 두 부분배열로 나누기 위해 가운데 값 정함.</span>\n    <span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>leftIndex <span class=\"token operator\">+</span> rightIndex<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 왼쪽 부분배열의 순환호출</span>\n    <span class=\"token function\">mergeSort</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> sorted<span class=\"token punctuation\">,</span> leftIndex<span class=\"token punctuation\">,</span> mid<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 오른쪽 부분배열의 순환호출</span>\n    <span class=\"token function\">mergeSort</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> sorted<span class=\"token punctuation\">,</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> rightIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 정렬된 두 부분배열의 합병</span>\n    <span class=\"token function\">merge</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> sorted<span class=\"token punctuation\">,</span> leftIndex<span class=\"token punctuation\">,</span> mid<span class=\"token punctuation\">,</span> rightIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>성능 분석</h2>\n<h3>합병 함수 수행 시간</h3>\n<p>합병 함수 수행 시간 = 부분배열[n/2] + 부분배열[n/2] = 배열[n]</p>\n<p>두 부분 배열을 합병하면 최악의 경우 결과 배열엔 n + m개의 원소가 저장되는에 이때 최악의 경우 n + m - 1회의 비교가 필요하다.</p>\n<ul>\n<li>최소 비교횟수: $\\frac{n}{2}$</li>\n<li>최대 비교횟수: ($\\frac{n}{2}$ + $\\frac{n}{2}$ - 1) = n - 1;\n=> 입력 데이터 개수만큼의 저장 장소가 추가로 필요하다.</li>\n</ul>\n<p>결국 합병을 하는데 걸리는 시간은 입력 크기 n에 비례하므로 Θ(n)이 된다.</p>\n<h3>합병 정렬 수행 시간</h3>\n<p>합병 정렬 수행시간 = 크기 n/2인 두번의 합병 정렬 순환 호출 + 한번의 합병</p>\n<p>T(1) = 1;\nT(n) = T($\\frac{n}{2}$) + T($\\frac{n}{2}$) + Θ(n);</p>\n<p>=> T(n) = 2T($\\frac{n}{2}$) + Θ(n)\n=> T(n) = O($n log n$)</p>\n<h2>Reference</h2>\n<p><a href=\"http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920026935&#x26;condLscValue=001&#x26;condYr=&#x26;condSmst=\">방송대 컴퓨터과학과 알고리즘 4강</a></p>","frontmatter":{"date":"March 18, 2019","path":"/base/algorithms/merge-sort","title":"합병정렬"}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}