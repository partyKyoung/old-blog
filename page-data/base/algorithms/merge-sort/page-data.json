{"componentChunkName":"component---src-templates-blog-template-tsx","path":"/base/algorithms/merge-sort","webpackCompilationHash":"04b35bb1e7e18e473c98","result":{"data":{"markdownRemark":{"html":"<h2>합병정렬</h2>\n<p>배열을 동일한 크기의 두 개의 부분배열로 분할하고 각각의 부분 배열을 순환적으로 정렬한 후, 정렬된 두 부분배열을 합병하여 하나의 정렬된 배열을 만든다.</p>\n<h3>분할</h3>\n<p>입력의 크기가 n인 배열을 n/2개의 원소를 가진 두 부분배열로 분할한다.</p>\n<h3>정복</h3>\n<p>각각의 부분배열에 대해서 합병 정렬을 순환적으로 적용하여 각 부분배열을 정렬한다.</p>\n<h3>결합</h3>\n<p>정렬된 두 부분배열을 합병하여 하나의 정렬된 배열을 만든다.</p>\n<p><img src=\"/images/base/algorithms-merge-sort-1.png\" alt=\"합병정렬\"></p>\n<h2>알고리즘</h2>\n<pre><code class=\"language-c\">void merge(int arr[], int sorted[], int leftIndex, int mid, int rightIndex) {\n  int l_hold = leftIndex, r_hold = mid + 1;\n  int resultIndex = leftIndex; // 결과 배열의 index\n\n  while(l_hold &#x3C;= mid &#x26;&#x26; r_hold &#x3C;= rightIndex) {\n    // 부분배열 두개를 비교하여 작은 값을 선택한다.\n    if (arr[l_hold] &#x3C; arr[r_hold]) {\n      sorted[resultIndex] = arr[l_hold];\n\n      l_hold++;\n    } else {\n      sorted[resultIndex] = arr[r_hold];\n\n      r_hold++;\n    }\n\n    resultIndex++;\n  }\n\n  // 왼쪽 부분배열에 남아있는 모든 원소를 새로은 배열로 이동시킨다.\n  while (l_hold &#x3C;= mid) {\n    sorted[resultIndex] = arr[l_hold];\n\n    resultIndex ++;\n    l_hold ++;\n  }\n\n  // 오른쪽 부분배열에 남아있는 모든 원소를 새로은 배열로 이동시킨다.\n  while (r_hold &#x3C;= rightIndex) {\n    sorted[resultIndex] = arr[r_hold];\n\n    resultIndex ++;\n    r_hold ++;\n  }\n\n\n  // 원본 배열에 정렬된 배열을 이동 시킨다.\n  for (int i = leftIndex; i &#x3C;= rightIndex; i++) {\n    arr[i] = sorted[i];\n  }\n}\n\nvoid mergeSort (int arr[], int sorted[], int leftIndex, int rightIndex) {\n  if (leftIndex &#x3C; rightIndex) {\n    // 각각 n/2크기를 가진 두 부분배열로 나누기 위해 가운데 값 정함.\n    int mid = (leftIndex + rightIndex) / 2;\n\n    // 왼쪽 부분배열의 순환호출\n    mergeSort(arr, sorted, leftIndex, mid);\n\n    // 오른쪽 부분배열의 순환호출\n    mergeSort(arr, sorted, mid + 1, rightIndex);\n\n    // 정렬된 두 부분배열의 합병\n    merge(arr, sorted, leftIndex, mid, rightIndex);\n  }\n}\n</code></pre>\n<h2>성능 분석</h2>\n<h3>합병 함수 수행 시간</h3>\n<p>합병 함수 수행 시간 = 부분배열[n/2] + 부분배열[n/2] = 배열[n]</p>\n<p>두 부분 배열을 합병하면 최악의 경우 결과 배열엔 n + m개의 원소가 저장되는에 이때 최악의 경우 n + m - 1회의 비교가 필요하다.</p>\n<ul>\n<li>최소 비교횟수: $\\frac{n}{2}$</li>\n<li>최대 비교횟수: ($\\frac{n}{2}$ + $\\frac{n}{2}$ - 1) = n - 1;\n=> 입력 데이터 개수만큼의 저장 장소가 추가로 필요하다.</li>\n</ul>\n<p>결국 합병을 하는데 걸리는 시간은 입력 크기 n에 비례하므로 Θ(n)이 된다.</p>\n<h3>합병 정렬 수행 시간</h3>\n<p>합병 정렬 수행시간 = 크기 n/2인 두번의 합병 정렬 순환 호출 + 한번의 합병</p>\n<p>T(1) = 1;\nT(n) = T($\\frac{n}{2}$) + T($\\frac{n}{2}$) + Θ(n);</p>\n<p>=> T(n) = 2T($\\frac{n}{2}$) + Θ(n)\n=> T(n) = O($n log n$)</p>\n<h2>Reference</h2>\n<p><a href=\"http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920026935&#x26;condLscValue=001&#x26;condYr=&#x26;condSmst=\">방송대 컴퓨터과학과 알고리즘 4강</a></p>","frontmatter":{"date":"March 18, 2019","path":"/base/algorithms/merge-sort","title":"합병정렬"}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}