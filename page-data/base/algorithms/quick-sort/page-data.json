{"componentChunkName":"component---src-templates-blog-template-tsx","path":"/base/algorithms/quick-sort","webpackCompilationHash":"d66e1b8145158d6fc1c8","result":{"data":{"markdownRemark":{"html":"<h2>퀵 정렬</h2>\n<p>특정 원소를 기준으로 주어진 배열을 두 부분배열로 분할하고, 각 부분배열에 대해서 퀵 정렬을 순환적으로 적용하는 방식.\n특정 원소를 <strong>피벗</strong> 이라고 부름. 즉, 피벗이 제자리를 잡조록 하여 정렬하는 방식. 피벗의 왼쪽 부분배열엔 피벗보다 작은 값이, 오른쪽 부분배열엔 피벗보다 큰 값이 온다.</p>\n<ul>\n<li>피벗: 두 부분배열로 분할할 때 기준에 되는 특정 원소. 보통 주어진 배열의 첫 번째 원소로 지정한다.</li>\n</ul>\n<h3>분할</h3>\n<p>피벗을 기준으로 주어진 배열을 두 부분배열로 분할한다.</p>\n<h3>정복</h3>\n<p>두 부분배열에 대해서 퀵 정렬을 순환적으로 적용하여 각 부분배열을 정렬한다.</p>\n<h3>결합</h3>\n<p>필요 없음</p>\n<p><img src=\"/images/base/algorithms-quick-sort-1.png\" alt=\"퀵정렬\"></p>\n<h2>알고리즘</h2>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> temp <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    arr<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    arr<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 배열의 맨 오른쪽 index엔 무한대 값이 있다고 가정한다.</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">partition</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> leftIndex<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> rightIndex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token comment\">// 맨 왼쪽을 피벗으로 잡기 때문에 l_hold는 피벗의 위치 + 1, r_hold는 배열의 마지막 index</span>\n  <span class=\"token keyword\">int</span> pivot <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>leftIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> l_hold <span class=\"token operator\">=</span> leftIndex <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> r_hold <span class=\"token operator\">=</span> rightIndex<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>l_hold <span class=\"token operator\">&lt;=</span> r_hold<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// l_hold는 피벗보다 큰 값을 찾는다.</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>l_hold <span class=\"token operator\">&lt;=</span> rightIndex <span class=\"token operator\">&amp;&amp;</span> arr<span class=\"token punctuation\">[</span>l_hold<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> pivot<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      l_hold<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// r_hold는 피벗보다 작은 값을 찾는다.</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>r_hold <span class=\"token operator\">></span> leftIndex <span class=\"token operator\">&amp;&amp;</span> arr<span class=\"token punctuation\">[</span>r_hold<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> pivot<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      r_hold<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>l_hold <span class=\"token operator\">&lt;</span> r_hold<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// arr[l_hold]와 arr[r_hold]의 값을 교환한다.</span>\n      <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> l_hold<span class=\"token punctuation\">,</span> r_hold<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// 피벗과 arr[r_hold]값을 교환한다.</span>\n  <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> leftIndex<span class=\"token punctuation\">,</span> r_hold<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> r_hold<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">quickSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> leftIndex<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> rightIndex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>leftIndex <span class=\"token operator\">&lt;=</span> rightIndex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> pivot <span class=\"token operator\">=</span> <span class=\"token function\">partition</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> leftIndex<span class=\"token punctuation\">,</span> rightIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 두 부분배열로 분할</span>\n\n    <span class=\"token function\">quickSort</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> leftIndex<span class=\"token punctuation\">,</span> pivot <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 왼쪽 부분배열에 대해 순환호출</span>\n    <span class=\"token function\">quickSort</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> pivot <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> rightIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 오른쪽 부분배열에 대해서 순환호출</span>\n  <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>성능 분석</h2>\n<p>퀵 정렬 알고리즘은 한 번의 분할과 두 번의 순환 호출로 구성된다.</p>\n<h3>분할 함수 수행 시간</h3>\n<p>피벗을 제외한 배열의 원소들은 피벗과 최대 2번 비교 하게 된다. 전체적으로는 입력 크기 n에 비례하는 Θ(n) 시간이 걸린다.</p>\n<h3>퀵 정렬 수행 시간</h3>\n<p>퀵 정렬 수행 시간 = 한 번의 분할 + 두번의 킉정렬 순환 호출.\n배열 부분 시 두 부분배열의 크기가 다르기 때문에 배열이 어떤 크기의 두 부분배열로 분할되느냐에 따라 수행 시간이 다르다.</p>\n<h4>최악의 경우</h4>\n<p>극심한 불균형적 분할.</p>\n<ul>\n<li>피벗만 제자리를 잡고, 나머지 모든 원소가 하나의 부분배열로 분할되는 경우</li>\n<li>피벗이 항상 부분배열의 최솟값, 또는 최댓값이 되는 경우</li>\n<li>입력 데이터가 정렬되어 있고 피벗을 배열의 처음 원소로 지정한 경우</li>\n</ul>\n<p>T(n) = T(n-1) + T(0) + Θ(n) (n > 0) // 한쪽은 데이터가 없으므로 T(0)\nT(0) = 0</p>\n<p>=> T(n) = T(n - 1) + Θ(n)\n=> T(n) = O($n^2$)</p>\n<h3>최선의 경우</h3>\n<p>가장 균형적인 분할.</p>\n<ul>\n<li>피벗을 중심으로 항상 동일한 크기의 두 부분배열로 분할되는 경우</li>\n<li>피벗이 항상 부분배열의 중간값이 되는 경우</li>\n</ul>\n<p>T(n) = T($\\frac{n}{2}$) + T($\\frac{n}{2}$) + Θ(n) (n > 1)\nT(1) = 1</p>\n<p>=> T(n) = 2T($\\frac{n}{2}$) + Θ(n)\n=> T(n) = O($n log n$)</p>\n<h3>평균적인 경우</h3>\n<p>부분배열의 모든 분할 비율에 따른 수행 시간의 평균.</p>\n<ul>\n<li>피벗은 동일한 확률로서 분할 후 배열의 어느 곳에나 위치 가능</li>\n</ul>\n<p>T(1) = T(0) = 0\nT(n) = $\\frac{1}{n}\\sum_{i = 1}^{n}(T(i - 1) + T(n - i)) + O(n) (n >= 2)$</p>\n<p>=> T(n) = O($n log n$)</p>\n<h2>특징</h2>\n<ul>\n<li>최선/ 평균의 경우 O($n log n$)</li>\n<li>최악의 경우 O($n^2$)</li>\n</ul>\n<p>즉 피벗 선택의 임의성만 보장되면 평균적인 성능을 보일 가능성이 매우 높다. 그래서 배열에서 임의로 값을 선택해서 배열의 처음 원소와 서로 교환 후 정렬 수행하면 최악의 경우를 피할 가능성이 커진다.</p>\n<h2>Reference</h2>\n<p><a href=\"http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920026935&#x26;condLscValue=001&#x26;condYr=&#x26;condSmst=\">방송대 컴퓨터과학과 알고리즘 3강</a></p>","frontmatter":{"date":"March 17, 2019","path":"/base/algorithms/quick-sort","title":"퀵 정렬"}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}