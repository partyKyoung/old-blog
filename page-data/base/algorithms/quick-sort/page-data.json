{"componentChunkName":"component---src-templates-blog-template-tsx","path":"/base/algorithms/quick-sort","webpackCompilationHash":"8785a6d9f464df12dbe0","result":{"data":{"markdownRemark":{"html":"<h2>퀵 정렬</h2>\n<p>특정 원소를 기준으로 주어진 배열을 두 부분배열로 분할하고, 각 부분배열에 대해서 퀵 정렬을 순환적으로 적용하는 방식.\n특정 원소를 <strong>피벗</strong> 이라고 부름. 즉, 피벗이 제자리를 잡조록 하여 정렬하는 방식. 피벗의 왼쪽 부분배열엔 피벗보다 작은 값이, 오른쪽 부분배열엔 피벗보다 큰 값이 온다.</p>\n<ul>\n<li>피벗: 두 부분배열로 분할할 때 기준에 되는 특정 원소. 보통 주어진 배열의 첫 번째 원소로 지정한다.</li>\n</ul>\n<h3>분할</h3>\n<p>피벗을 기준으로 주어진 배열을 두 부분배열로 분할한다.</p>\n<h3>정복</h3>\n<p>두 부분배열에 대해서 퀵 정렬을 순환적으로 적용하여 각 부분배열을 정렬한다.</p>\n<h3>결합</h3>\n<p>필요 없음</p>\n<p><img src=\"/images/base/algorithms-quick-sort-1.png\" alt=\"퀵정렬\"></p>\n<h2>알고리즘</h2>\n<pre><code class=\"language-c\">void swap(int arr[], int a, int b)\n{\n    int temp = arr[a];\n    arr[a] = arr[b];\n    arr[b] = temp;\n}\n\n// 배열의 맨 오른쪽 index엔 무한대 값이 있다고 가정한다.\nint partition(int arr[], int leftIndex, int rightIndex) {\n// 맨 왼쪽을 피벗으로 잡기 때문에 l_hold는 피벗의 위치 + 1, r_hold는 배열의 마지막 index\n  int pivot = arr[leftIndex], l_hold = leftIndex + 1, r_hold = rightIndex;\n\n  while (l_hold &#x3C;= r_hold) {\n    // l_hold는 피벗보다 큰 값을 찾는다.\n    while (l_hold &#x3C;= rightIndex &#x26;&#x26; arr[l_hold] &#x3C; pivot) {\n      l_hold++;\n    }\n\n    // r_hold는 피벗보다 작은 값을 찾는다.\n    while (r_hold > leftIndex &#x26;&#x26; arr[r_hold] >= pivot) {\n      r_hold--;\n    }\n\n    if (l_hold &#x3C; r_hold) {\n      // arr[l_hold]와 arr[r_hold]의 값을 교환한다.\n      swap(arr, l_hold, r_hold);\n    }\n  }\n\n  // 피벗과 arr[r_hold]값을 교환한다.\n  swap(arr, leftIndex, r_hold);\n\n  return r_hold;\n}\n\nvoid quickSort(int arr[], int leftIndex, int rightIndex) {\n  if (leftIndex &#x3C;= rightIndex) {\n    int pivot = partition(arr, leftIndex, rightIndex); // 두 부분배열로 분할\n\n    quickSort(arr, leftIndex, pivot - 1);  // 왼쪽 부분배열에 대해 순환호출\n    quickSort(arr, pivot + 1, rightIndex); // 오른쪽 부분배열에 대해서 순환호출\n  }\n\n}\n</code></pre>\n<h2>성능 분석</h2>\n<p>퀵 정렬 알고리즘은 한 번의 분할과 두 번의 순환 호출로 구성된다.</p>\n<h3>분할 함수 수행 시간</h3>\n<p>피벗을 제외한 배열의 원소들은 피벗과 최대 2번 비교 하게 된다. 전체적으로는 입력 크기 n에 비례하는 Θ(n) 시간이 걸린다.</p>\n<h3>퀵 정렬 수행 시간</h3>\n<p>퀵 정렬 수행 시간 = 한 번의 분할 + 두번의 킉정렬 순환 호출.\n배열 부분 시 두 부분배열의 크기가 다르기 때문에 배열이 어떤 크기의 두 부분배열로 분할되느냐에 따라 수행 시간이 다르다.</p>\n<h4>최악의 경우</h4>\n<p>극심한 불균형적 분할.</p>\n<ul>\n<li>피벗만 제자리를 잡고, 나머지 모든 원소가 하나의 부분배열로 분할되는 경우</li>\n<li>피벗이 항상 부분배열의 최솟값, 또는 최댓값이 되는 경우</li>\n<li>입력 데이터가 정렬되어 있고 피벗을 배열의 처음 원소로 지정한 경우</li>\n</ul>\n<p>T(n) = T(n-1) + T(0) + Θ(n) (n > 0) // 한쪽은 데이터가 없으므로 T(0)\nT(0) = 0</p>\n<p>=> T(n) = T(n - 1) + Θ(n)\n=> T(n) = O($n^2$)</p>\n<h3>최선의 경우</h3>\n<p>가장 균형적인 분할.</p>\n<ul>\n<li>피벗을 중심으로 항상 동일한 크기의 두 부분배열로 분할되는 경우</li>\n<li>피벗이 항상 부분배열의 중간값이 되는 경우</li>\n</ul>\n<p>T(n) = T($\\frac{n}{2}$) + T($\\frac{n}{2}$) + Θ(n) (n > 1)\nT(1) = 1</p>\n<p>=> T(n) = 2T($\\frac{n}{2}$) + Θ(n)\n=> T(n) = O($n log n$)</p>\n<h3>평균적인 경우</h3>\n<p>부분배열의 모든 분할 비율에 따른 수행 시간의 평균.</p>\n<ul>\n<li>피벗은 동일한 확률로서 분할 후 배열의 어느 곳에나 위치 가능</li>\n</ul>\n<p>T(1) = T(0) = 0\nT(n) = $\\frac{1}{n}\\sum_{i = 1}^{n}(T(i - 1) + T(n - i)) + O(n) (n >= 2)$</p>\n<p>=> T(n) = O($n log n$)</p>\n<h2>특징</h2>\n<ul>\n<li>최선/ 평균의 경우 O($n log n$)</li>\n<li>최악의 경우 O($n^2$)</li>\n</ul>\n<p>즉 피벗 선택의 임의성만 보장되면 평균적인 성능을 보일 가능성이 매우 높다. 그래서 배열에서 임의로 값을 선택해서 배열의 처음 원소와 서로 교환 후 정렬 수행하면 최악의 경우를 피할 가능성이 커진다.</p>\n<h2>Reference</h2>\n<p><a href=\"http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920026935&#x26;condLscValue=001&#x26;condYr=&#x26;condSmst=\">방송대 컴퓨터과학과 알고리즘 3강</a></p>","frontmatter":{"date":"March 17, 2019","path":"/base/algorithms/quick-sort","title":"퀵 정렬"}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}