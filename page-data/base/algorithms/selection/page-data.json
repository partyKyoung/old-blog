{"componentChunkName":"component---src-templates-blog-template-tsx","path":"/base/algorithms/selection","webpackCompilationHash":"","result":{"data":{"markdownRemark":{"id":"21e57b59-7684-5d27-9910-f51d385f96a8","html":"<h2>선택 문제</h2>\n<p>n개의 원소가 임의의 순서로 저장된 배열에서 i번째로 작은 원소를 찾는 문제.</p>\n<ul>\n<li>i = 1 이면 최솟값.</li>\n<li>i = n/2 이면 중간값.</li>\n<li>i = n 이면 최댓값.</li>\n</ul>\n<p>직관적인 방법으로는 오름차순으로 정렬한 후 i 번째 원소를 찾으면 되는데 이떄 성능은 o(<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathdefault\">n</span></span></span></span>)이다.\n또 다른 직관적인 방법으로는 최솟값 찾는 과정을 i번 반복한다. i-1번째까지는 최솟값을 찾은 후 삭제한다. 이 경우에는 최솟값을 찾는데 걸리는 시간 O(n)을 i번 반복하기 때문에 성능은 O(in)이다.</p>\n<h2>최솟값 찾기</h2>\n<p>각 데이터를 하나씩 모드 비교한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">int</span> findMinimum <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">int</span> min <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> min<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      min <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> min<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>n개의 데이터에서 대해서 최소한 length - 1번의 비교가 필요하므로 성능은 O(n)이다.</p>\n<h2>최솟값과 최대값 모두 찾기.</h2>\n<p>최솟값과 최댓값을 모두 찾으려면 최솟값을 찾은 후에 최댓값을 찾거나 최댓값을 찾은 후 최솟값을 찾으면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">findMinMax</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">int</span> min <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">int</span> max <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// arr[0]과 arr[1]을 사용하여 최솟값/최댓값 초기화.</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>min <span class=\"token operator\">></span> max<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    max <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    min <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> length<span class=\"token punctuation\">;</span> i <span class=\"token operator\">+=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> small <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> large <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 두 데이터 중에서 작은 값과 큰 값을 결정.</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&lt;</span> length <span class=\"token operator\">&amp;&amp;</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;</span> length <span class=\"token operator\">&amp;&amp;</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> arr<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      small <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      large <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      small <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      large <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// 작은 값과 최솟 값을 비교.</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>small <span class=\"token operator\">&lt;</span> min<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      min <span class=\"token operator\">=</span> small<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// 큰 값과 최댓 값을 비교.</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>large <span class=\"token operator\">></span> max<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      max <span class=\"token operator\">=</span> large<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"최댓값: %d, 최솟값: %d\\n\"</span><span class=\"token punctuation\">,</span> max<span class=\"token punctuation\">,</span> min<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위의 알고리즘을 이용하면 <span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">3</span><span class=\"mord\">/</span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span>번의 비교를 통해서 최솟값과 최댓값을 동시에 찾을 수 있다.</p>\n<h3>i번째로 작은 원소 찾기: 최악 <span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, 평균 O(n)</h3>\n<p>퀵 정렬의 분할 함수 Partition()을 이용하면 모든 원소를 정렬하지 않고도 i번째로 작은 원소를 구할 수 있다.</p>\n<ul>\n<li>i = j 일때 피벗이 찾고자 하는 i 번째 원소.</li>\n<li>i &#x3C; j 일때 왼쪽 부분배열에 대해 순환 적용.</li>\n<li>i > j 일때 오른쪽 부분배열에 대해 순환 적용.</li>\n</ul>\n<h4>분할</h4>\n<p>피벗을 기준으로 주어진 배열을 두 부분배열로 분할한다. i가 피벗의 인덱스와 같으면 피벗의 값을 반환하고 종료한다.</p>\n<h4>정복</h4>\n<p>인덱스 i가 포함된 부분배열에 대해서 선택 알고리즘을 순환적으로 적용한다.</p>\n<h4>결합</h4>\n<p>필요 없다.</p>\n<h4>알고리즘</h4>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> temp <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    arr<span class=\"token punctuation\">[</span>a<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    arr<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 퀵정렬에 사용된 분할 함수를 그대로 사용하면 된다.</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">partition</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> leftIndex<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> rightIndex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token comment\">// 맨 왼쪽을 피벗으로 잡기 때문에 l_hold는 피벗의 위치 + 1, r_hold는 배열의 마지막 index</span>\n  <span class=\"token keyword\">int</span> pivot <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>leftIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> l_hold <span class=\"token operator\">=</span> leftIndex <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> r_hold <span class=\"token operator\">=</span> rightIndex<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>l_hold <span class=\"token operator\">&lt;=</span> r_hold<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// l_hold는 피벗보다 큰 값을 찾는다.</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>l_hold <span class=\"token operator\">&lt;=</span> rightIndex <span class=\"token operator\">&amp;&amp;</span> arr<span class=\"token punctuation\">[</span>l_hold<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> pivot<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      l_hold<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// r_hold는 피벗보다 작은 값을 찾는다.</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>r_hold <span class=\"token operator\">></span> leftIndex <span class=\"token operator\">&amp;&amp;</span> arr<span class=\"token punctuation\">[</span>r_hold<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> pivot<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      r_hold<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>l_hold <span class=\"token operator\">&lt;</span> r_hold<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// arr[l_hold]와 arr[r_hold]의 값을 교환한다.</span>\n      <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> l_hold<span class=\"token punctuation\">,</span> r_hold<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// 피벗과 arr[r_hold]값을 교환한다.</span>\n  <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> leftIndex<span class=\"token punctuation\">,</span> r_hold<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> r_hold<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">findNumber</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> leftIndex<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> rightIndex<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> findNum<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> pivot <span class=\"token operator\">=</span> <span class=\"token function\">partition</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> leftIndex<span class=\"token punctuation\">,</span> rightIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 두 부분배열로 분할</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>findNum <span class=\"token operator\">==</span> pivot<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">[</span>pivot<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>findNum <span class=\"token operator\">&lt;</span> leftIndex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 왼쪽 부분배열에 대해 순환호출</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">findNumber</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> leftIndex<span class=\"token punctuation\">,</span> pivot <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> findNum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 오른쪽 부분배열에 대해서 순환호출</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">findNumber</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> pivot <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> rightIndex<span class=\"token punctuation\">,</span> findNum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4>성능분석</h4>\n<p>최악의 경우 = 퀵 정렬의 최악의 경우</p>\n<ul>\n<li>분할 함수가 항상 하나의 부분배열만 생성하는 경우.</li>\n<li>\n<p>오름차순으로 정렬된 상태에서 i = n을 찾는 경우.</p>\n<ul>\n<li>분할 함수 호출할 떄 마다 피벗의 인덱스는 1씩 증가. -> Partition()을 O(n)번 호출. O(<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>).</li>\n<li>해결책은 항상 일정한 비율의 두 부분배열로 분할 시키면 된다.</li>\n</ul>\n</li>\n</ul>\n<p>평균적인 경우에는 O(n).</p>\n<h3>i번째로 작은 원소 찾기: 최악 O(n), 평균 O(n)</h3>\n<p>특정한 성질을 만족하도록 피벗을 선택하되 항상 일정한 비율의 두 부분배열로 분할 시킨다. 그러면 항상 하나의 부분배열만으로 분할되는 문제를 피하여 최악의 수행 시간 O(<span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>)를 개선할 수 있다.</p>\n<h4>피벗 선택 방법</h4>\n<ol>\n<li>크기가 n인 배열의 원소를 5개씩 묶어 <span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mord\">/</span><span class=\"mord\">5</span></span></span></span>개의 그룹을 형성한다. 이떄 n이 5의 배수가 되지 않아 그룹을 형성하지 못한 채 남은 원소들은 그대로 남겨둔다.</li>\n<li>각 그룹에 대해서 중간 값을 찾는다.</li>\n<li><span class=\"katex\"><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mord\">/</span><span class=\"mord\">5</span></span></span></span>개의 중간값들을 대상으로 다시 중간값을 찾는다.</li>\n<li>이렇게 계산된 '중간값들의 중간값'을 피벗으로 사용하여 주어진 배열을 분할한다.</li>\n</ol>\n<h4>알고리즘</h4>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// 삽입 정렬 함수</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">insertionSort</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> leftIndex<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> rightIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">int</span> i<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> leftIndex <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> rightIndex<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    key <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 현재 삽입될 숫자인 i번째 정수를 key 변수로 복사</span>\n\n    <span class=\"token comment\">// 현재 정렬된 배열은 i-1까지이므로 i-1번째부터 역순으로 조사한다.</span>\n    <span class=\"token comment\">// j 값은 음수가 아니어야 되고</span>\n    <span class=\"token comment\">// key 값보다 정렬된 배열에 있는 값이 크면 j번째를 j+1번째로 이동</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>j<span class=\"token operator\">=</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">>=</span><span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">></span>key<span class=\"token punctuation\">;</span> j<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      arr<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 레코드의 오른쪽으로 이동</span>\n    <span class=\"token punctuation\">}</span>\n\n    arr<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> key<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 분할 함수</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">partition</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> leftIndex<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> rightIndex<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> pivot<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">int</span> swapIndex <span class=\"token operator\">=</span> leftIndex<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> leftIndex<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> rightIndex<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> pivot<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">int</span> temp <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n      arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>swapIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      arr<span class=\"token punctuation\">[</span>swapIndex<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n\n      swapIndex <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> swapIndex <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> selection <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> leftIndex<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> rightIndex<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> findIndex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">int</span> arrLength <span class=\"token operator\">=</span> rightIndex <span class=\"token operator\">-</span> leftIndex <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">int</span> medianNum <span class=\"token operator\">=</span> arrLength <span class=\"token operator\">/</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0</span> <span class=\"token operator\">></span> findIndex <span class=\"token operator\">&amp;&amp;</span> findIndex <span class=\"token operator\">></span> arrLength<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// 배열의 길이가 5보다 같거나 작으면 findIndex - 1번째 원소를 찾아 봔한한다.</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arrLength <span class=\"token operator\">&lt;=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">insertionSort</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> leftIndex<span class=\"token punctuation\">,</span> rightIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">[</span>findIndex <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">int</span> <span class=\"token operator\">*</span>maidanArr <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> medianNum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 배열 arr에서 5개씩 원소를 묶어 n/5 개의 그룹을 만든 후 각 그룹에서 중간값을 구해 배열 maidanArr을 만든다.</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> medianNum<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    maidanArr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">selection</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> leftIndex <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token number\">5</span> <span class=\"token operator\">*</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>leftIndex <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token number\">5</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> leftIndex <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token number\">5</span> <span class=\"token operator\">*</span> i<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// 중간값들의 중간값을 계산하기 위해 선택 함수를 순환호출한다.</span>\n  <span class=\"token keyword\">int</span> pivot <span class=\"token operator\">=</span> <span class=\"token function\">selection</span><span class=\"token punctuation\">(</span>maidanArr<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> medianNum <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>medianNum <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// pivot을 사용하여 배열 arr을 분할한다.</span>\n  <span class=\"token keyword\">int</span> pivotIndex <span class=\"token operator\">=</span> <span class=\"token function\">partition</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> leftIndex<span class=\"token punctuation\">,</span> rightIndex<span class=\"token punctuation\">,</span> pivot<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">int</span> rank <span class=\"token operator\">=</span> pivotIndex <span class=\"token operator\">-</span> leftIndex <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>findIndex <span class=\"token operator\">&lt;=</span> rank<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">selection</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> leftIndex<span class=\"token punctuation\">,</span> pivotIndex<span class=\"token punctuation\">,</span> findIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">selection</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> pivotIndex <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> rightIndex<span class=\"token punctuation\">,</span> findIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Reference</h2>\n<ul>\n<li><a href=\"http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920026935&#x26;condLscValue=001&#x26;condYr=&#x26;condSmst=\">방송대 컴퓨터과학과 알고리즘 4강</a></li>\n<li><a href=\"https://ronniej.sfuh.tk/kth-largest-element-array/\">프로그래밍 면접 문제 10 : Kth Largest Element in Array</a></li>\n</ul>","frontmatter":{"date":"2019년 05월 10일","description":"n개의 원소가 임의의 순서로 저장된 배열에서 i번째로 작은 원소를 찾는 문제.","path":"/base/algorithms/selection","title":"선택 문제"}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}