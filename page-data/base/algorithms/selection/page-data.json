{"componentChunkName":"component---src-templates-blog-template-tsx","path":"/base/algorithms/selection","webpackCompilationHash":"8785a6d9f464df12dbe0","result":{"data":{"markdownRemark":{"html":"<h2>선택 문제</h2>\n<p>n개의 원소가 임의의 순서로 저장된 배열에서 i번째로 작은 원소를 찾는 문제.</p>\n<ul>\n<li>i = 1 이면 최솟값.</li>\n<li>i = n/2 이면 중간값.</li>\n<li>i = n 이면 최댓값.</li>\n</ul>\n<p>직관적인 방법으로는 오름차순으로 정렬한 후 i 번째 원소를 찾으면 되는데 이떄 성능은 o($n log n$)이다.\n또 다른 직관적인 방법으로는 최솟값 찾는 과정을 i번 반복한다. i-1번째까지는 최솟값을 찾은 후 삭제한다. 이 경우에는 최솟값을 찾는데 걸리는 시간 O(n)을 i번 반복하기 때문에 성능은 O(in)이다.</p>\n<h2>최솟값 찾기</h2>\n<p>각 데이터를 하나씩 모드 비교한다.</p>\n<pre><code class=\"language-c\">int findMinimum (int arr[], int length) {\n  int min = arr[0];\n\n  for (int i = 1; i &#x3C; length; i++) {\n    if (arr[i] &#x3C; min) {\n      min = arr[i];\n    }\n  }\n\n  return min;\n}\n</code></pre>\n<p>n개의 데이터에서 대해서 최소한 length - 1번의 비교가 필요하므로 성능은 O(n)이다.</p>\n<h2>최솟값과 최대값 모두 찾기.</h2>\n<p>최솟값과 최댓값을 모두 찾으려면 최솟값을 찾은 후에 최댓값을 찾거나 최댓값을 찾은 후 최솟값을 찾으면 된다.</p>\n<pre><code class=\"language-c\">void findMinMax(int arr[], int length) {\n  int min = arr[0];\n  int max = arr[1];\n\n  // arr[0]과 arr[1]을 사용하여 최솟값/최댓값 초기화.\n  if (min > max) {\n    max = arr[0];\n    min = arr[1];\n  }\n\n  for(int i = 2; i &#x3C; length; i += 2) {\n    int small = 0, large = 0;\n\n    // 두 데이터 중에서 작은 값과 큰 값을 결정.\n    if (i &#x3C; length &#x26;&#x26; i + 1 &#x3C; length &#x26;&#x26; arr[i] &#x3C; arr[i + 1]) {\n      small = arr[i];\n      large = arr[i + 1];\n    } else {\n      small = arr[i + 1];\n      large = arr[i];\n    }\n\n    // 작은 값과 최솟 값을 비교.\n    if (small &#x3C; min) {\n      min = small;\n    }\n\n    // 큰 값과 최댓 값을 비교.\n    if (large > max) {\n      max = large;\n    }\n  }\n\n  printf(\"최댓값: %d, 최솟값: %d\\n\", max, min);\n}\n</code></pre>\n<p>위의 알고리즘을 이용하면 $(3/2 * n) - 2$번의 비교를 통해서 최솟값과 최댓값을 동시에 찾을 수 있다.</p>\n<h3>i번째로 작은 원소 찾기: 최악 $O(n^2)$, 평균 O(n)</h3>\n<p>퀵 정렬의 분할 함수 Partition()을 이용하면 모든 원소를 정렬하지 않고도 i번째로 작은 원소를 구할 수 있다.</p>\n<ul>\n<li>i = j 일때 피벗이 찾고자 하는 i 번째 원소.</li>\n<li>i &#x3C; j 일때 왼쪽 부분배열에 대해 순환 적용.</li>\n<li>i > j 일때 오른쪽 부분배열에 대해 순환 적용.</li>\n</ul>\n<h4>분할</h4>\n<p>피벗을 기준으로 주어진 배열을 두 부분배열로 분할한다. i가 피벗의 인덱스와 같으면 피벗의 값을 반환하고 종료한다.</p>\n<h4>정복</h4>\n<p>인덱스 i가 포함된 부분배열에 대해서 선택 알고리즘을 순환적으로 적용한다.</p>\n<h4>결합</h4>\n<p>필요 없다.</p>\n<h4>알고리즘</h4>\n<pre><code class=\"language-c\">void swap(int arr[], int a, int b) {\n    int temp = arr[a];\n    arr[a] = arr[b];\n    arr[b] = temp;\n}\n\n// 퀵정렬에 사용된 분할 함수를 그대로 사용하면 된다.\nint partition(int arr[], int leftIndex, int rightIndex) {\n// 맨 왼쪽을 피벗으로 잡기 때문에 l_hold는 피벗의 위치 + 1, r_hold는 배열의 마지막 index\n  int pivot = arr[leftIndex], l_hold = leftIndex + 1, r_hold = rightIndex;\n\n  while (l_hold &#x3C;= r_hold) {\n    // l_hold는 피벗보다 큰 값을 찾는다.\n    while (l_hold &#x3C;= rightIndex &#x26;&#x26; arr[l_hold] &#x3C; pivot) {\n      l_hold++;\n    }\n\n    // r_hold는 피벗보다 작은 값을 찾는다.\n    while (r_hold > leftIndex &#x26;&#x26; arr[r_hold] >= pivot) {\n      r_hold--;\n    }\n\n    if (l_hold &#x3C; r_hold) {\n      // arr[l_hold]와 arr[r_hold]의 값을 교환한다.\n      swap(arr, l_hold, r_hold);\n    }\n  }\n\n  // 피벗과 arr[r_hold]값을 교환한다.\n  swap(arr, leftIndex, r_hold);\n\n  return r_hold;\n}\n\nint findNumber(int arr[], int leftIndex, int rightIndex, int findNum) {\n    int pivot = partition(arr, leftIndex, rightIndex); // 두 부분배열로 분할\n\n    if (findNum == pivot) {\n      return arr[pivot];\n    }\n\n    if (findNum &#x3C; leftIndex) {\n      // 왼쪽 부분배열에 대해 순환호출\n      return findNumber(arr, leftIndex, pivot - 1, findNum);\n\n    } else {\n      // 오른쪽 부분배열에 대해서 순환호출\n      return findNumber(arr, pivot + 1, rightIndex, findNum);\n    }\n}\n</code></pre>\n<h4>성능분석</h4>\n<p>최악의 경우 = 퀵 정렬의 최악의 경우</p>\n<ul>\n<li>분할 함수가 항상 하나의 부분배열만 생성하는 경우.</li>\n<li>\n<p>오름차순으로 정렬된 상태에서 i = n을 찾는 경우.</p>\n<ul>\n<li>분할 함수 호출할 떄 마다 피벗의 인덱스는 1씩 증가. -> Partition()을 O(n)번 호출. O($n^2$).</li>\n<li>해결책은 항상 일정한 비율의 두 부분배열로 분할 시키면 된다.</li>\n</ul>\n</li>\n</ul>\n<p>평균적인 경우에는 O(n).</p>\n<h3>i번째로 작은 원소 찾기: 최악 O(n), 평균 O(n)</h3>\n<p>특정한 성질을 만족하도록 피벗을 선택하되 항상 일정한 비율의 두 부분배열로 분할 시킨다. 그러면 항상 하나의 부분배열만으로 분할되는 문제를 피하여 최악의 수행 시간 O($n^2$)를 개선할 수 있다.</p>\n<h4>피벗 선택 방법</h4>\n<ol>\n<li>크기가 n인 배열의 원소를 5개씩 묶어 $n/5$개의 그룹을 형성한다. 이떄 n이 5의 배수가 되지 않아 그룹을 형성하지 못한 채 남은 원소들은 그대로 남겨둔다.</li>\n<li>각 그룹에 대해서 중간 값을 찾는다.</li>\n<li>$n/5$개의 중간값들을 대상으로 다시 중간값을 찾는다.</li>\n<li>이렇게 계산된 '중간값들의 중간값'을 피벗으로 사용하여 주어진 배열을 분할한다.</li>\n</ol>\n<h4>알고리즘</h4>\n<pre><code class=\"language-c\">// 삽입 정렬 함수\nvoid insertionSort(int arr[], int leftIndex, int rightIndex){\n  int i, j, key;\n\n  for(i = leftIndex + 1; i &#x3C;= rightIndex; i++){\n    key = arr[i]; // 현재 삽입될 숫자인 i번째 정수를 key 변수로 복사\n\n    // 현재 정렬된 배열은 i-1까지이므로 i-1번째부터 역순으로 조사한다.\n    // j 값은 음수가 아니어야 되고\n    // key 값보다 정렬된 배열에 있는 값이 크면 j번째를 j+1번째로 이동\n    for(j=i-1; j>=0 &#x26;&#x26; arr[j]>key; j--){\n      arr[j+1] = arr[j]; // 레코드의 오른쪽으로 이동\n    }\n\n    arr[j+1] = key;\n  }\n}\n\n// 분할 함수\nint partition(int arr[], int leftIndex, int rightIndex, int pivot) {\n  int swapIndex = leftIndex;\n\n  for (int i = leftIndex; i &#x3C;= rightIndex; i++) {\n    if (arr[i] &#x3C; pivot) {\n      int temp = arr[i];\n\n      arr[i] = arr[swapIndex];\n      arr[swapIndex] = temp;\n\n      swapIndex += 1;\n    }\n  }\n\n  return swapIndex - 1;\n}\n\nint selection (int arr[], int leftIndex, int rightIndex, int findIndex) {\n  int arrLength = rightIndex - leftIndex + 1;\n  int medianNum = arrLength / 5;\n\n  if (0 > findIndex &#x26;&#x26; findIndex > arrLength) {\n    return -1;\n  }\n\n  // 배열의 길이가 5보다 같거나 작으면 findIndex - 1번째 원소를 찾아 봔한한다.\n  if (arrLength &#x3C;= 5) {\n    insertionSort(arr, leftIndex, rightIndex);\n\n    return arr[findIndex - 1];\n  }\n\n  int *maidanArr = (int *) malloc(sizeof(int) * medianNum);\n\n  // 배열 arr에서 5개씩 원소를 묶어 n/5 개의 그룹을 만든 후 각 그룹에서 중간값을 구해 배열 maidanArr을 만든다.\n  for (int i = 0; i &#x3C; medianNum; i++) {\n    maidanArr[i] = selection(arr, leftIndex + (5 * i), (leftIndex + (5 * (i+1)-1)), leftIndex + (5 * i) + 2);\n  }\n\n  // 중간값들의 중간값을 계산하기 위해 선택 함수를 순환호출한다.\n  int pivot = selection(maidanArr, 0, medianNum - 1, (medianNum / 2) + 1);\n\n  // pivot을 사용하여 배열 arr을 분할한다.\n  int pivotIndex = partition(arr, leftIndex, rightIndex, pivot);\n  int rank = pivotIndex - leftIndex + 1;\n\n  if (findIndex &#x3C;= rank) {\n      return selection(arr, leftIndex, pivotIndex, findIndex);\n  } else {\n      return selection(arr, pivotIndex + 1, rightIndex, findIndex);\n  }\n}\n</code></pre>\n<h2>Reference</h2>\n<p><a href=\"http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920026935&#x26;condLscValue=001&#x26;condYr=&#x26;condSmst=\">방송대 컴퓨터과학과 알고리즘 4강</a>\n<a href=\"https://ronniej.sfuh.tk/kth-largest-element-array/\">프로그래밍 면접 문제 10 : Kth Largest Element in Array</a></p>","frontmatter":{"date":"May 10, 2019","path":"/base/algorithms/selection","title":"선택 문제"}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}