{"componentChunkName":"component---src-templates-blog-template-tsx","path":"/front-end/reactjs/map","webpackCompilationHash":"04b35bb1e7e18e473c98","result":{"data":{"markdownRemark":{"html":"<h2>arr.map(callback(currentValue[, index[, array]])[, thisArg])</h2>\n<p>JavaScript 배열 객체의 내장 함수 중 하나이다. 배열 내의 모든 요소 각각에 대하여 주어진 함수를 호출한 결과를 모아 새로운 배열을 반환한다. 원본 배열은 건드리지 않고 그 값들만을 사용해서 혹은 약간 변형해서 새로운 배열을 만들어야 할 때 유용하다.</p>\n<ul>\n<li>\n<p><strong>callback</strong>: 새로운 배열의 요소를 생성하는 콜백 함수.</p>\n<ul>\n<li><strong>currentValue</strong>: 현재 처리하고 있는 요소</li>\n<li><strong>index</strong>: 현재 처리하고 있는 요소의 index 값</li>\n<li><strong>array</strong>: 현재 처리하고 있는 배열의 원본</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/images/frontend/reactjs-map-1.png\" alt=\"arr.map 실행 결과\">;</p>\n<h2>Component map</h2>\n<p>array.map 메소드를 사용하여 기존 배열을 사용하여 컴포넌트로 구성된 배열을 생성할 수 있다.</p>\n<pre><code class=\"language-javascript\">import React, { Component } from \"react\"\n\nexport default class Map extends Component {\n  constructor() {\n    super()\n\n    this.fruitsList = [\"사과\", \"바나나\", \"오렌지\", \"체리\"]\n  }\n\n  render() {\n    return (\n      &#x3C;ul>\n        {this.fruitsList.map(fruits => {\n          // DOM을 사용해도 되고 컴포넌트를 사용해도 된다.\n          return &#x3C;li>{fruits}&#x3C;/li>\n        })}\n      &#x3C;/ul>\n    )\n  }\n}\n</code></pre>\n<iframe height=\"265\" style=\"width: 100%;\" scrolling=\"no\" title=\"oVvvga\" src=\"//codepen.io/partykyoung/embed/oVvvga/?height=265&theme-id=0&default-tab=js,result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href='https://codepen.io/partykyoung/pen/oVvvga/'>oVvvga</a> by partyKyoung\n  (<a href='https://codepen.io/partykyoung'>@partykyoung</a>) on <a href='https://codepen.io'>CodePen</a>.\n</iframe>\n<h3>key</h3>\n<p>리액트에서 key는 컴포넌트 배열을 렌더링 했을 때 어떤 원소에 변동이 있었는지 알아내려고 사용한다. key가 없으면 가상 DOM을 비교하는 과정에서 리스트를 순차적으로 비교하면서 변화를 감지하지만 key가 있으면 key 값을 사용하여 리스트에 어던 변화가 일어났는지 더욱 빠르게 알 수 있다.</p>\n<p><img src=\"/images/frontend/reactjs-map-2.png\" alt=\"key를 정해주지 않으면 실행 시 경고 메시지가 뜬다.\">;</p>\n<p>key 값을 설정할 때는 mpa 함수의 인자로 전달되는 함수 내부에서 컴포넌트 props를 설정하듯이 설정하면 된다. key 값은 언제나 유일해야 한다. key값이 중복된다면 렌더링 과정에서 오류가 발생한다.</p>\n<pre><code class=\"language-javascript\">// ... 생략\n\n  render() {\n    return (\n      &#x3C;ul>\n        {this.fruitsList.map((fruits, index) => {\n          return &#x3C;li key={index}>{fruits}&#x3C;/li>;\n        })}\n      &#x3C;/ul>\n    );\n  }\n\n// ... 생략\n</code></pre>\n<p>데이터가 가진 고윳값이 없으면 콜백함수의 인수인 index를 사용해도 괜찮으나 리액트 공식문서에서는 성능에 부정적인 영향을 줄 수 있으며 컴포넌트의 상태이슈를 유발하기 때문에 index를 key 값으로 쓰는것을 추천하지 않는다. 만약 key값을 명시하지 않은 경우에 리액트는 index값을 기본 값으로 할당하게 된다고 한다.</p>\n<h3>state 활용</h3>\n<p>state를 활용하면 유동적인 데이터를 렌더링 할 수 있다.</p>\n<p>상태 안에서 배열을 변형할 때 배열을 직접 접근하여 수정하면 자동으로 리렌더링을 트리거 하지 않는다. 다라서 concat, slice 같이 새로운 배열을 반환하는 함수들을 사용하여 새로운 배열을 만든 후 setState 메서드로 적용해야 한다.</p>\n<pre><code class=\"language-javascript\">import React, { Component } from \"react\"\n\ninterface Props {}\ninterface State {\n  fruitsList: string[];\n  value: string;\n}\n\nexport default class MapState extends Component&#x3C;Props, State> {\n  constructor(props: Props) {\n    super(props)\n\n    this.state = {\n      fruitsList: [],\n      value: \"\",\n    }\n  }\n\n  handleChange = (e: any): void => {\n    this.setState({\n      value: e.target.value,\n    })\n  }\n\n  handleInsert = (e: any): void => {\n    const { fruitsList, value } = this.state\n\n    if (e.keyCode !== 13) {\n      return\n    }\n\n    this.setState({\n      fruitsList: fruitsList.concat(value),\n      value: \"\",\n    })\n  }\n\n  handleDelete = (index: number): void => {\n    const { fruitsList } = this.state\n\n    this.setState({\n      fruitsList: [\n        ...fruitsList.slice(0, index),\n        ...fruitsList.slice(index + 1, fruitsList.length),\n      ],\n    })\n  }\n\n  render() {\n    const { fruitsList, value } = this.state\n\n    return (\n      &#x3C;div>\n        &#x3C;ul>\n          {fruitsList.map((fruits, index) => {\n            return (\n              &#x3C;li\n                key={index}\n                onClick={() => {\n                  this.handleDelete(index)\n                }}\n              >\n                {fruits}\n              &#x3C;/li>\n            )\n          })}\n        &#x3C;/ul>\n        &#x3C;input\n          type=\"text\"\n          value={value}\n          onChange={this.handleChange}\n          onKeyDown={this.handleInsert}\n        />\n      &#x3C;/div>\n    )\n  }\n}\n</code></pre>\n<iframe height=\"265\" style=\"width: 100%;\" scrolling=\"no\" title=\"react typescript map\" src=\"//codepen.io/partykyoung/embed/ZPzGdM/?height=265&theme-id=0&default-tab=js,result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href='https://codepen.io/partykyoung/pen/ZPzGdM/'>react typescript map</a> by partyKyoung\n  (<a href='https://codepen.io/partykyoung'>@partykyoung</a>) on <a href='https://codepen.io'>CodePen</a>.\n</iframe>\n<h2>Reference</h2>\n<p><a href=\"http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&#x26;mallGb=KOR&#x26;barcode=9791160505238&#x26;orderClick=LAG&#x26;Kc=\">리액트를 다루는 기술</a>\n<a href=\"https://reactjs.org/docs/lists-and-keys.html\">Lists and Keys</a>\n<a href=\"https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318\">Index as a key is an anti-pattern</a></p>","frontmatter":{"date":"February 25, 2019","path":"/front-end/reactjs/map","title":"Component 반복"}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}