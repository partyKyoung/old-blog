<!DOCTYPE html>
<html lang="ko">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
<title>태그: Algorithms - 경아&#39;s 개발일기</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



    <meta name="description" content="관심있는 기술들과 공부한 것들을 기록합니다. :)">
<meta property="og:type" content="website">
<meta property="og:title" content="경아&#39;s 개발일기">
<meta property="og:url" content="http://dev.kyoungah.com/tags/Algorithms/index.html">
<meta property="og:site_name" content="경아&#39;s 개발일기">
<meta property="og:description" content="관심있는 기술들과 공부한 것들을 기록합니다. :)">
<meta property="og:locale" content="ko">
<meta property="og:image" content="http://dev.kyoungah.com/images/og_image.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="경아&#39;s 개발일기">
<meta name="twitter:description" content="관심있는 기술들과 공부한 것들을 기록합니다. :)">
<meta name="twitter:image" content="http://dev.kyoungah.com/images/og_image.png">







<link rel="icon" href="/images/kyoungah-favicon.svg">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css">


    
    
    
    <style>body>.footer,body>.navbar,body>.section{opacity:0}</style>
    

    
    
    
    

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">


    
    
    
    

<link rel="stylesheet" href="/css/back-to-top.css">


    
    

    
    
    
    

    
    
<link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

    
    
    

    
    
    


<link rel="stylesheet" href="/css/style.css">
</head>
<body class="is-2-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/kyoungah.png" alt="경아&#39;s 개발일기" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item" href="/">Home</a>
                
                <a class="navbar-item" href="/archives">Archives</a>
                
                <a class="navbar-item" href="/categories">Categories</a>
                
                <a class="navbar-item" href="/tags">Tags</a>
                
                <a class="navbar-item" href="/about">About</a>
                
            </div>
            
            <div class="navbar-end">
                
                    
                    
                    <a class="navbar-item" target="_blank" title="Download on GitHub" href="http://github.com/partyKyoung">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                    
                
                
                
                <a class="navbar-item search" title="검색" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-8-widescreen has-order-2 column-main"><div class="card">
    <div class="card-content">
        <nav class="breadcrumb" aria-label="breadcrumbs">
        <ul>
            <li><a href="/tags">태그</a></li>
            <li class="is-active"><a href="#" aria-current="page">Algorithms</a></li>
        </ul>
        </nav>
    </div>
</div>

    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-05-12T14:30:07.000Z">2019-05-12</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Base/">Base</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Base/Algorithms/">Algorithms</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    9분 읽기 (나에 대하여 1308 단어)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/05/12/2019-03-17-algorithms-minMatMult/">연쇄 행렬 곱셈 문제</a>
            
        </h1>
        <div class="content">
            <h2 id="연쇄-행렬-곱셈-문제"><a href="#연쇄-행렬-곱셈-문제" class="headerlink" title="연쇄 행렬 곱셈 문제"></a>연쇄 행렬 곱셈 문제</h2><p>n개의 행렬을 연쇄적으로 곱할 때 최적의 곱셈 순서를 구하는 문제. 즉 최소의 기본 곱셈 횟수를 가진 행렬의 곱셈 순서를 구하는 문제이다.</p>
<p>i x j 행렬과 j x k 행렬을 곱하는데에는 i x j x k번만큼의 곱셈이 필요하고 그 결과로는 i x k 번의 행렬을 얻는다. 행렬의 곱셈 연산은 결합법칙이 성립하기 때문에 n개의 행렬을 연쇄적으로 곱하는 경우에는 곱하는 순서에 따라 여러 가지 다른 방법으로 계산될 수 있다. 즉 어떤 순서로 곱하느냐에 따라 곱셈 횟수가 달라질 수 있다.</p>
<p>M1: 30 x 5<br>M2: 5 x 20<br>M3: 20 x 15<br>M4: 15 x 10 </p>
<p>이렇게 행렬이 있다고 가정하면 </p>
<p>M1 (M2 (M3M4)) = (20 x 15 x 10) + (5 x 20 x 10) + (30 x 5 x 10) = 5,500<br>(M1M2)(M3M4) = (30 x 5 x 20) + (20 x 15 x 10) + (30 x 20 x 10) - 12,000<br>M1( (M2M3) M4) = (5 x 20 x 15) + (5 x 15 x 10 ) + (30 x 5 x 10) = 3,750<br>((M1M2) M3 )M4 = (30 x 5 x 20) + (30 x 20 x 15) + (30 x 15 x 10) = 16,500<br>(M1 (M2M3))M4 = (5 x 20 x 15) + (30 x 5 x 15) + (30 x 15 x 10) = 6,900</p>
<p>위와 같은 결과가 나온다. 즉 M1( (M2M3) M4) 순으로 곱하면 우리가 원하는 최종적인 결과를 얻을 수 있다.</p>
<h2 id="연쇄-행렬-곱셉-문제에서의-최적성의-원리"><a href="#연쇄-행렬-곱셉-문제에서의-최적성의-원리" class="headerlink" title="연쇄 행렬 곱셉 문제에서의 최적성의 원리."></a>연쇄 행렬 곱셉 문제에서의 최적성의 원리.</h2><p>n개의 행렬을 곱하는 최적의 순서는 n개의 행렬의 어떤 부분집합을 곱하는 최적의 순서를 포함한다.</p>
<p>ex)<br>7개 행렬을 곱하는 최적의 순서를 (M1M2)( (((M3M4) M5) M6) M7) 이라고 할 때 M3, M4, M5를 곱하는 최적의 순서는 ((M3M4) M5) 이다.<br>이렇게 부분 문제들의 최적해로 n개 행렬을 곱하는 최적의 순서를 구할 수 있기 때문에 최적성의 원리가 성립하므로 동적 프로그래밍 방법으로 해결 가능하다.</p>
<h2 id="연쇄-행렬-곱셈-문제의-점화식"><a href="#연쇄-행렬-곱셈-문제의-점화식" class="headerlink" title="연쇄 행렬 곱셈 문제의 점화식"></a>연쇄 행렬 곱셈 문제의 점화식</h2><p>n개의 행렬 $M_i$($D_{i-1}$ x $D_i$)(1 &lt;= i &lt; n)를 아래와 같이 연쇄적으로 곱하는 문제를 생각해보자.</p>
<p>$M_1$ x $M_2$ x $M_3$ x … x $M_{n-1}$ x $M_n$ =  ($d_0$ x $d_1$) x ($d_1$ x $d_2$) x ($d_2$ x $d_3$) x … x ($d_{n-2}$ x $d_{n-1}$) x ($d_{n-1}$ x $d_n$)</p>
<p>최적해를 구축하기 위해서 테이블 C[][]를 다음과 같이 정의한다.</p>
<ul>
<li><strong>C(i, j)</strong> = $M_i$ x $M_{i+1}$ x … x $M_{j-1}$ x $M_j$ 를 수행하는데 필요한 곱셈의 최소 횟수(비용).</li>
</ul>
<p>C(i, i) -&gt; C(i, i + 1) -&gt; C(i, i + 2) -&gt; … -&gt; C(1, n) 순으로 계산하므로 따라서 구하려는 n개 행렬을 연쇄적으로 곱하는데 필요한 최소 곱셈의 횟수는 C(1, n)이 된다.</p>
<ul>
<li>C(i, i) = 0</li>
<li>C(i, i + 1) = $d_{i-1}$$d_i$$d_{i+1}$ =&gt; $d_{i-1}$ x $d_{i+1}$</li>
<li>C(i, i + 2) = min{$M_i$($M_{i+1}$$M_{i+2}$)) + 결합비용, ($M_i$$M_{i+1}$)$M_{i+2}$ + 결합비용} = min{C(i,i) + C(i + 1, i + 2) + $d_{i-1}$$d_i$$d_{i+2}$, C(i, i+1) + C(i+2, i+2) + $d_{i-1}$$d_{i+1}$$d_{i+2}$}</li>
<li>C(i, i+3) = min{$M_i$($M_{i+1}$$M_{i+2}$$M_{i+3}$) + 결합비용, ($M_i$$M_{i+1}$)($M_{i+2}$$M_{i+3}$) + 결합비용, ($M_i$$M_{i+1}$$M_{i+2}$)$M_{i+3}$ + 결합비용} = min{C(i, i) + C(i+1, i+3) + $d_{i-1}$$d_i$$d_{i+3}$, C(i, i+1) + C(i+2, i+3) + $d_{i-1}$$d_{i+1}$$d_{i+3}$, C(i, i+2) + C(i+3, i+3) + $d_{i-1}$$d_{i+2}$$d_{i+3}$}</li>
</ul>
<p>즉 점화식은 다음과 같다. </p>
<ul>
<li><strong>C(i, j)</strong> = min{($M_i$ … $M_k$)($M_{k+1}$ … $M_j$) + 결합비용} = min{C(i, k) + C(k + 1,j) + $d_{i-1}$$d_k$$d_j$} (i &lt;= k &lt;= j-1)</li>
<li>C(i, i) = 0</li>
</ul>
<h2 id="알고리즘"><a href="#알고리즘" class="headerlink" title="알고리즘"></a>알고리즘</h2><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_VALUE 9999999</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">min</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> ( a &lt; b ) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> a;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * length: 행렬의 갯수</span></span><br><span class="line"><span class="hljs-comment"> * d[]: 정수 배열</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minMatMult</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> length, <span class="hljs-keyword">int</span> d[])</span> </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// n개의 행렬을 곱하는데 필요한 곱셈 횟수의 최솟값을 저장하는 배열.</span></span><br><span class="line">  <span class="hljs-keyword">int</span> **matrix =  <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * length);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= length; i++) &#123;</span><br><span class="line">    matrix[i] =  <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * length);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// mtarix[i][i] 초기화.</span></span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= length; i++) &#123;</span><br><span class="line">    matrix[i][i] = <span class="hljs-number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> f = <span class="hljs-number">1</span>; f &lt;= length - <span class="hljs-number">1</span>; f++) &#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n = <span class="hljs-number">1</span>; n &lt;= length - f; n++) &#123;</span><br><span class="line">      <span class="hljs-keyword">int</span> j = f + n;</span><br><span class="line">      </span><br><span class="line">      matrix[n][j] = MAX_VALUE;</span><br><span class="line"></span><br><span class="line">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = n; k &lt;= j - <span class="hljs-number">1</span>; k++) &#123;</span><br><span class="line">        matrix[n][j] = min(matrix[n][j], matrix[n][k] + matrix[k + <span class="hljs-number">1</span>][j] + d[n - <span class="hljs-number">1</span>] * d[k] * d[j]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">int</span> value = matrix[<span class="hljs-number">1</span>][length];</span><br><span class="line"></span><br><span class="line">  <span class="hljs-built_in">free</span>(matrix);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="작동-방법"><a href="#작동-방법" class="headerlink" title="작동 방법"></a>작동 방법</h2><p>3 x 2, 2 x 4, 4 x 1인 세개의 행렬 M1, M2, M3이 있다고 할 때 여기서 d0  = 3, d1 = 2, d2 = 4, d3 = 1 이므로  d[] = { 3, 2, 4, 1 }, length = 3 이 된다.</p>
<ol>
<li>초기화</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="center">0</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td>2</td>
<td align="center"></td>
<td align="center">0</td>
<td align="center"></td>
</tr>
<tr>
<td>3</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>C(i, i)  = 0 이므로 먼저 초기값을 세팅해준다. </p>
<ol start="2">
<li>f = 1, n = 1, j = 2</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="center">0</td>
<td align="center">24</td>
<td align="center"></td>
</tr>
<tr>
<td>2</td>
<td align="center"></td>
<td align="center">0</td>
<td align="center"></td>
</tr>
<tr>
<td>3</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>C(1, 2) = min{C(1, 1) + C(2, 2) + d0 x d1 x d2} = 0 + 0 + 3 x 2 x 4 이므로 24이다.</p>
<ol start="3">
<li>f = 1, n = 2, j = 3</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="center">0</td>
<td align="center">24</td>
<td align="center"></td>
</tr>
<tr>
<td>2</td>
<td align="center"></td>
<td align="center">0</td>
<td align="center">8</td>
</tr>
<tr>
<td>3</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>c(2, 3) = min{C(2, 2) + C(3, 3) + d1 x d2 x d3} = 0 + 0 + 2 x 4 x 1 이므로 8이다.</p>
<ol start="4">
<li>f = 2, n = 1, j = 3</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="center">0</td>
<td align="center">24</td>
<td align="center">14</td>
</tr>
<tr>
<td>2</td>
<td align="center"></td>
<td align="center">0</td>
<td align="center">8</td>
</tr>
<tr>
<td>3</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>C(1, 3) = min{C(1, 1) + C(2, 3) + d0 x d1 x d3, C(1, 2) + C(3, 3) + d0 x d2 x d3} = min (0 + 8 + 3 x 2 x 1, 24 + 0 + 3 x 4 x 1)  = min(14, 36) 이므로 14 이다.</p>
<p>C(1, length)을 반환하므로 최소 곱셉횟수는 C(1, 3) = 14 가 된다.</p>
<h2 id="성능"><a href="#성능" class="headerlink" title="성능"></a>성능</h2><p>위의 알고리즘 소스를 보면 for문이 3중으로 중첩된 것을 볼 수 있다.</p>
<p>O($\sum_{s=1}^{n-1}$[(n - s) X s]) = O($n^3$) 이므로 알고리즘의 시간 복잡도는 O($n^3$)이다.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920026935&condLscValue=001&condYr=&condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 알고리즘 5강</a><br><a href="https://huiyu.tistory.com/entry/DP-%EC%97%B0%EC%87%84%ED%96%89%EB%A0%AC-%EC%B5%9C%EC%86%8C%EA%B3%B1%EC%85%88-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98" target="_blank" rel="noopener">[DP] 연쇄행렬 최소곱셈 알고리즘</a><br><a href="https://twinparadox.tistory.com/183" target="_blank" rel="noopener">[Algorithm] 동적계획법 - 연속 행렬 곱셈 본문</a></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-05-12T13:35:49.000Z">2019-05-12</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Base/">Base</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Base/Algorithms/">Algorithms</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    3분 읽기 (나에 대하여 495 단어)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/05/12/2019-03-17-algorithms-fibonachi/">피보나치 수열</a>
            
        </h1>
        <div class="content">
            <h2 id="피보나치-수열"><a href="#피보나치-수열" class="headerlink" title="피보나치 수열"></a>피보나치 수열</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(0) = 0.</span><br><span class="line">f(1) = 1.</span><br><span class="line">f(n) = f(n - 1) + f(n -2), n &gt;= 2.</span><br></pre></td></tr></table></figure>

<p>피보나치 수열은 정의 자체가 최적성의 원리가 성립되는 점화식이므로 바로 동적 프로그래밍 방법을 적용할 수 있다.</p>
<p>2 이상인 n에 대해 f(n)은 그 소문제의 해인 f(n - 1)과 f(n - 2)의 합으로 구성되므로 f(0)과 f(1)을 먼저 테이블에 저장한 후 n을 2로부터 1씩 증가시키며 해를 구한 뒤 테이블에 저장한다. n에 어떤 값이 있더라도 f(n)을 구할 시점에는 f(n - 1)과 f(n - 2)가 항상 테이블에 저장되어 있으므로 테이블을 이용하여 즉시 f(n)을 구할 수 있다.</p>
<h2 id="알고리즘"><a href="#알고리즘" class="headerlink" title="알고리즘"></a>알고리즘</h2><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 50 이상의 수열에서는 int형 범위를 초과하기 때문에 double을 반환형으로 사용하였다.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">fibonachi</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">double</span> *fiboArr = (<span class="hljs-keyword">double</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">double</span>) * num);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// f(0)과 f(1)을 테이블에 저장한다.</span></span><br><span class="line">  fiboArr[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;</span><br><span class="line">  fiboArr[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// i를 2부터 1씩 증가시키며 f(i)의 해를 테이블에 저장된 f(i - 1)과 f(i - 2)의 합으로 계산하여 다시 테이블에 저장한다.</span></span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= num; i++) &#123;</span><br><span class="line">    fiboArr[i] = fiboArr[i - <span class="hljs-number">1</span>] + fiboArr[i - <span class="hljs-number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> fiboArr[num];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이렇게 하면 데이터를 저장하기 위해 필요한 테이블이 O(n) 에 비례해지는 단점이 있다.</p>
<figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">fibonachi</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> fibonachi(num - <span class="hljs-number">1</span>) + fibonachi(num - <span class="hljs-number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>재귀방식으로 구현할 수도 있으나 실행시간이 늘어난다는 단점이 있다.</p>
<h2 id="성능-분석"><a href="#성능-분석" class="headerlink" title="성능 분석"></a>성능 분석</h2><p>동적 프로그래밍 방식으로 푸는 경우 알고리즘의 for 루프는 구하려는 피보나치 수열의 순번 n만큼 반복하므로 시간 복잡도는 O(n)이다.</p>
<p>순환 호출 방식으로 푸는 경우 성능은 O($n^2$) 이다.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920026935&condLscValue=001&condYr=&condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 알고리즘 5강</a></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-05-12T12:53:04.000Z">2019-05-12</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Base/">Base</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Base/Algorithms/">Algorithms</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    3분 읽기 (나에 대하여 411 단어)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/05/12/2019-03-17-algorithms-dynamic-programming/">동적 프로그래밍 방법</a>
            
        </h1>
        <div class="content">
            <h2 id="동적-프로그래밍-방식"><a href="#동적-프로그래밍-방식" class="headerlink" title="동적 프로그래밍 방식"></a>동적 프로그래밍 방식</h2><p>문제의 크기가 작은 소문제에 대한 해를 저장해 놓고, 이를 이용하여 크기가 보다 큰 문제의 해를 점진적으로 만들어가는 상향식 접근 방법.</p>
<ul>
<li>각 작은 문제는 원래의 문제와 동일한 문제지만 입력의 크기만 작다.</li>
<li>입력의 크기가 아주 작은 단순한 문제가 되면 쉽게 해를 구할 수 있고 이를 테이블에 저장한다.</li>
<li>이후 해당 소문제의 해가 필요할 떄마다 테이블에 저장된 결과를 바로 이용한다.</li>
</ul>
<p>동적 프로그래밍 방법은 주로 최솟값 또는 최댓값 구하는 최적화 문제에 사용된다.</p>
<h3 id="최적성의-원리"><a href="#최적성의-원리" class="headerlink" title="최적성의 원리"></a>최적성의 원리</h3><p>동적 프로그래밍 방법은 최적성의 원리가 반드시 성립하는 최적화 문제의 대상이 된다. </p>
<ul>
<li><strong>최적성의 원리</strong>: 주어진 문제에 대한 최적해는 주어진 문제의 소문제에 대한 문제에 대한 최적해로 구성된다는 원리.</li>
</ul>
<h2 id="동적-프로그래밍-방법의-처리-과정"><a href="#동적-프로그래밍-방법의-처리-과정" class="headerlink" title="동적 프로그래밍 방법의 처리 과정"></a>동적 프로그래밍 방법의 처리 과정</h2><ol>
<li>주어진 문제에 대해서 최적해를 제공하는 점화식을 도출한다.</li>
<li>가장 작은 소문제부터 점화식의 해를 구한 뒤 이를 테이블에 저장한ㄷ나.</li>
<li>테이블에 저장되어 있는 소문제의 해를 이용하여 점차적으로 큰 상위 문제의 해를 구한다.</li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920026935&condLscValue=001&condYr=&condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 알고리즘 5강</a></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-05-10T10:55:08.000Z">2019-05-10</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Base/">Base</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Base/Algorithms/">Algorithms</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    11분 읽기 (나에 대하여 1714 단어)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/05/10/2019-03-17-algorithms-selection/">선택 문제</a>
            
        </h1>
        <div class="content">
            <h2 id="선택-문제"><a href="#선택-문제" class="headerlink" title="선택 문제"></a>선택 문제</h2><p>n개의 원소가 임의의 순서로 저장된 배열에서 i번째로 작은 원소를 찾는 문제.</p>
<ul>
<li>i = 1 이면 최솟값.</li>
<li>i = n/2 이면 중간값.</li>
<li>i = n 이면 최댓값.</li>
</ul>
<p>직관적인 방법으로는 오름차순으로 정렬한 후 i 번째 원소를 찾으면 되는데 이떄 성능은 o($n log n$)이다.<br>또 다른 직관적인 방법으로는 최솟값 찾는 과정을 i번 반복한다. i-1번째까지는 최솟값을 찾은 후 삭제한다. 이 경우에는 최솟값을 찾는데 걸리는 시간 O(n)을 i번 반복하기 때문에 성능은 O(in)이다.</p>
<h2 id="최솟값-찾기"><a href="#최솟값-찾기" class="headerlink" title="최솟값 찾기"></a>최솟값 찾기</h2><p>각 데이터를 하나씩 모드 비교한다. </p>
<figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMinimum</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> min = arr[<span class="hljs-number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (arr[i] &lt; min) &#123;</span><br><span class="line">      min = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>n개의 데이터에서 대해서 최소한 length - 1번의 비교가 필요하므로 성능은 O(n)이다.</p>
<h2 id="최솟값과-최대값-모두-찾기"><a href="#최솟값과-최대값-모두-찾기" class="headerlink" title="최솟값과 최대값 모두 찾기."></a>최솟값과 최대값 모두 찾기.</h2><p>최솟값과 최댓값을 모두 찾으려면 최솟값을 찾은 후에 최댓값을 찾거나 최댓값을 찾은 후 최솟값을 찾으면 된다.</p>
<figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findMinMax</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> min = arr[<span class="hljs-number">0</span>];</span><br><span class="line">  <span class="hljs-keyword">int</span> max = arr[<span class="hljs-number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// arr[0]과 arr[1]을 사용하여 최솟값/최댓값 초기화.</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (min &gt; max) &#123;</span><br><span class="line">    max = arr[<span class="hljs-number">0</span>];</span><br><span class="line">    min = arr[<span class="hljs-number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; length; i += <span class="hljs-number">2</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> small = <span class="hljs-number">0</span>, large = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 두 데이터 중에서 작은 값과 큰 값을 결정.</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (i &lt; length &amp;&amp; i + <span class="hljs-number">1</span> &lt; length &amp;&amp; arr[i] &lt; arr[i + <span class="hljs-number">1</span>]) &#123;</span><br><span class="line">      small = arr[i];</span><br><span class="line">      large = arr[i + <span class="hljs-number">1</span>];</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      small = arr[i + <span class="hljs-number">1</span>];</span><br><span class="line">      large = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 작은 값과 최솟 값을 비교.</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (small &lt; min) &#123;</span><br><span class="line">      min = small;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 큰 값과 최댓 값을 비교.</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (large &gt; max) &#123;</span><br><span class="line">      max = large;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"최댓값: %d, 최솟값: %d\n"</span>, max, min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위의 알고리즘을 이용하면 $(3/2 * n) - 2$번의 비교를 통해서 최솟값과 최댓값을 동시에 찾을 수 있다.</p>
<h3 id="i번째로-작은-원소-찾기-최악-O-n-2-평균-O-n"><a href="#i번째로-작은-원소-찾기-최악-O-n-2-평균-O-n" class="headerlink" title="i번째로 작은 원소 찾기: 최악 $O(n^2)$, 평균 O(n)"></a>i번째로 작은 원소 찾기: 최악 $O(n^2)$, 평균 O(n)</h3><p>퀵 정렬의 분할 함수 Partition()을 이용하면 모든 원소를 정렬하지 않고도 i번째로 작은 원소를 구할 수 있다.</p>
<ul>
<li>i = j 일때 피벗이 찾고자 하는 i 번째 원소.</li>
<li>i &lt; j 일때 왼쪽 부분배열에 대해 순환 적용.</li>
<li>i &gt; j 일때 오른쪽 부분배열에 대해 순환 적용.</li>
</ul>
<h4 id="분할"><a href="#분할" class="headerlink" title="분할"></a>분할</h4><p>피벗을 기준으로 주어진 배열을 두 부분배열로 분할한다. i가 피벗의 인덱스와 같으면 피벗의 값을 반환하고 종료한다.</p>
<h4 id="정복"><a href="#정복" class="headerlink" title="정복"></a>정복</h4><p>인덱스 i가 포함된 부분배열에 대해서 선택 알고리즘을 순환적으로 적용한다.</p>
<h4 id="결합"><a href="#결합" class="headerlink" title="결합"></a>결합</h4><p>필요 없다.</p>
<h4 id="알고리즘"><a href="#알고리즘" class="headerlink" title="알고리즘"></a>알고리즘</h4><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> temp = arr[a];</span><br><span class="line">    arr[a] = arr[b];</span><br><span class="line">    arr[b] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 퀵정렬에 사용된 분할 함수를 그대로 사용하면 된다.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> leftIndex, <span class="hljs-keyword">int</span> rightIndex)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">// 맨 왼쪽을 피벗으로 잡기 때문에 l_hold는 피벗의 위치 + 1, r_hold는 배열의 마지막 index</span></span><br><span class="line">  <span class="hljs-keyword">int</span> pivot = arr[leftIndex], l_hold = leftIndex + <span class="hljs-number">1</span>, r_hold = rightIndex;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">while</span> (l_hold &lt;= r_hold) &#123;</span><br><span class="line">    <span class="hljs-comment">// l_hold는 피벗보다 큰 값을 찾는다.</span></span><br><span class="line">    <span class="hljs-keyword">while</span> (l_hold &lt;= rightIndex &amp;&amp; arr[l_hold] &lt; pivot) &#123;</span><br><span class="line">      l_hold++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// r_hold는 피벗보다 작은 값을 찾는다.</span></span><br><span class="line">    <span class="hljs-keyword">while</span> (r_hold &gt; leftIndex &amp;&amp; arr[r_hold] &gt;= pivot) &#123;</span><br><span class="line">      r_hold--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">if</span> (l_hold &lt; r_hold) &#123;</span><br><span class="line">      <span class="hljs-comment">// arr[l_hold]와 arr[r_hold]의 값을 교환한다.</span></span><br><span class="line">      swap(arr, l_hold, r_hold);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 피벗과 arr[r_hold]값을 교환한다. </span></span><br><span class="line">  swap(arr, leftIndex, r_hold);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> r_hold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> leftIndex, <span class="hljs-keyword">int</span> rightIndex, <span class="hljs-keyword">int</span> findNum)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> pivot = partition(arr, leftIndex, rightIndex); <span class="hljs-comment">// 두 부분배열로 분할</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (findNum == pivot) &#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> arr[pivot];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (findNum &lt; leftIndex) &#123;</span><br><span class="line">      <span class="hljs-comment">// 왼쪽 부분배열에 대해 순환호출</span></span><br><span class="line">      <span class="hljs-keyword">return</span> findNumber(arr, leftIndex, pivot - <span class="hljs-number">1</span>, findNum);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      <span class="hljs-comment">// 오른쪽 부분배열에 대해서 순환호출</span></span><br><span class="line">      <span class="hljs-keyword">return</span> findNumber(arr, pivot + <span class="hljs-number">1</span>, rightIndex, findNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="성능분석"><a href="#성능분석" class="headerlink" title="성능분석"></a>성능분석</h4><p>최악의 경우 = 퀵 정렬의 최악의 경우 </p>
<ul>
<li>분할 함수가 항상 하나의 부분배열만 생성하는 경우.</li>
<li>오름차순으로 정렬된 상태에서 i = n을 찾는 경우.<ul>
<li>분할 함수 호출할 떄 마다 피벗의 인덱스는 1씩 증가. -&gt; Partition()을 O(n)번 호출. O($n^2$).</li>
<li>해결책은 항상 일정한 비율의 두 부분배열로 분할 시키면 된다.</li>
</ul>
</li>
</ul>
<p>평균적인 경우에는 O(n).</p>
<h3 id="i번째로-작은-원소-찾기-최악-O-n-평균-O-n"><a href="#i번째로-작은-원소-찾기-최악-O-n-평균-O-n" class="headerlink" title="i번째로 작은 원소 찾기: 최악 O(n), 평균 O(n)"></a>i번째로 작은 원소 찾기: 최악 O(n), 평균 O(n)</h3><p>특정한 성질을 만족하도록 피벗을 선택하되 항상 일정한 비율의 두 부분배열로 분할 시킨다. 그러면 항상 하나의 부분배열만으로 분할되는 문제를 피하여 최악의 수행 시간 O($n^2$)를 개선할 수 있다.</p>
<h4 id="피벗-선택-방법"><a href="#피벗-선택-방법" class="headerlink" title="피벗 선택 방법"></a>피벗 선택 방법</h4><ol>
<li>크기가 n인 배열의 원소를 5개씩 묶어 $n/5$개의 그룹을 형성한다. 이떄 n이 5의 배수가 되지 않아 그룹을 형성하지 못한 채 남은 원소들은 그대로 남겨둔다.</li>
<li>각 그룹에 대해서 중간 값을 찾는다.</li>
<li>$n/5$개의 중간값들을 대상으로 다시 중간값을 찾는다. </li>
<li>이렇게 계산된 ‘중간값들의 중간값’을 피벗으로 사용하여 주어진 배열을 분할한다.</li>
</ol>
<h4 id="알고리즘-1"><a href="#알고리즘-1" class="headerlink" title="알고리즘"></a>알고리즘</h4><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 삽입 정렬 함수</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> leftIndex, <span class="hljs-keyword">int</span> rightIndex)</span></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> i, j, key;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">for</span>(i = leftIndex + <span class="hljs-number">1</span>; i &lt;= rightIndex; i++)&#123;</span><br><span class="line">    key = arr[i]; <span class="hljs-comment">// 현재 삽입될 숫자인 i번째 정수를 key 변수로 복사</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 현재 정렬된 배열은 i-1까지이므로 i-1번째부터 역순으로 조사한다.</span></span><br><span class="line">    <span class="hljs-comment">// j 값은 음수가 아니어야 되고</span></span><br><span class="line">    <span class="hljs-comment">// key 값보다 정렬된 배열에 있는 값이 크면 j번째를 j+1번째로 이동</span></span><br><span class="line">    <span class="hljs-keyword">for</span>(j=i<span class="hljs-number">-1</span>; j&gt;=<span class="hljs-number">0</span> &amp;&amp; arr[j]&gt;key; j--)&#123;</span><br><span class="line">      arr[j+<span class="hljs-number">1</span>] = arr[j]; <span class="hljs-comment">// 레코드의 오른쪽으로 이동</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr[j+<span class="hljs-number">1</span>] = key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 분할 함수</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> leftIndex, <span class="hljs-keyword">int</span> rightIndex, <span class="hljs-keyword">int</span> pivot)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> swapIndex = leftIndex;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = leftIndex; i &lt;= rightIndex; i++) &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">      <span class="hljs-keyword">int</span> temp = arr[i];</span><br><span class="line">    </span><br><span class="line">      arr[i] = arr[swapIndex];</span><br><span class="line">      arr[swapIndex] = temp;</span><br><span class="line"></span><br><span class="line">      swapIndex += <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> swapIndex - <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">selection</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> leftIndex, <span class="hljs-keyword">int</span> rightIndex, <span class="hljs-keyword">int</span> findIndex)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> arrLength = rightIndex - leftIndex + <span class="hljs-number">1</span>;</span><br><span class="line">  <span class="hljs-keyword">int</span> medianNum = arrLength / <span class="hljs-number">5</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> &gt; findIndex &amp;&amp; findIndex &gt; arrLength) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 배열의 길이가 5보다 같거나 작으면 findIndex - 1번째 원소를 찾아 봔한한다.</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (arrLength &lt;= <span class="hljs-number">5</span>) &#123;</span><br><span class="line">    insertionSort(arr, leftIndex, rightIndex);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> arr[findIndex - <span class="hljs-number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">int</span> *maidanArr = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * medianNum);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 배열 arr에서 5개씩 원소를 묶어 n/5 개의 그룹을 만든 후 각 그룹에서 중간값을 구해 배열 maidanArr을 만든다.</span></span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; medianNum; i++) &#123;</span><br><span class="line">    maidanArr[i] = selection(arr, leftIndex + (<span class="hljs-number">5</span> * i), (leftIndex + (<span class="hljs-number">5</span> * (i+<span class="hljs-number">1</span>)<span class="hljs-number">-1</span>)), leftIndex + (<span class="hljs-number">5</span> * i) + <span class="hljs-number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 중간값들의 중간값을 계산하기 위해 선택 함수를 순환호출한다. </span></span><br><span class="line">  <span class="hljs-keyword">int</span> pivot = selection(maidanArr, <span class="hljs-number">0</span>, medianNum - <span class="hljs-number">1</span>, (medianNum / <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="hljs-comment">// pivot을 사용하여 배열 arr을 분할한다.</span></span><br><span class="line">  <span class="hljs-keyword">int</span> pivotIndex = partition(arr, leftIndex, rightIndex, pivot);</span><br><span class="line">  <span class="hljs-keyword">int</span> rank = pivotIndex - leftIndex + <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (findIndex &lt;= rank) &#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> selection(arr, leftIndex, pivotIndex, findIndex);</span><br><span class="line">  &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> selection(arr, pivotIndex + <span class="hljs-number">1</span>, rightIndex, findIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920026935&condLscValue=001&condYr=&condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 알고리즘 4강</a><br><a href="https://ronniej.sfuh.tk/kth-largest-element-array/" target="_blank" rel="noopener">프로그래밍 면접 문제 10 : Kth Largest Element in Array</a></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-03-17T16:13:13.000Z">2019-03-18</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Base/">Base</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Base/Algorithms/">Algorithms</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    5분 읽기 (나에 대하여 693 단어)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/03/18/2019-03-17-algorithms-merge-sort/">합병정렬</a>
            
        </h1>
        <div class="content">
            <h2 id="합병정렬"><a href="#합병정렬" class="headerlink" title="합병정렬"></a>합병정렬</h2><p>배열을 동일한 크기의 두 개의 부분배열로 분할하고 각각의 부분 배열을 순환적으로 정렬한 후, 정렬된 두 부분배열을 합병하여 하나의 정렬된 배열을 만든다.</p>
<h3 id="분할"><a href="#분할" class="headerlink" title="분할"></a>분할</h3><p>입력의 크기가 n인 배열을 n/2개의 원소를 가진 두 부분배열로 분할한다.</p>
<h3 id="정복"><a href="#정복" class="headerlink" title="정복"></a>정복</h3><p>각각의 부분배열에 대해서 합병 정렬을 순환적으로 적용하여 각 부분배열을 정렬한다. </p>
<h3 id="결합"><a href="#결합" class="headerlink" title="결합"></a>결합</h3><p>정렬된 두 부분배열을 합병하여 하나의 정렬된 배열을 만든다.</p>
<p><img src="/images/base/algorithms-merge-sort-1.png" alt="합병정렬"></p>
<h2 id="알고리즘"><a href="#알고리즘" class="headerlink" title="알고리즘"></a>알고리즘</h2><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> sorted[], <span class="hljs-keyword">int</span> leftIndex, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> rightIndex)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> l_hold = leftIndex, r_hold = mid + <span class="hljs-number">1</span>;</span><br><span class="line">  <span class="hljs-keyword">int</span> resultIndex = leftIndex; <span class="hljs-comment">// 결과 배열의 index</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">while</span>(l_hold &lt;= mid &amp;&amp; r_hold &lt;= rightIndex) &#123;</span><br><span class="line">    <span class="hljs-comment">// 부분배열 두개를 비교하여 작은 값을 선택한다.</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (arr[l_hold] &lt; arr[r_hold]) &#123;</span><br><span class="line">      sorted[resultIndex] = arr[l_hold];</span><br><span class="line"></span><br><span class="line">      l_hold++;</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      sorted[resultIndex] = arr[r_hold];</span><br><span class="line"></span><br><span class="line">      r_hold++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resultIndex++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 왼쪽 부분배열에 남아있는 모든 원소를 새로은 배열로 이동시킨다.</span></span><br><span class="line">  <span class="hljs-keyword">while</span> (l_hold &lt;= mid) &#123;</span><br><span class="line">    sorted[resultIndex] = arr[l_hold];</span><br><span class="line"></span><br><span class="line">    resultIndex ++;</span><br><span class="line">    l_hold ++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 오른쪽 부분배열에 남아있는 모든 원소를 새로은 배열로 이동시킨다.</span></span><br><span class="line">  <span class="hljs-keyword">while</span> (r_hold &lt;= rightIndex) &#123;</span><br><span class="line">    sorted[resultIndex] = arr[r_hold];</span><br><span class="line"></span><br><span class="line">    resultIndex ++;</span><br><span class="line">    r_hold ++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 원본 배열에 정렬된 배열을 이동 시킨다.</span></span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = leftIndex; i &lt;= rightIndex; i++) &#123;</span><br><span class="line">    arr[i] = sorted[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> sorted[], <span class="hljs-keyword">int</span> leftIndex, <span class="hljs-keyword">int</span> rightIndex)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (leftIndex &lt; rightIndex) &#123;</span><br><span class="line">    <span class="hljs-comment">// 각각 n/2크기를 가진 두 부분배열로 나누기 위해 가운데 값 정함.</span></span><br><span class="line">    <span class="hljs-keyword">int</span> mid = (leftIndex + rightIndex) / <span class="hljs-number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 왼쪽 부분배열의 순환호출</span></span><br><span class="line">    mergeSort(arr, sorted, leftIndex, mid);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 오른쪽 부분배열의 순환호출</span></span><br><span class="line">    mergeSort(arr, sorted, mid + <span class="hljs-number">1</span>, rightIndex);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 정렬된 두 부분배열의 합병</span></span><br><span class="line">    merge(arr, sorted, leftIndex, mid, rightIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="성능-분석"><a href="#성능-분석" class="headerlink" title="성능 분석"></a>성능 분석</h2><h3 id="합병-함수-수행-시간"><a href="#합병-함수-수행-시간" class="headerlink" title="합병 함수 수행 시간"></a>합병 함수 수행 시간</h3><p>합병 함수 수행 시간 = 부분배열[n/2] + 부분배열[n/2] = 배열[n]</p>
<p>두 부분 배열을 합병하면 최악의 경우 결과 배열엔 n + m개의 원소가 저장되는에 이때 최악의 경우  n + m - 1회의 비교가 필요하다. </p>
<ul>
<li>최소 비교횟수: $\frac{n}{2}$</li>
<li>최대 비교횟수: ($\frac{n}{2}$ + $\frac{n}{2}$ - 1) = n - 1;<br>=&gt; 입력 데이터 개수만큼의 저장 장소가 추가로 필요하다.</li>
</ul>
<p>결국 합병을 하는데 걸리는 시간은 입력 크기 n에 비례하므로 Θ(n)이 된다. </p>
<h3 id="합병-정렬-수행-시간"><a href="#합병-정렬-수행-시간" class="headerlink" title="합병 정렬 수행 시간"></a>합병 정렬 수행 시간</h3><p>합병 정렬 수행시간 = 크기 n/2인 두번의 합병 정렬 순환 호출 + 한번의 합병</p>
<p>T(1) = 1;<br>T(n) = T($\frac{n}{2}$) + T($\frac{n}{2}$) + Θ(n);</p>
<p>=&gt; T(n) = 2T($\frac{n}{2}$) + Θ(n)<br>=&gt; T(n) = O($n log n$)</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920026935&condLscValue=001&condYr=&condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 알고리즘 4강</a></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-03-17T10:15:00.000Z">2019-03-17</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Base/">Base</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Base/Algorithms/">Algorithms</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    7분 읽기 (나에 대하여 1062 단어)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/03/17/2019-03-11-algorithms-quick-sort/">퀵 정렬</a>
            
        </h1>
        <div class="content">
            <h2 id="퀵-정렬"><a href="#퀵-정렬" class="headerlink" title="퀵 정렬"></a>퀵 정렬</h2><p>특정 원소를 기준으로 주어진 배열을 두 부분배열로 분할하고, 각 부분배열에 대해서 퀵 정렬을 순환적으로 적용하는 방식.<br>특정 원소를 <strong>피벗</strong> 이라고 부름. 즉, 피벗이 제자리를 잡조록 하여 정렬하는 방식. 피벗의 왼쪽 부분배열엔 피벗보다 작은 값이, 오른쪽 부분배열엔 피벗보다 큰 값이 온다.</p>
<ul>
<li>피벗: 두 부분배열로 분할할 때 기준에 되는 특정 원소. 보통 주어진 배열의 첫 번째 원소로 지정한다. </li>
</ul>
<h3 id="분할"><a href="#분할" class="headerlink" title="분할"></a>분할</h3><p>피벗을 기준으로 주어진 배열을 두 부분배열로 분할한다.</p>
<h3 id="정복"><a href="#정복" class="headerlink" title="정복"></a>정복</h3><p>두 부분배열에 대해서 퀵 정렬을 순환적으로 적용하여 각 부분배열을 정렬한다.</p>
<h3 id="결합"><a href="#결합" class="headerlink" title="결합"></a>결합</h3><p>필요 없음</p>
<p><img src="/images/base/algorithms-quick-sort-1.png" alt="퀵정렬"></p>
<h2 id="알고리즘"><a href="#알고리즘" class="headerlink" title="알고리즘"></a>알고리즘</h2><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> temp = arr[a];</span><br><span class="line">    arr[a] = arr[b];</span><br><span class="line">    arr[b] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 배열의 맨 오른쪽 index엔 무한대 값이 있다고 가정한다.</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> leftIndex, <span class="hljs-keyword">int</span> rightIndex)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">// 맨 왼쪽을 피벗으로 잡기 때문에 l_hold는 피벗의 위치 + 1, r_hold는 배열의 마지막 index</span></span><br><span class="line">  <span class="hljs-keyword">int</span> pivot = arr[leftIndex], l_hold = leftIndex + <span class="hljs-number">1</span>, r_hold = rightIndex;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">while</span> (l_hold &lt;= r_hold) &#123;</span><br><span class="line">    <span class="hljs-comment">// l_hold는 피벗보다 큰 값을 찾는다.</span></span><br><span class="line">    <span class="hljs-keyword">while</span> (l_hold &lt;= rightIndex &amp;&amp; arr[l_hold] &lt; pivot) &#123;</span><br><span class="line">      l_hold++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// r_hold는 피벗보다 작은 값을 찾는다.</span></span><br><span class="line">    <span class="hljs-keyword">while</span> (r_hold &gt; leftIndex &amp;&amp; arr[r_hold] &gt;= pivot) &#123;</span><br><span class="line">      r_hold--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">if</span> (l_hold &lt; r_hold) &#123;</span><br><span class="line">      <span class="hljs-comment">// arr[l_hold]와 arr[r_hold]의 값을 교환한다.</span></span><br><span class="line">      swap(arr, l_hold, r_hold);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 피벗과 arr[r_hold]값을 교환한다. </span></span><br><span class="line">  swap(arr, leftIndex, r_hold);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> r_hold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> leftIndex, <span class="hljs-keyword">int</span> rightIndex)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (leftIndex &lt;= rightIndex) &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> pivot = partition(arr, leftIndex, rightIndex); <span class="hljs-comment">// 두 부분배열로 분할</span></span><br><span class="line"></span><br><span class="line">    quickSort(arr, leftIndex, pivot - <span class="hljs-number">1</span>);  <span class="hljs-comment">// 왼쪽 부분배열에 대해 순환호출</span></span><br><span class="line">    quickSort(arr, pivot + <span class="hljs-number">1</span>, rightIndex); <span class="hljs-comment">// 오른쪽 부분배열에 대해서 순환호출</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="성능-분석"><a href="#성능-분석" class="headerlink" title="성능 분석"></a>성능 분석</h2><p>퀵 정렬 알고리즘은 한 번의 분할과 두 번의 순환 호출로 구성된다.</p>
<h3 id="분할-함수-수행-시간"><a href="#분할-함수-수행-시간" class="headerlink" title="분할 함수 수행 시간"></a>분할 함수 수행 시간</h3><p>피벗을 제외한 배열의 원소들은 피벗과 최대 2번 비교 하게 된다. 전체적으로는 입력 크기 n에 비례하는 Θ(n) 시간이 걸린다.</p>
<h3 id="퀵-정렬-수행-시간"><a href="#퀵-정렬-수행-시간" class="headerlink" title="퀵 정렬 수행 시간"></a>퀵 정렬 수행 시간</h3><p>퀵 정렬 수행 시간 = 한 번의 분할 + 두번의 킉정렬 순환 호출.<br>배열 부분 시 두 부분배열의 크기가 다르기 때문에  배열이 어떤 크기의 두 부분배열로 분할되느냐에 따라 수행 시간이 다르다.</p>
<h4 id="최악의-경우"><a href="#최악의-경우" class="headerlink" title="최악의 경우"></a>최악의 경우</h4><p>극심한 불균형적 분할.</p>
<ul>
<li>피벗만 제자리를 잡고, 나머지 모든 원소가 하나의 부분배열로 분할되는 경우</li>
<li>피벗이 항상 부분배열의 최솟값, 또는 최댓값이 되는 경우</li>
<li>입력 데이터가 정렬되어 있고 피벗을 배열의 처음 원소로 지정한 경우</li>
</ul>
<p>T(n) = T(n-1) + T(0) + Θ(n) (n &gt; 0) // 한쪽은 데이터가 없으므로 T(0)<br>T(0) = 0</p>
<p>=&gt; T(n) = T(n - 1) + Θ(n)<br>=&gt; T(n) = O($n^2$)</p>
<h3 id="최선의-경우"><a href="#최선의-경우" class="headerlink" title="최선의 경우"></a>최선의 경우</h3><p>가장 균형적인 분할.</p>
<ul>
<li>피벗을 중심으로 항상 동일한 크기의 두 부분배열로 분할되는 경우 </li>
<li>피벗이 항상 부분배열의 중간값이 되는 경우 </li>
</ul>
<p>T(n) = T($\frac{n}{2}$) + T($\frac{n}{2}$) + Θ(n) (n &gt; 1)<br>T(1) = 1</p>
<p>=&gt; T(n) = 2T($\frac{n}{2}$) + Θ(n)<br>=&gt; T(n) = O($n log n$)</p>
<h3 id="평균적인-경우"><a href="#평균적인-경우" class="headerlink" title="평균적인 경우"></a>평균적인 경우</h3><p>부분배열의 모든 분할 비율에 따른 수행 시간의 평균.</p>
<ul>
<li>피벗은 동일한 확률로서 분할 후 배열의 어느 곳에나 위치 가능 </li>
</ul>
<p>T(1) = T(0) = 0<br>T(n) = $\frac{1}{n}\sum_{i = 1}^{n}(T(i - 1) + T(n - i)) + O(n) (n &gt;= 2)$</p>
<p>=&gt; T(n) = O($n log n$)</p>
<h2 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h2><ul>
<li>최선/ 평균의 경우 O($n log n$)</li>
<li>최악의 경우 O($n^2$)</li>
</ul>
<p>즉 피벗 선택의 임의성만 보장되면 평균적인 성능을 보일 가능성이 매우 높다. 그래서 배열에서 임의로 값을 선택해서 배열의 처음 원소와 서로 교환 후 정렬 수행하면 최악의 경우를 피할 가능성이 커진다. </p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920026935&condLscValue=001&condYr=&condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 알고리즘 3강</a></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-03-16T18:03:57.000Z">2019-03-17</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Base/">Base</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Base/Algorithms/">Algorithms</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    5분 읽기 (나에 대하여 710 단어)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/03/17/2019-03-11-algorithms-binary-search/">이진 탐색</a>
            
        </h1>
        <div class="content">
            <h2 id="이진탐색"><a href="#이진탐색" class="headerlink" title="이진탐색"></a>이진탐색</h2><ul>
<li><strong>탐색</strong>: 배열 형태로 주어진 데이터에서 원하는 값을 가진 데이터를 찾는 문제.</li>
<li><strong>이진 탐색</strong>: 정렬된 상태의 데이텅에 대해 적용 가능한 효과적인 탐색 방법.</li>
</ul>
<h2 id="탐색-방법"><a href="#탐색-방법" class="headerlink" title="탐색 방법"></a>탐색 방법</h2><p>배열은 오름차순 정렬 되어 있다고 가정한다.</p>
<p>###분할<br>배열의 가운데 원소를 기준으로 왼쪽 부분배열과 오른쪽 부분배열로 분할한다. 탐색키 x가 가운데 원소와 같으면 가운데 원소에 해당하는 배열의 인덱스를 반환하고 종료한다.</p>
<p>###정복<br>x가 가운데 원소보다 작으면 왼쪽 부분배열을 대상으로 이진 탐색을 순환호출 하고, 크면 오른쪽 부분배열을 대상으로 이진 탐색을 순환호출한다. 탐색을 다시 수행할 때마다 탐색 범위가 절반으로 줄어든다.</p>
<h3 id="결합"><a href="#결합" class="headerlink" title="결합."></a>결합.</h3><p>부분배열에 대해서 이진 탐색의 결과가 직접 반환되므로 결과를 결합할 필요가 없다. </p>
<p><img src="/images/base/algorithms-binary-search-1.png" alt="이진 탐색 분할"></p>
<h2 id="알고리즘"><a href="#알고리즘" class="headerlink" title="알고리즘"></a>알고리즘</h2><h3 id="재귀함수"><a href="#재귀함수" class="headerlink" title="재귀함수"></a>재귀함수</h3><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> leftIndex, <span class="hljs-keyword">int</span> rightIndex, <span class="hljs-keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// 탐색 실패</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (leftIndex &gt; rightIndex) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">int</span> mid = (leftIndex + rightIndex) / <span class="hljs-number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (x == arr[mid]) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> mid;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (x &lt; arr[mid]) &#123;</span><br><span class="line">    <span class="hljs-comment">// 왼족 배열 탐색</span></span><br><span class="line">    <span class="hljs-keyword">return</span> binarySearch(arr, leftIndex, mid - <span class="hljs-number">1</span>, x);</span><br><span class="line">  &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">    <span class="hljs-comment">// 오른쪽 배열 탐색</span></span><br><span class="line">    <span class="hljs-keyword">return</span> binarySearch(arr, mid + <span class="hljs-number">1</span>, rightIndex, x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="반복함수"><a href="#반복함수" class="headerlink" title="반복함수"></a>반복함수</h3><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch_Iteration</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> leftIndex = <span class="hljs-number">0</span>, rightIndex = index - <span class="hljs-number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="hljs-keyword">while</span>(leftIndex &lt;= rightIndex) &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> mid = (leftIndex + rightIndex) / <span class="hljs-number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (x == arr[mid]) &#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (x &lt; arr[mid]) &#123;</span><br><span class="line">      <span class="hljs-comment">// 왼쪽 부분배열 탐색</span></span><br><span class="line">      rightIndex = mid - <span class="hljs-number">1</span>;</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      <span class="hljs-comment">// 오른쪽 부분배열 탐색</span></span><br><span class="line">      leftIndex = mid + <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 탐색키가 존재하지 않을 경우</span></span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>이진 탐색에서는 분할 될 때마다 입력 크기가 절반으로 감소 하며, 탐색 대상의 개수가 1이 되면 더는 분할이 수행되지 않고 탐색 성공 여부가 결정된다.</p>
<h2 id="성능-분석"><a href="#성능-분석" class="headerlink" title="성능 분석"></a>성능 분석</h2><p>T(n) = 입력 크기 n에 대한 탐색 과정에서의 모든 비교 횟수의 합 = 맨 바깥 수준에서의 비교 횟수 + 순환 호출에서의 비교 횟수.</p>
<p>맨 바깥 수준에서의 비교 횟수는 상수이므로 1.<br>순환 호출에서의 비교 횟수는 비교 할 때마다 절반 씩 데이터를 나누므로 $\frac{n}{2}$.</p>
<p>T(n) = T($\frac{n}{2}$) + O(1)(n &gt; 1), T(1) = 1;<br>T(n) = O($logn$)</p>
<h2 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h2><ul>
<li>입력이 정렬된 리스트에 대해서만 적용이 가능하다.</li>
<li>데이터의 삽입/삭제 연산을 수행하면 데이터의 이동이 발생한다.<ul>
<li>평균 $\frac{2}{n}$개의 데이터 이동이 발생하므로 삽입/삭제가 빈번한 응용에는 부적합하다.</li>
</ul>
</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920026935&condLscValue=001&condYr=&condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 알고리즘 3강</a></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-03-10T17:03:57.000Z">2019-03-11</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Base/">Base</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Base/Algorithms/">Algorithms</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    4분 읽기 (나에 대하여 583 단어)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/03/11/2019-03-11-algorithms-divide-and-conquer/">분할정복 방법</a>
            
        </h1>
        <div class="content">
            <h2 id="분할정복-방법"><a href="#분할정복-방법" class="headerlink" title="분할정복 방법"></a>분할정복 방법</h2><p>순환적으로 문제를 푸는 하향식 접근 방법.</p>
<p>주어진 문제의 입력을 더 이상 나눌 수 없을 때까지 두 개 이상의 작은 문제들로 순환적으로 분할하고, 이렇게 분할된 작은 문제들을 각각 해결한 후 이들의 해를 결합하여 원래의 문제의 해를 구하는 방식.</p>
<h2 id="분할정복-방법-처리-과정"><a href="#분할정복-방법-처리-과정" class="headerlink" title="분할정복 방법 처리 과정"></a>분할정복 방법 처리 과정</h2><h3 id="분할"><a href="#분할" class="headerlink" title="분할"></a>분할</h3><p>주어진 문제를 여러 개의 작은 문제로 분할한다.</p>
<h3 id="정복"><a href="#정복" class="headerlink" title="정복"></a>정복</h3><p>작은 문제들을 순환적으로 분할한다. 만약 작은 문제가 더 이상 분할되지 않을 정도로 충분히 작다면 순환호출 없이 작은 문제의 해를 구한다. (정복)</p>
<h3 id="결합"><a href="#결합" class="headerlink" title="결합"></a>결합</h3><p>작은 문제에 대해 정복된 해를 결합하여 원래 문제의 해를 구한다. </p>
<h2 id="분할정복-방법의-특징"><a href="#분할정복-방법의-특징" class="headerlink" title="분할정복 방법의 특징"></a>분할정복 방법의 특징</h2><ul>
<li>분할된 작은 문제는 원래의 문제에 비해 입력 크기만 작아졌을 뿐 문제 자체는 원래 문제와 동일하다.</li>
<li>분할된 문제는 서로 독립적이기 때문에 각각의 작은 문제를 다시 순환적으로 분할하고 그 결과를 통합하는 것이 가능하다.</li>
</ul>
<h2 id="분할정복-방법을-적용한-알고리즘"><a href="#분할정복-방법을-적용한-알고리즘" class="headerlink" title="분할정복 방법을 적용한 알고리즘"></a>분할정복 방법을 적용한 알고리즘</h2><h3 id="이진-탐색"><a href="#이진-탐색" class="headerlink" title="이진 탐색"></a>이진 탐색</h3><p>  <img src="/images/base/algorithms-divide-and-conquer-1.png" alt="이진 탐색"><br>  크기가 n인 문제를 크기가 n/2인 두 개의 작은 문제로 분할한다. 그 중 하나의 작은 문제는 처리 대상에서 제외한다.</p>
<h3 id="합병-정렬"><a href="#합병-정렬" class="headerlink" title="합병 정렬"></a>합병 정렬</h3><p><img src="/images/base/algorithms-divide-and-conquer-2.png" alt="합병 정렬"><br>  크기가 n인 문제를 크기가 n/2인 두 개의 작은 문제로 분할한다.</p>
<h3 id="퀵-정렬"><a href="#퀵-정렬" class="headerlink" title="퀵 정렬"></a>퀵 정렬</h3><p><img src="/images/base/algorithms-divide-and-conquer-3.png" alt="퀵 정렬"><br>크기가 n인 문제를 쿠기는 감소하지만 일정하지 않은 크기의 두 개의 작은 문제로 분할한다.</p>
<h3 id="선택-문제"><a href="#선택-문제" class="headerlink" title="선택 문제"></a>선택 문제</h3><p><img src="/images/base/algorithms-divide-and-conquer-4.png" alt="선택 문제"><br>크기가 n인 문제를 크기는 감소하지만 일정하지 않은 크기의 두 개의 작은 문제로 분할한다. 그중 하나의 작은 문제는 처리 대상에서 제외한다. </p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920026935&condLscValue=001&condYr=&condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 알고리즘 3강</a></p>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-03-10T15:27:29.000Z">2019-03-11</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Base/">Base</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Base/Algorithms/">Algorithms</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    11분 읽기 (나에 대하여 1652 단어)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/03/11/2019-03-11-algorithms-analysis/">알고리즘 분석</a>
            
        </h1>
        <div class="content">
            <p>설계한 알고리즘은 무엇보다 정확하고 효율적인 알고리즘이어야 한다.</p>
<h2 id="정확성-분석"><a href="#정확성-분석" class="headerlink" title="정확성 분석"></a>정확성 분석</h2><p>정확한 알고리즘이라면 유효한 입력이 주어졌을 때 유한 시간 내에 정확한 결과를 생성해야 한다. 정확성 분석을 위해서는 다양한 수학적 기법을 사용하여 알고리즘이 예상한 대로 수행되는지에 대해 증명해야 한다.</p>
<h2 id="효율성-분석"><a href="#효율성-분석" class="headerlink" title="효율성 분석"></a>효율성 분석</h2><p>알고리즘 분석의 대부분의 경우 알고리즘이 주어진 문제를 시간적으로 또는 공간적으로 얼마나 효울적으로 풀 수 있는지를 판단하는 것을 의미한다. 해당 알고리즘을 수행하기 위해서 필요한 메모리의 양과 수행 시간을 통해서 효울성을 평가한다.</p>
<p>효율적인 알고리즘이란 ‘가능한 한 적은 메모리와 보다 빠른 수행 시간을 갖는 알고리즘’을 의미한다.</p>
<h3 id="공간-복잡도"><a href="#공간-복잡도" class="headerlink" title="공간 복잡도"></a>공간 복잡도</h3><p>알고리즘을 실행시켜 완료할 때까지 필요한 총 메모리의 양을 말한다.</p>
<h3 id="시간-복잡도"><a href="#시간-복잡도" class="headerlink" title="시간 복잡도"></a>시간 복잡도</h3><p>알고리즘을 실행시켜 완료될 때까지 걸리는 시간을 말한다. 이때 알고리즘을 평가하는 컴퓨터 환경, 프로그래밍 언어, 프로그램 작성 방법 등의 종속적인 요인을 배제해야만 객관적인 평가가 가능하다.</p>
<p>알고리즘의 수행 시간은 입력크기 n이 증가하면 수행 시간도 증가한다. 따라서 알고리즘의 수행 시간을 단순히 수행되는 단위 연산의 개수의 합으로 표현하기보다는 입력 크기 n에 대한 함수로 표현 하는 것이 바람직하다. </p>
<p>또한 알고리즘의 수행 시간은 주어진 입력 데이터의 상태에 따라 영향을 받는다. 예를 들어 정렬 알고리즘의 경우 데이터가 이미 정렬된 상태로 주어질 때 가장 빠른 수행 시간을 보이지만 데이터가 무작위인 경우에는 가장 나쁜 성능을 보여준다. 알고리즘에 입력되는 데이터의 상태가 항상 최적이라고는 가정할 수 없으므로 최선의 수행 시간이 아닌 일반적인 상황에서 소요되는 시간을 추정하는 것이 바람직하다.</p>
<p>평균 수행 시간을 택하는 것이 좋으나 일반적으로 평균 수행 시간을 구하는 과정에서 모든 경우의 입력상태와 그에 대한 각각의 수행 시간을 알기 어렵기 때문에 보통 ‘최악의 수행 시간’을 알고리즘의 시간 복잡도를 평가하는 일반적인 척도로 사용한다. </p>
<p><strong>최악 수행 시간</strong>: 알고리즘 수행 시간의 상한을 의미한다. 어떤 입력이 주어지더라도 이것 이상의 수행 시간은 걸리지 않는 다는 것을 보장하는 수행 시간이다.</p>
<h2 id="점근성능"><a href="#점근성능" class="headerlink" title="점근성능"></a>점근성능</h2><p>입력크기 n이 무한대로 커짐에 따라 결정되는 성능. </p>
<p>점근성능의 표기법으로는 Big-O, Big-Ω, Big-⍬ 표기법이 있다. 표기법에서 f(n)은 알고리즘의 수행시간을 나타낸다.</p>
<h3 id="Big-O-표기법"><a href="#Big-O-표기법" class="headerlink" title="Big-O 표기법"></a>Big-O 표기법</h3><p>어떤 양의 상수 c와 $n_0$이 존재하여 모든 n &gt;= $n_0$에 대하여 f(n) &lt;= cg(n)이면 f(n) = O(g(n))이다. 이때 O(n)은 최악의 수행시간이다. </p>
<p>f(n)이 O(g(n))이라는 것은 입력크기 n이 $n_0$ 이상으로 무한히 증가하더라도 f(n)의 값은 cg(n)보다 절대로 커질 수 없다는 의미로 G(n)을 상한으로 간주하기 때문에 함수의 점근적 상한을 나타낸다.</p>
<p>알고리즘의 시간 복잡도는 일반적으로 O- 표기를 사용해서 나타낸다. 아래와 같은 O- 표기법을 주로 사용한다. 맨 왼쪽의 상수 시간이 효율성이 제일 좋으며 오른쪽으로 갈 수록 비효율적이다.<br>O(1) &lt; O($logn$) &lt; O(n) &lt; O($nlong$) &lt; O($n^2$) &lt; O($n^3$) &lt; O($2^n$)</p>
<h3 id="Big-Ω-표기법"><a href="#Big-Ω-표기법" class="headerlink" title="Big-Ω 표기법"></a>Big-Ω 표기법</h3><p>어떤 양의 상수 c와 $n_0$이 존재하여 모든 n &gt;= $n_0$에 대하여 f(n) &gt;= cg(n)이면 f(n) = Ω(g(n))이다. 이때 Ω(g(n))은 최상의 수행시간이다.</p>
<h3 id="Big-⍬-표기법"><a href="#Big-⍬-표기법" class="headerlink" title="Big-⍬ 표기법"></a>Big-⍬ 표기법</h3><p>어떤 양의 상수 c와 $n_0$이 존재하여 모든 n &gt;= $n_0$에 대하여 $c_1$g(n) &lt;= f(n) &lt;= $c_2$g(n)이면 f(n) = ⍬(g(n))이다. 이때 ⍬(g(n))은 상한과 하한의 평균시간 이다.</p>
<p>점근적 상한과 하한을 동시에 갖는 경우로서 다른 표기법보다 성능을 정밀하게 나타낼 수 있다. </p>
<h2 id="효율적인-알고리즘의-중요성"><a href="#효율적인-알고리즘의-중요성" class="headerlink" title="효율적인 알고리즘의 중요성"></a>효율적인 알고리즘의 중요성</h2><p>동일한 문제를 해결하는 알고리즘이 여러 개 존재한다면 입력 크기 n이 증가하더라도 알고리즘의 수행 시간이 상대적으로 적게 증가하는 알고리즘을 선택해야 한다. 입력크기가 작으면 어느 알고리즘을 사용해도 수행 시간의 차이가 별로 없지만, 입력 크기가 크면 클 수록 수행 시간의 차이가 확연하게 나타나므로 효율적인 알고리즘을 설계하거나 선택하는 것이 중요하다. </p>
<table>
<thead>
<tr>
<th align="center">n</th>
<th align="center">f(n) = $logn$</th>
<th align="center">f(n) = n</th>
<th align="center">f(n) = $nlogn$</th>
<th align="center">f(n) = $n^2$</th>
<th align="center">f(n) = $n^3$</th>
<th align="center">f(n) = $2^n$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">8</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">8</td>
<td align="center">16</td>
<td align="center">64</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">3</td>
<td align="center">8</td>
<td align="center">24</td>
<td align="center">64</td>
<td align="center">512</td>
<td align="center">256</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center">4</td>
<td align="center">16</td>
<td align="center">64</td>
<td align="center">256</td>
<td align="center">4096</td>
<td align="center">65536</td>
</tr>
<tr>
<td align="center">32</td>
<td align="center">5</td>
<td align="center">32</td>
<td align="center">160</td>
<td align="center">1024</td>
<td align="center">32768</td>
<td align="center">4294967296</td>
</tr>
</tbody></table>
<h2 id="순환-알고리즘의-성능"><a href="#순환-알고리즘의-성능" class="headerlink" title="순환 알고리즘의 성능"></a>순환 알고리즘의 성능</h2><p><strong>순환(재귀) 알고리즘</strong>: 알고리즘 수행 과정에서 자기 자신의 알고리즘을 다시 수행하는 형태.</p>
<p>순환 알고리즘의 수행 시간을 나타내기 위한 방법으로 점화식이 사용된다.</p>
<table>
<thead>
<tr>
<th align="center">점화식</th>
<th align="center">폐쇄형</th>
<th align="center">비고</th>
</tr>
</thead>
<tbody><tr>
<td align="center">T(n) = $\begin{cases} ⍬(1), &amp; n = 1 \\ T(n - 1) + ⍬(1), &amp; n &gt;= 2 \end{cases}$</td>
<td align="center">T(n) =  ⍬(n)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">T(n) = $\begin{cases} ⍬(1), &amp; n = 1 \\ T(n - 1) + ⍬(n), &amp; n &gt;= 2 \end{cases}$</td>
<td align="center">T(n) =  ⍬($n^2$)</td>
<td align="center">퀵 정렬의 최악의 수행 시간</td>
</tr>
<tr>
<td align="center">T(n) = $\begin{cases} ⍬(1), &amp; n = 1 \\ T(\frac{n}{2}) + ⍬(1), &amp; n &gt;= 2 \end{cases}$</td>
<td align="center">T(n) =  ⍬($logn$)</td>
<td align="center">이진 탐색의 수행 시간</td>
</tr>
<tr>
<td align="center">T(n) = $\begin{cases} ⍬(1), &amp; n = 1 \\ T(\frac{n}{2}) + ⍬(n), &amp; n &gt;= 2 \end{cases}$</td>
<td align="center">T(n) =  ⍬($n$)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">T(n) = $\begin{cases} ⍬(1), &amp; n = 1 \\ 2T(\frac{n}{2}) + ⍬(1), &amp; n &gt;= 2 \end{cases}$</td>
<td align="center">T(n) =  ⍬($n$)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">T(n) = $\begin{cases} ⍬(1), &amp; n = 1 \\ 2T(\frac{n}{2}) + ⍬(n), &amp; n &gt;= 2 \end{cases}$</td>
<td align="center">T(n) =  ⍬($nlogn$)</td>
<td align="center">합병 정렬의 수행 시간, <br> 퀵 정렬의 최선의 수행 시간</td>
</tr>
</tbody></table>

        </div>
        
        
        
    </div>
</div>








    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-03-10T15:23:17.000Z">2019-03-11</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Base/">Base</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Base/Algorithms/">Algorithms</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    4분 읽기 (나에 대하여 663 단어)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/03/11/2019-03-02-algorithms-first/">알고리즘</a>
            
        </h1>
        <div class="content">
            <h2 id="알고리즘의-개념"><a href="#알고리즘의-개념" class="headerlink" title="알고리즘의 개념"></a>알고리즘의 개념</h2><p>알고리즘(algorithm)은 문제 해결을 위한 레시피(조리법)라고 할 수 있다. 알고리즘은 주어진 문제를 해결하기 위한 일련의 처리 과정을 단계적으로 나열한 것이다. 알고리즘의 단게적인 절차를 따르면 주어진 문제의 해를 구할 수 있다. </p>
<h2 id="알고리즘의-정의"><a href="#알고리즘의-정의" class="headerlink" title="알고리즘의 정의"></a>알고리즘의 정의</h2><ul>
<li><strong>입출력</strong><br>0개 이상의 외부 입력과 하나 이상의 출력이 있어야 한다.</li>
<li><strong>명확성</strong><br>각 명령은 모호하지 않고 단순 명확해야 한다.</li>
<li><strong>유한성</strong><br>한정된 수의 단계를 거친 후에는 반드시 종료해야 한다.</li>
<li><strong>유효성</strong><br>모든 명령은 컴퓨터에서 수행 가능해야 한다. </li>
</ul>
<p>알고리즘은 “주어진 문제에 대한 결과를 생성하기 위해 모호하지 않고 간단하며 컴퓨터가 수행 가능한 유한개의 일련의 명령들을 순서적으로 구성한 것” 이다. </p>
<p>알고리즘이 존재하는 문제일지라도 컴퓨터를 이용해서 해결하는데 현실적으로는 처리 결과를 기다릴 수 없을 정도의 상당히 긴 처리 시간을 구하는 문제도 있다. 즉 이론적으로는 알고리즘이 존재해서 ㅎ해결이 가능하지만 효율적으로 풀 수 없는 문제도 있다. 따라서 실용적인 관점에서 보면 알고리즘이 효율적이어야 한다는 것도 충분히 고려되고 만족되어야 할 중요한 조건임에 틀림없다. </p>
<h2 id="알고리즘의-생성"><a href="#알고리즘의-생성" class="headerlink" title="알고리즘의 생성"></a>알고리즘의 생성</h2><p>알고리즘으르 생성하려면 일련의 과정을 거쳐야 한다. </p>
<ol>
<li><p>설계<br>주어진 문제의 입출력 조건과 처리 조건 등을 분석해서 알고리즘을 설계한다. </p>
<ul>
<li>상향식 설계</li>
<li>하향식 설계</li>
</ul>
</li>
<li><p>표현 / 기술<br>설게가 완료된 알고리즘은 적절한 방법으로 표현한다. </p>
<ul>
<li>일상 언어</li>
<li>순서도</li>
<li>의사코드</li>
<li>프로그래밍 언어<br>…</li>
</ul>
</li>
<li><p>정확성 검증<br>알고리즘은 정확하고 효율적이어야만 실제 문제 해결에 안정적으로 사용될 수 있기 때문에 설계된 알고리즘의 정확성을 검증하고, 알고리즘이 얼마나 효율적인가를 분석하는 과정을 반드시 거친다. </p>
<ul>
<li>수학적 검증</li>
</ul>
</li>
<li><p>효율성 분석</p>
<ul>
<li>공간 복잡도</li>
<li>시간 복잡도</li>
</ul>
</li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://press.knou.ac.kr/goods/textBookView.do?condCmdtCode=9788920026935&condLscValue=001&condYr=&condSmst=" target="_blank" rel="noopener">방송대 컴퓨터과학과 알고리즘 1강</a></p>

        </div>
        
        
        
    </div>
</div>








</div>
                




<div class="column is-4-tablet is-4-desktop is-4-widescreen  has-order-1 column-left ">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered">
                <div>
                    
                        <img class="image is-128x128 has-mb-6" src="/images/me.jpg" alt="Kyoungah">
                    
                    
                    <p class="is-size-4 is-block">
                        Kyoungah
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        공부하고 익힌 것을 기록하고 있습니다.
                    </p>
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>Seoul</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        포스트
                    </p>
                    <p class="title has-text-weight-normal">
                        49
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        카테고리
                    </p>
                    <p class="title has-text-weight-normal">
                        16
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        태그
                    </p>
                    <p class="title has-text-weight-normal">
                        14
                    </p>
                </div>
            </div>
        </nav>
        <div class="level">
            <a class="level-item button is-link is-rounded follow-link" href="http://github.com/partyKyoung" target="_blank">
                팔로우</a>
        </div>
        
        
        <div class="level is-mobile">
            
            <a class="level-item button is-white is-marginless" target="_blank" title="Github" href="http://github.com/partyKyounf">
                
                <i class="fab fa-github"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" title="Facebook" href="http://facebook.com">
                
                <i class="fab fa-facebook"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" title="Twitter" href="http://twitter.com">
                
                <i class="fab fa-twitter"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" title="Dribbble" href="http://dribbble.com">
                
                <i class="fab fa-dribbble"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" title="RSS" href="/">
                
                <i class="fas fa-rss"></i>
                
            </a>
            
        </div>
        
    </div>
</div>
    
        
    
        


    
        
<div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                카테고리
            </h3>
            <ul class="menu-list">
            <li>
        <a class="level is-marginless" href="/categories/Back-end/">
            <span class="level-start">
                <span class="level-item">Back-end</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">3</span>
            </span>
        </a><ul><li>
        <a class="level is-marginless" href="/categories/Back-end/Node-js/">
            <span class="level-start">
                <span class="level-item">Node.js</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">3</span>
            </span>
        </a></li></ul></li><li>
        <a class="level is-marginless" href="/categories/Base/">
            <span class="level-start">
                <span class="level-item">Base</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">26</span>
            </span>
        </a><ul><li>
        <a class="level is-marginless" href="/categories/Base/Algorithms/">
            <span class="level-start">
                <span class="level-item">Algorithms</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">10</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Base/Computer-security/">
            <span class="level-start">
                <span class="level-item">Computer security</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">3</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Base/Data-Structure/">
            <span class="level-start">
                <span class="level-item">Data Structure</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">2</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Base/Information-network/">
            <span class="level-start">
                <span class="level-item">Information network</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">2</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Base/Operating-systems/">
            <span class="level-start">
                <span class="level-item">Operating systems</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">7</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Base/Software-engineering/">
            <span class="level-start">
                <span class="level-item">Software engineering</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">2</span>
            </span>
        </a></li></ul></li><li>
        <a class="level is-marginless" href="/categories/Etc/">
            <span class="level-start">
                <span class="level-item">Etc</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">2</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Front-end/">
            <span class="level-start">
                <span class="level-item">Front-end</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">17</span>
            </span>
        </a><ul><li>
        <a class="level is-marginless" href="/categories/Front-end/Css/">
            <span class="level-start">
                <span class="level-item">Css</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Front-end/Etc/">
            <span class="level-start">
                <span class="level-item">Etc</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">2</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Front-end/React-js/">
            <span class="level-start">
                <span class="level-item">React.js</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">8</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Front-end/TypeScript/">
            <span class="level-start">
                <span class="level-item">TypeScript</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">4</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Front-end/memo/">
            <span class="level-start">
                <span class="level-item">memo</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">2</span>
            </span>
        </a></li></ul></li>
            </ul>
        </div>
    </div>
</div>
    
        
<div class="card widget tags">
    <div class="card-content">
        <h3 class="menu-label">
            태그 클라우드
        </h3>
        <a href="/tags/Algorithms/" style="font-size: 20px;">Algorithms</a> <a href="/tags/CSS/" style="font-size: 11.67px;">CSS</a> <a href="/tags/Computer-security/" style="font-size: 13.33px;">Computer security</a> <a href="/tags/Data-structure/" style="font-size: 11.67px;">Data structure</a> <a href="/tags/HTML/" style="font-size: 11.67px;">HTML</a> <a href="/tags/Information-network/" style="font-size: 11.67px;">Information network</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Next-js/" style="font-size: 11.67px;">Next.js</a> <a href="/tags/Node-js/" style="font-size: 13.33px;">Node.js</a> <a href="/tags/Operating-systems/" style="font-size: 16.67px;">Operating systems</a> <a href="/tags/React-js/" style="font-size: 18.33px;">React.js</a> <a href="/tags/Software-engineering/" style="font-size: 11.67px;">Software engineering</a> <a href="/tags/TypeScript/" style="font-size: 15px;">TypeScript</a> <a href="/tags/etc/" style="font-size: 11.67px;">etc</a>
    </div>
</div>

    
    
        <div class="column-right-shadow is-hidden-widescreen ">
        
        </div>
    
</div>

                
            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/kyoungah.png" alt="경아&#39;s 개발일기" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2019 경아&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a href="http://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>
                
                </p>
            </div>
            <div class="level-end">
            
                <div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle">
                
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Creative Commons" href="https://creativecommons.org/">
                        
                        <i class="fab fa-creative-commons"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/">
                        
                        <i class="fab fa-creative-commons-by"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Download on GitHub" href="http://github.com/ppoffice/hexo-theme-icarus">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                </p>
                
                </div>
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("ko");</script>


    
    
    
    <script src="/js/animation.js"></script>
    

    
    
    
    

<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


    
    
<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>

    
    

<a id="back-to-top" title="Back to Top" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>


    
    

    
    
    
    

    
    
    
    
    
    <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>
    <script src="/js/clipboard.js" defer></script>
    

    
    
    


<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="입력 하세요...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '포스트',
                PAGES: '페이지',
                CATEGORIES: '카테고리',
                TAGS: '태그',
                UNTITLED: '(제목없음)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>